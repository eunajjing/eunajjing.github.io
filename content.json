{"meta":{"title":"ERecord","subtitle":"일상 및 개발 공부 기록용 블로그","description":"일상 및 개발 공부 기록용 블로그","author":"euna","url":"http://eunajjing.github.io"},"pages":[{"title":"Categories","date":"2016-08-16T06:00:44.000Z","updated":"2018-12-07T09:47:13.380Z","comments":false,"path":"categories/index.html","permalink":"http://eunajjing.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"우아한테크코스 Typescript & React 101 01","slug":"woowahan01","date":"2019-05-15T02:47:18.000Z","updated":"2019-05-15T04:59:26.966Z","comments":true,"path":"2019/05/15/woowahan01/","link":"","permalink":"http://eunajjing.github.io/2019/05/15/woowahan01/","excerpt":"","text":"구구절절나는 어쩌다가 이 강의를 듣게 되었나이 시리즈는 내가 어떤 공부를 했다, 의 기록 겸 느낀점 기록에 치중될 예정이다. 나는 프로 구구절절러이기 때문에(…) 이 과정을 어떻게 입과(라는 용어가 합당한가?)하게 되었는지도 쓸 것. 시작은 단순히 친한 언니가 이런 과정이 있다더라, 라고 소개해준 것. 당시 나는 리액트로 당장 프로젝트 구현은 해야하는데, 아무 것도 모르는 상황이라 닥치는대로 리액트 정보를 흡수 중에 있었다. 지인들에게 힘든 티를 팍팍 냈더니(죄송) 건너서 이런 식으로도 정보가 왔다. 문제는 이런 강의가 다 그렇듯 공급에 비해 수요가 너무 많다는 것. 이 소식을 듣자마자 신청했지만, 되리라는 생각은 별로 안했다. 그런데 운이 좋게도 당첨(로또는 아니지만 당첨이란 말이 어울린다고 생각한다! sns에 안됐다는 사람 꽤 봐서)이 되어 손 꼽아 해당 강좌를 기다렸고, 어제가 해당 첫날이었다. 우형 사무실이 얼마나 좋은지는 굳이 쓸 필요 없을 거 같아서… 쓰지 않는다… 이 과정의 타겟은 누구인가알고 보니, 해당 과정은 내부 개발자 교육을 하기 위해 만들어졌다고 했다. 그런데 겸사겸사 외부 개발자들도 참여할 수 있게 열었고, 100여명을 선발했으며 50%는 우형 개발자라고 했다. 즉 프론트엔드 개발자는 아닌데, 당장 뭔가를 만들어야 하는 백엔드 &amp; 앱 개발자를 대상으로 한다고. 하지만 외부에서 온 개발자의 90%는 프론트엔드를 전문으로 하시는 분들이 뽑히셨다고 했다. 그래서 해당 강좌는 자바스크립트에 나름 익숙하며, dom을 다룬 적이 있는 사람을 대상으로 하는 것 같았다. 와중에 듣다가 우형에서 프론트만 전문적으로 하시는 분이 20여명 계신다고 듣게 됐다. 수가 적은 터라 프론트 개발자가 필요한 모든 곳에 가 개발할 수 없다보니, 다른 분야를 하시던 분들이 프론트를 만들 수밖에 없는 상황이 되었다고. 라인 프론트 데브에서는(이거 후기 언제 쓰냐) 라인 내 프론트 개발자가 30여명이라고 했는데, 둘 다 큰 회사인데도 전문적인 프론트 엔지니어 수가 생각보다 적어서 놀랐다. 라인 데브 후에 네트워킹에도 참여했다. 참여자 대부분이 각 회사에서 프론트 단만을 전문적으로 개발하시는 분들이었다. 그런데 네트워킹 주최하신 분이 “다들 회사에서 프론트 혼자 하시거나 되게 소수시지 않냐~”라는 식으로 말을 꺼냈던 게 기억이 났다. 프론트가 수요는 있는데… 전문적으로 하시는 분들은 많지 않다는, 어디선가 들은 이야기가 생각 났다. 나는 왜 현재 이 강의를 듣는가그동안 진짜 농담이 아니라 리액트만 했다. (DB와 스프링이 아득하다) 스스로 현재 상태를 가늠하기엔 예쁜 마크업은 자신이 없는데, 어떻게든 리액트로 무언가를 완성할 수 있는 상태…인 것 같다. 그래서 리액트 기초를 듣는 것도 좋지만, 알고 있는 것과 모르는 것을 구분하고, 모르지만 개발을 하기 위해선 알아야 하는 것들을 배우는 것도 좋을 것 같았다. 그럼에도 불구하고 나는 리액트 기초 강의를 현재 두 개나 듣고 있고, 하나는 심지어 유료 강의다. 그래서 주변에서… 왜 굳이 교육을 듣냐고, 이제 공식 문서를 보고 포폴용 프로젝트 개발하면 되는 거 아니냐고 하시는 분들도 많은데(영어 못해…!) 성향 때문인 것 같다. 어쨌든 나는 교육을 듣고 있을 때 제일 열심히 하는 사람이니까. 옆에서 누군가가 하고 있어야 부담스러워하면서(하기 싫어하면서) 나도 하는 사람이라, 원동력이 필요했다. 스터디도 들어봤지만, 스터디도 너무 케바케라서 모르는 게 생기면 바로바로 질문할 수 있는 교육을 더 선호하는 것 같다. 어쨌든 기초도 이해는 하지만 계속 까먹는 걸… 이 강의에서 내가 얻고자 하는 것은 아래와 같다. 타입스크립트와 리액트의 혼용은 어떻게 하냐 그래서 리액트로 뭘 어떻게 구현하는지 (프론트에 들어가는 비지니스 로직 및 Ui 라이브러리 보통 뭐 쓰시는지) 리덕스 개념 다시 잡기 자바스크립트 개념 다시 잡기 자바 스크립트는 정말 해도 해도 늘… 어려운 것 같다… 어제 우형 측에서 자바스크립트 기초 강의를 할 수는 없는 노릇이니, 링크 하나 주시면서 필요한 분들은 이걸 보는 것도 좋을 것 같다고 하셨다. 그거 가지구 모르는 거 생기면 읽으며 공부할 예정 (근데 해당 링크 공유해도 되는 건진 모르겠어서 기록하진 않는다) 시작보일러 플레이트로 만든 creact react-app만들 어플리케이션은 모두 타입스크립트 기반으로 만들기 때문에 create react-app 때 옵션 값인 --typescript를 써줘야 한다. 즉 yarn create react-app projectName --typescript 아, 나처럼 projectName을 명령어의 일환으로 볼 사람이 있을까 덧붙인다(왜 그랬어 과거의 나) projectName은 본인이 사용하고 싶은 프로젝트 제목을 넣어주면 된다. 오 그 전에 vsCode node.js npx or yarn 을 깔아주어야 함. Yarn과 npx는 하는 패키지 관리자로 역할이 거의 같은데, 많은 예제에서 Yarn을 쓰시는데다가 더 빠르다는 이야기를 들어서 나는 계속 yarn을 썼다. 어떤 패키지 관리자를 쓰느냐에 따라 명령어에 조금씩 차이가 있다. 이렇게 프로젝트를 만들면 이런 파일 구조가 생긴다. 보일러 플레이트로 생성한 프로젝트 구조의 경우, 바꾸려면 꽤 까다롭다. 특히 src 폴더를 바꾸고자 하는 움직임이 좀 있었다고 들었는데(이를테면 이름이라던가) 페이스북 측에서 들어주지 않는다고 했다. 순수한 create react-app과 조금 다른 점은, 확장자와 tsconfig.json이다. tsconfig.json타입스크립트 컨파일하기 위한 설정들이 담긴 파일이라고 한다. .tsxts는 js와 같은 타입스크립트 코드로만 이루어진 경우에 붙고, 여기에 x가 붙으면 ui 컴포넌트라는 뜻이 된다. 리액트와 달리 설정해줘야 하는 것 타입스크립트는 자바스크립트의 객체/변수들에 타입을 명명해주는 게 큰 특징이다. 때문에 패키지들 또한 타입이 있어야 한다. 리액트는 타입스크립트 쪽에서 가지고 있는 저장소에 타입이 지정되어있다. 해당 리액트 타입의 경우 디폴트 익스포트가 없다. 때문에 따로 수정을 해줘야 한다. 아래는 수정 전. create react-app으로 구현한 것과 소스가 일치한다. 12import React from 'react';import ReactDOM from 'react-dom'; 아래는 수정 후, 디폴트 익스포트가 없기 때문에 모든 것을 가져오는 * 키워드를 써주고, alias를 붙여준다.안 붙여주면 안된다! 이렇게 가져온 모듈은 객체처럼 쓸 수 있다 moduleName.blahblah() 12import * as React from 'react';import * as ReactDOM from 'react-dom'; 그 외 리액트와 비슷한 것 from 뒤의 패스가 상대경로이거나 이름만 덜렁 있는 경우가 있다. 이름만 있는 경우에는 패키지 관리자를 통해 가져온 모듈이며 해당 모듈은 node_moudules라는 폴더에 있다 익스포트는 여러 개를 할 수도 있고 다른 파일에서 임포트할 때 디폴트 모듈이 온다. 예전부터 궁금했다, entry point인 index.js의 react 모듈! ReactDOM을 사용해서 render하긴 하는데, 도대체 react 모듈은 어디에 쓰이나. 가상 DOM을 만들 적 내부적으로 사용된다고. 때문에 모두 리액트 모듈을 포함해야 한다. 이미지 파일이나 css 파일은 js 파일이 아닌데 어떻게 Js와 해서 쓸 수 있나 번들러가 합쳐주는 역할을 수행한다. 그래서 이렇게 쓸 수 있는 것 123&gt; import logo from './logo.svg';&gt; import './App.css';&gt; 컴포넌트를 만드는 방법크게 3가지이다. 일반 컴포넌트 퓨어 컴포넌트 일반 컴포넌트의 기능 중 많이 쓰는 기능만을 가지고 있으며 상대적으로 가볍다. 함수형 컴포넌트 화면을 그리는데 사용하며, 라이프사이클이 없다. index.tsx123456789101112131415import * as React from \"react\";import &#123; render &#125; from \"react-dom\";// react-dom 모듈 중 특정한 것만 가지고 올 때 이렇게 쓴다.// 여러 개 가지고 올 때는 콤마로 구분import App from \"./App\";const rootElement: HTMLElement = document.getElementById(\"root\");// : ~ 는 타입을 기술한 것// 타입스크립트는 값을 추론해서 타입을 넣어주기 때문에 안 써도 되는 경우가 있긴 한데// 함수의 리턴 타입을 명시하지 않았을 경우 이렇게 받을 때 명시하기도 함// any라는 타입은 다 사용 가능하다 (그럼 왜 타입스크립트를 쓰는 걸까... 자바스크립트 화)// 사실 위의 코드에서 해당 타입은 안 써도 된다.render(&lt;App /&gt;, rootElement); 보일러 플레이트를 만들어보아요! 구조 컴포넌트는 크게 버튼, 카드로 구성되어 있고 두 개의 컴포넌트를 감싸고 있는 부모 컴포넌트 App.tsx가 있는 형태 버튼12345678910111213141516171819202122232425262728293031323334353637383940414243444546import * as React from \"react\";import &#123; Button &#125; from \"antd\";// 버튼 ui 가지고 옴interface PlayButtonProps &#123; // 타입을 정의하기 위해 인터페이스 사용 monitoring: boolean; onPlay?: () =&gt; void; onPause?: () =&gt; void; // 위의 인터페이스는 세 개의 프로퍼티를 받는다. // 프로퍼티의 타입 또한 지정할 수 있으며 // 이들은 객체가 아니기 때문에 세미콜론으로 끝을 맺는다. // ?는 프로퍼티가 옵션이라는 뜻&#125;export const PlayButton: React.FC&lt;PlayButtonProps&gt; = props =&gt; &#123; // React.FC 리액트의 함수 컴포넌트이며 // 해당 함수 컴포넌트의 제네릭타입은 위에 기술한 PlayButtonProps 인터페이스이다. const [isPlay, togglePlay] = React.useState(props.monitoring); // 이건 나중에 설명한다고 했는데... const renderIcon = isPlay ? \"pause\" : \"caret-right\"; return ( &lt;div&gt; &lt;Button style=&#123;&#123; marginTop: 20 &#125;&#125; shape=\"circle\" icon=&#123;renderIcon&#125; // 여기까지는 ui 라이브러리 도큐먼트를 그대로 따른 것 onClick=&#123;() =&gt; &#123; if (isPlay) &#123; props.onPause &amp;&amp; props.onPause(); // and 연산자 // 처음이 참(존재하고)이며 뒤가 함수이면 함수 실행 &#125; else &#123; props.onPlay &amp;&amp; props.onPlay(); &#125; togglePlay(!isPlay); // 훅인데 지금은 설명하지 않음 &#125;&#125; /&gt; &lt;/div&gt; );&#125;; 타입을 정의하는 방식 인터페이스 사용 타입 정의 보통은 인터페이스를 많이 사용한다고 한다. 개인적으로 그랲큐엘과 자바 두 개 다 다뤄봐서 그런지 둘 다 익숙한 방법이었다. 카드1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import * as React from \"react\";import &#123; Card &#125; from \"antd\";// 마찬가지로 ui 모듈interface OrderStatusProps &#123; success: number; failure: number;&#125;export const MonitorCard: React.FC&lt;OrderStatusProps&gt; = props =&gt; &#123; const errorRate: string = // 해당 결과 값은 string 타입이다 props.failure &gt; 0 // 실패 결과가 0건 이상이면 ? Number((props.failure / props.success) * 100).toFixed(2) // 실패율을 구한다, 소수점 두 자리까지 자르고 리턴 : \"0\"; const formattedNumber = (value: number): string =&gt; // 프로퍼티 앞에 바로 : 찍고 타입을 기입하면 해당 함수의 리턴 타입 대한 정의을 뜻한다. // :string이므로 해당 함수는 String 자료형을 리턴한다. String(value).replace(/(\\d)(?=(?:\\d&#123;3&#125;)+(?!\\d))/g, \"$1,\"); // 1000단위마다 콤마를 찍는다 return ( &lt;Card bordered=&#123;false&#125; bodyStyle=&#123;&#123; background: \"#fff\", padding: \"24px\" &#125;&#125; // 속성의 value를 줄 때 문자열은 \"\"에 싸서 주면 되고, // 그 외의 값, 자바스크립트의 value를 줄 때는 &#123;&#125; 안에 기술 // &#123;&#125;를 두 번 연속해서 사용한 건 객체가 value일 때 &gt; &lt;div className=\"wrapper\"&gt; &lt;div className=\"item\"&gt; &lt;p&gt;Success&lt;/p&gt; &lt;p style=&#123;&#123; color: \"#000\" &#125;&#125;&gt; &lt;span&gt;&#123;formattedNumber(props.success)&#125;&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div className=\"item\"&gt; &lt;p&gt;Failure&lt;/p&gt; &lt;p style=&#123;&#123; color: \"#000\" &#125;&#125;&gt; &lt;span&gt;&#123;formattedNumber(props.failure)&#125;&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div className=\"item\"&gt; &lt;p&gt;Error Rate&lt;/p&gt; &lt;p style=&#123;&#123; color: \"#000\" &#125;&#125;&gt; &lt;span&gt;&#123;errorRate&#125;&lt;/span&gt; &lt;span className=\"unit\"&gt;%&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Card&gt; );&#125;; index.js컴포넌트들을 익스포트한다. 12export * from \"./MonitorCard\";export * from \"./PlayButton\"; app.tsx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import * as React from \"react\";import &#123; MonitorCard, PlayButton &#125; from \"./components\";// 폴더명을 경로로 줬기 때문에 자연스럽게 index.js를 불러오게 되고,// index.js에서 컴포넌트들을 미리 익스포트 했기 때문에 쉽게 사용 가능하다.import &#123; Typography &#125; from \"antd\";// ui 라이브러리를 쓰기 위해 이렇게 사용import \"antd/dist/antd.css\";import \"./sass/main.scss\";interface Application &#123; timerId: number; state: &#123; success: number; failure: number; &#125;; onStart(): void; onStop(): void;&#125;export default class App extends React.Component implements Application &#123; // class이므로 인터페이스를 상속 받아서 써도 된다. // 제네릭으로 해도 됨 timerId: number = 0; // 위에 정의되어 있기 때문에 기술할 필요는 없음 // class field 문법으로 실행 블록인 것인 양 써도 된다. // 실제로 timerId는 인스턴스의 멤버로 들어간다 (스태틱이 아님) state = &#123; success: 0, failure: 0 &#125;; onStart = () =&gt; &#123; this.timerId = setInterval(() =&gt; &#123; this.setState(&#123; success: this.state.success + Math.floor(Math.random() * (100 - 1) + 1), failure: this.state.failure + Math.floor(Math.random() * 2 - 0) &#125;); // 상태가 바뀌면 렌더 함수가 호출됨 &#125;, 200); &#125;; // 애로우 펑션의 this는 항상 해당 클래스의 인스턴스로 고정된다. onStop = () =&gt; &#123; clearInterval(this.timerId); this.timerId = 0; &#125;; render() &#123; return ( &lt;div&gt; &lt;header&gt; &lt;Typography.Title&gt;React &amp; TS Boilerplate&lt;/Typography.Title&gt; &lt;Typography&gt;Order Monitor&lt;/Typography&gt; &lt;/header&gt; &lt;main&gt; &lt;MonitorCard success=&#123;this.state.success&#125; // new 키워드를 통해 인스턴스 생성을 하지 않지만, // 내부적으로는 분명히 인스턴스이므로 this라는 키워드를 사용 failure=&#123;this.state.failure&#125; /&gt; &lt;PlayButton monitoring=&#123;false&#125; onPlay=&#123;this.onStart&#125; onPause=&#123;this.onStop&#125; /&gt; &lt;/main&gt; &lt;/div&gt; ); &#125;&#125; 리액트의 특징 class를 만들지만 다른 곳에서 인스턴스로 만들어 사용하지 않는 것처럼 보임 사실은 리액트가 내부적으로 인스턴스를 만드는 작업을 함. 그래서 사용자가 new 연산자를 사용하여 인스턴스를 만들지 않을 뿐 타입스크립트는 자바스크립트가 OOP의 특징을 갖도록 도움을 주는데, 그런 점에서 리액트는 타입스크립트의 일부만 사용하는 거라 볼 수 있다. OOP의 특징나는 이거 왜이렇게 계속 잊어버리지? 예전에 본격 취준할 때는 진짜 주변 사람들이 하나 같이 “누구야 안녕? 그래서 OOP 특징 말해봐” 급으로 물어보며 암기에 도움을 줬는데(… 감사합니다 여러분) 나는 왜 늘 까먹을까. 알고 있다고 생각했는데 수업 들으면서 그래서 OOP 특징 뭐더라, 하다가 또 까먹은 거 같음 추상화 캡슐화 상속 다형성 추상화랑 캡슐화는 기억하는데 상속이랑 다형성을 매번 잊는다. 그니까, 용어 던져주고 설명하라고 그러면 할 수도 있고 예시도 드는데 버튼 누르듯이 말해봐! 이러면 추상화캡슐화… 어… 이렇게 되는 거 같다ㅠㅠㅠ 정리하며정리하는 게 너무… 귀찮기도 하고 할 일이 많은 터라 쉽지 않았는데 정리하기 잘한 것 같다. (늘 투덜거리면서 정리 안하면 불안해한다) 정리하면서 어제 배운 걸 한 번 더 복습할 수 있어서 좋았고, 정리하면서 완벽히(과연?) 이해했는데 시간 지나면 또 까먹겠지? 미래의 나 과거의 나를 칭찬해주길…","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"우아한테크코스(React+Typescript)","slug":"개발공부/우아한테크코스-React-Typescript","permalink":"http://eunajjing.github.io/categories/개발공부/우아한테크코스-React-Typescript/"}],"tags":[]},{"title":"뉴욕의 프로그래머(2007)","slug":"programmerInNewYork","date":"2019-05-14T05:32:18.000Z","updated":"2019-05-14T06:46:36.422Z","comments":true,"path":"2019/05/14/programmerInNewYork/","link":"","permalink":"http://eunajjing.github.io/2019/05/14/programmerInNewYork/","excerpt":"","text":"뉴욕의 프로그래머읽게 된 경위갑자기 여행을 다녀왔다. 퇴사 기념 여행이었다. 여행을 무진장 싫어해서 고등학교 수학여행도 안 갔던 나지만, 퇴사할 거라고 하니 다들 여행을 추천하길래 ‘그 좋다는 여행 뭐가 좋은지 한 번 보자’하는 심경으로 쫓기듯 일주일을 떠났다. 남해를 따라 쏘다닌 터라 출경하고 상경하는 시간이 길었다. 마냥 자는 것도 지쳐서 휴대전화로 전자책을 읽었다. 기술서를 보고 싶었지만 읽고서 바로 이해할 자신이 없었다. 분명 오랜만에 문학 서적을 읽을 생각이었는데, 이 책을…. 문학 서적이라고 말하기는 좀 힘든 것 같고. 소설 겸 개발자 이야기라고 하길래 덥썩 집어 읽었다. 여행 때 틈이 나면 읽기도 했고, 책 자체도 짧아서 여행의 시작과 끝을 이 책과 함께 했다. 그래서 책은 어땠냐면이 책을 기술서라고 하기도 좀 그런데, 문학이라고 하기도 좀 그렇다. 왜 그렇게 느낀 건진 잘 모르겠다. 어쨌든 포스트모던의 영향을 받아 문학도 기존 틀이 많이 깨졌고, 나도 이를 인정하지만 그럼에도 불구하고 이 책을 문학이다, 라고 이야기하긴 힘들 것 같다. 이 책에는 다양한 개발자들이 등장인물로 등장하며, 각각 다른 성격과 코딩 스타일을 가지고 있다. 챕터마다 그 스토리를 끌고 가는 주체가 변경되고 각각의 챕터가 연속성을 띄지 않고 종결된다는 점에서 에피소드 형태다. 내용은 대개 어떤 이슈가 발생했을 때 이를 어떻게 처리했는지에 대한 것들. 등장인물들은 한 회사에 다닌다. 월가에 제공되는 주식 매수/매도 관련 SW 개발 및 유지보수 업무를 하는 것 같았다. 그들은 자바의 스윙패키지를 이용해 SW을 만드는데, 어… 스윙… 굉장히 오랜만… 게다가 자바 1.4 버전에서 1.5 버전에 추가된 패키지에 대해 대화하는 장면이 있어서 한편으로 놀랐다. (자바 1.8만 써본 사람) 하기야 이 책이 나온 게 10년도 더 전이니까. 나는 처음 배운 프로그래밍 언어가 자바였다. (국비 출신들이 다 그렇듯) 그래서 책에서 언급된 에러의 내용이라던가 패키지들이 낯익어서 한편으로 ‘내가 아는 것 나왔다’ 같은 재미도 있었다. 책에 나오는 등장인물들은 하나 같이 어딘가에 있을 것 같은 개발자의 특징을 엄청 부풀려놓은 형태였다. 통합 개발툴을 사용하지 않는 개발자라던가, 성격이 급해서 에러를 고치다가 더 큰 에러를 만드는 사람이라던가(난 가) 어렵게 쓴 문장은 없어서 쉽고 빠르게 읽기는 좋았는데 개발 분야를 아예 모르는 사람이 보면 재미 없을 것 같다. 실제로 지인한테 이거 읽고 있다고 보여주니까 ‘무슨 소리인지 하나도 모르겠다’고 할 정도였으니까. 소설 내에서 객체지향적 설계, 좋은 코드에 대한 찬양이 엄청 나온다. 그런데 코드가 직접적으로 나오는 부분은 극히 일부분이고(이 책이 기술서는 아니니까), 그마저도 초반만 자세하고 책 후반부 천재 등장인물들이 나올 때는 그들이 어떻게 코드를 쳤는지에 대한 묘사는 별로 없었다. 발화자가 코드를 보고 느낀 감정을 서술하는데 치중된 문장이 많아 아쉽다. 다 읽고 나서는 저자나 출판사가 이 책의 독자층을 어떻게 설정한 것인지가 궁금했다. 아예 개발 업무에 문외한이면 읽기 힘들 것 같은데, 현업에 계신 분들은 이 책이 재미있을까? 나는… 사실 잘 모르겠다. 재미 없진 않았는데, 어디서 재미를 느꼈는지 잘 모르겠다. 챕터 시작 전에 유명 개발자의 말이나 챕터 내에서 하고 싶었던 핵심 문단이 인용구로 나오는데, 전자책으로 읽어서 그런가 어떤 역할을 하고 있는지 모르겠다는 생각을 했다. 독자로 하여금 울림을 주고 싶었던 것 같은데, 잘 쓴 글이라면 문단을 강조하지 않더라도 독자가 알아서 느꼈으리라고 생각한다.","categories":[{"name":"책","slug":"책","permalink":"http://eunajjing.github.io/categories/책/"}],"tags":[]},{"title":"grid garden 게임","slug":"grid-garden","date":"2019-05-13T05:48:18.000Z","updated":"2019-05-13T05:53:58.553Z","comments":true,"path":"2019/05/13/grid-garden/","link":"","permalink":"http://eunajjing.github.io/2019/05/13/grid-garden/","excerpt":"","text":"Grid Garden 이전에 올렸던 개구리 게임의 개발진이 만든 듯한 그리드 가든 게임 애증의 css임을 느끼며ㅠㅠㅠ 총 28단계에서 24단계까지 풀다가 막혔다. 해당 게임을 진행하면서 개구리에 비해서는 아직까지 그리드를 잘 모르겠다는 생각이 들어서, 좀 여유로워지면 해당 부분만 파보는 것도 재밌을 것 같다. 그리드 가든 게임","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"CSS","slug":"개발공부/CSS","permalink":"http://eunajjing.github.io/categories/개발공부/CSS/"}],"tags":[]},{"title":"flex 게임","slug":"css-flex","date":"2019-05-07T02:29:18.000Z","updated":"2019-05-13T06:07:51.848Z","comments":true,"path":"2019/05/07/css-flex/","link":"","permalink":"http://eunajjing.github.io/2019/05/07/css-flex/","excerpt":"","text":"flexboxfroggy또 어디서 주웠는진 모르겠는데 이 게임을 알게 되어 미루고 미루다가 여행 짐 싸면서 심심할 적마다 한 단계씩 플레이했다. 나름 재밌긴 한데 무슨 속성에 어떤 값이 있는지 좀 헷갈려서 한 번 정리하는 게 좋을 것 같다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"CSS","slug":"개발공부/CSS","permalink":"http://eunajjing.github.io/categories/개발공부/CSS/"}],"tags":[]},{"title":"React.createRef()","slug":"createRef","date":"2019-05-07T02:29:18.000Z","updated":"2019-05-13T05:51:44.153Z","comments":true,"path":"2019/05/07/createRef/","link":"","permalink":"http://eunajjing.github.io/2019/05/07/createRef/","excerpt":"","text":"React.createRef() Ref DOM에 접근해 직접 다루어야 할 때 사용한다. 컴포넌트 내부에서만 작동하기 때문에 전역적이지 않다 기존의 ref생성 신텍스는 1234&lt;input ref=&#123;(ref) =&gt; &#123;this.refname = ref&#125;&#125; /&gt;// 이제 이 input 요소를 제어할 때는// this.refname.블라블라();// 형식으로 제어한다. 그런데 React.createRef()을 사용할 경우 123456789101112class ReactTest extends Component &#123; refname = React.createRef(); // 위에서 선언해주고 render() &#123; &lt;input ref=&#123;this.refname&#125;/&gt; // 이렇게 쓴다! &#125; 만약 포커싱 같은 것을 주고 싶으면 this.refname.currnet.focus();&#125; currnet가 핵심","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"텍스트 마이닝","slug":"text-mining","date":"2019-04-29T11:09:00.000Z","updated":"2019-04-29T11:09:58.202Z","comments":true,"path":"2019/04/29/text-mining/","link":"","permalink":"http://eunajjing.github.io/2019/04/29/text-mining/","excerpt":"","text":"텍스트 마이닝 데이터 마이닝의 세부 항목 대부분의 데이터마이닝이 수치 데이터, 범주형 데이터를 집중적으로 보는 반면 텍스트 마이닝은 텍스트 데이터를 주로 다룸 단어와 용어를 모르더라도 주요 개념, 데이터들의 관계와 경향을 발견하기 위해 텍스트 자료 콜렉션을 분석하는 프로세스가 중심 데이터들을 쌓아 내용을 공고히하거나, 정리, 요약, 분류, 추출 가능 자연어 처리 기술(NLP), 정보 검색 기술, 데이터마이닝 기술 분야의 혼합체 적용 방법 텍스트(원천 데이터) 입력 텍스트 마이닝 알고리즘 적용 개념 및 범주 모델 작성 데이터 분석 필요한 것 형태소 분석기 구문 분석기 대용량 데이터 처리 플랫폼 등 세부 분류언어학적 기반 텍스트 마이닝 특징 자연어를 컴퓨터가 분석해 구조화함 의미 및 컨텍스트를 기반으로 특정 개념을 관련 그룹으로 분류 가능 관련 프레임웤을 이용하면 컴퓨터가 단어 양식, 문장 구조를 분석 고려 대상 동의어에 대한 처리 필요 확장 필요성 존재 텍스트의 모호성 때문에 관련 없는 결과가 다수 생성될 가능성 있음 언어학적 자원(라이브러리, 동의어 등)을 세부 조정해 추출 프로세스 실행이 중요 한국어 데이터의 경우 형태소 분석 문제가 추가로 발생 추출 프로세스의 단계 원천 데이터를 컴퓨터가 읽을 수 있는 표준 형식으로 변환 (프로그램에 따라 표준 형식으로 변환된 추가 DB 생성이 없을 수도 있다) 후보 항 식별 후보항 : 텍스트에서 개념을 식별하는데 사용되는 단어나 단어 그룹 단일어, 복합어, 품사 패턴 추출기를 사용하여 텍스트 내 유의미한 자료 식별 식별 시 여러 개의 라이브러리를 함께 사용해 상호 보완적으로 쓰는 것이 일반적 라이브러리에는 사전 기본 사전(명사, 동사, 형용사 등이 담긴 품사 코드) 유형 사전 동의어 사전 등 관계 및 추출 지정, 조정 세팅 등이 담긴다. 동의어의 동등 클래스 및 통합 식별 (유사한 후보 항 식별) 한 구문의 기본 양식, 동일 구문에 대한 두 개의 변형이 있는 단일 양식을 동등 클래스로 설정 라이브러리의 사용자 지정 양식과 최대 빈도 양식을 기반으로 식별 진행 유형 지정 상위 레벨 개념 (상위 데이터와 하위 데이터 인지) 사용자가 만든 추가 유형 등 색인화 패턴 및 이벤트 추출 매치 (일부 프로그램에서만 제공됨) 색인된 것들과의 관계 추출 가능 규칙 기반 텍스트 마이닝 언어학적 기반 텍스트 마이닝의 단점 보완 비언어적 규칙으로 관련 결과, 비관련 결과를 구분","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"나의 개발 이야기 후기","slug":"for-developer","date":"2019-04-29T05:52:00.000Z","updated":"2019-05-07T01:25:47.342Z","comments":true,"path":"2019/04/29/for-developer/","link":"","permalink":"http://eunajjing.github.io/2019/04/29/for-developer/","excerpt":"","text":"나의 개발 이야기어쩌다 이 행사를 알게 되었는진 모르겠는데, 당시 wtm 서울을 다녀온지 얼마 안되어(이 후기도 써야 하는데 언제 쓴담!) 많은 개발자 분들을 만나 임파워링할 수 있었던 게 너무 좋았던 기억(그 때 분명히 돌아오면서 우주최강 개발자가 되겠다고 공부 짱짱 열심히 해야지 했는데 의욕 어디갔지)을 간직 중이었다. 그래서 비슷한 행사에에 참여할 수 있는 기회가 된다면 꼭 참여해야지, 하고 있었는데 해당 행사를 발견했다. 내가 wtm 서울에서 아쉬운 점 중 하나가… 따로 쓰겠지만, 연사로 올라가신 분들이 주니어 분들은 아니셨다는데에 있었다. 솔직히 그런 곳에 연사로 올라가시는 분들, 넷상에 자료까지 정리해서 올려주시는 분들은 개발계 우주대존잘러 분들이 많다고 생각하기 때문에, 나처럼 개발을 좋아하지만 개발 덕후까진 아니고 전공이 관련 분야가 아닌 사람의 이야기를 듣고 싶었다. 물론 이 행사에 연사로 참여한 분들도 존잘러들이었다…. 그치만 연차가 상대적으로 낮은 편이었던 거 같다. 어쨌든 관심을 가지게 된 경위는 이렇고. 당시엔 티켓 오픈은 안한 상태였다. 살펴보니 신청 인원이 너무 적어서 피켓팅일 것임을 예상했고, 결과적으로 맞았다…ㅎㅎㅎ 솔드아웃 속도 실화냐… 어쨌든 콘서트 티켓팅하듯 티켓을 구매해 해당 행사에 참여했다. 재밌었던 부분은, 연사 분들이 sns를 활발히 하시는 분들이 많아서 넷상에서 한 번쯤 지나가며 뵈었던 분들이었다는 점. 혼자 내적 친밀감 느끼고 흥미로웠습니다… 항상 글 잘 보고 있고요… 많은 귀감과 삽질에 도움을 주고 계십니다… 여기서부터 진짜 후기 일단 시작하기에 앞서(계속 구구절절) 내가 발표를 듣는 자세는 내게 울림을 준 이야기, 도움이 될만한 정보가 나오면 그것만 메모하는 스타일임을 밝힌다. 세션은 모두 10분이었고, 한 명의 연사가 진행했다. 자세한 내용은 여기 참고 세션에 대한 세부적인 후기를 적을 수 있는 그런 꼼꼼함과 금손력을 가진 분들도 계시겠지만 아쉽게도 나는 그런 사람은 못되어… 정보성 후기가 되진 못할 것 같은 느낌이 든다. wtm 의 20분짜리 세션도 짧고 아쉽게 느낀 나로서는 10분이 순식간에 지나갔다. 어떤 연사 분은 시간 제한을 넘기셨는지, 운영진 측에서 재촉하시는 것처럼 보이기도 했고. 운영진 측도, 연사 쪽도 다 음… 유쾌한 경험 같지는 않아보였다. 둘 다 이해는 되는데…. 어…(나중에 알고보니까 해당 장소 대관 시간이 촉박하게 정해져있었다) 글이나 말은 마지막이 제일 중요한 것 같다. 말하다가, 글을 쓰다가 생각이 정리되는 경험은 대개 뒤에 일어나니까. 형편없는 글이나 발표도 뒤에서 정돈되며 유의미한 결과가 창출되기도 하는데, 시간적으로 여유가 없다보니 뒷부분에서 발휘되는 힘들이 세션 전체적으로 다 부족하게 느껴졌다. 많은 연사분들이 결론부를 생략하시거나, 생략을 하지 않더라도 준비한 결론을 빠르게 마무리하시곤 했는데 (wtm 연사님들처럼 발표 자료를 공유해주셨으면 좋겠지만…. 따로 슬라이드쉐어 같은 걸 발견하지 못했다.) 듣는 사람 입장에서는 아쉬울 따름. 연사분들 대부분 자세한 내용은 네크워킹 시간에 하자구 하셨는데, 네트워킹 시간도 시간적으로 여유가 너무 부족했다. 심지어 네트워킹하고 싶은 연사를 선택할 수가 없는 구조였다. 운영진 측에서 유동적으로 네트워킹 운영을 바꿔서, 나중에는 네트워킹 도중에 듣고 싶은 연사에게 가서 네트워킹 진행해도 좋다고 했지만. 앞에서 시간을 내주신 연사님을 등지고 다른 연사님께 가는 게 쉬운 일은 아니었다(엄마 좋아 아빠 좋아 급 난제) 아 제일 싫었던 거 사진 진짜 많이 찍으신다. 만약 본인이 사진 찍히는 걸 정말 많이 싫어한다, 하면 안 가는 걸 추천할 정도로. 참석하는 사람들에게 미리 사진이 무진장… 정면으로 찍힐 수 있음을 고지한 것도 아닌데. 미리 고지한 양 대놓고 찍으셔서 순간 모델된 줄 알았다. 나중에 너무 화나서 행사 참여 신청을 받았던 링크를 확인했는데, 사진 관련한 문장은 하나도 없었다. 그리고 나 개인적으론 사진 찍는 분에게 찍히기 싫음을 어필 되게 많이 했다고 생각하는데(손으로 얼굴을 가린다던가, 대놓고 가리킨다던가) 보통 그런 식으로 반응하면 피해서 찍으시던데(wtm의 경우 사진 찍히기 싫은 사람들을 위해 붙일 수 있는 스티커를 마련해둬서 너무 좋았다) 반도인의 불굴의 의지를 사진에서 느낄 줄은 상상도 못했다. 다시 돌아와서 말을 하다보니까 운영진들이 운영을 참 못했다, 라는 식으로 귀결되는 것 같아 덧붙이면 참석자들도 운영진들의 진행에 협조적으로 따른 편이 아니었다. 다들 참… 여러 모로 힘든 행사였다. 운영진들이 계속 이동을 유도하셔도 꿋꿋이 그 자리를 지키시는 분들이 많았고, 이동하려는 사람은 그 사람들 때문에 자리가 없어서 이동을 못하기도 하는… 심지어 건물 구조가 미로급이라서(장난 삼아 일행에게 건물 ux/ui 디자인 누가했냐고 난리침) 헤맸다는 사람도 많고, 쓰레기통이 잘 보이는 공간에 없어서 행사 막바지에는 정수기 옆에 쓰레기 장관이 펼쳐졌던… 뭔가 누구 하나 엄청 잘못한 건 아닌데…. 음… 결론세션 내용이 나쁜 건 아니었다. wtm에 없던 how에 대한 답도 있었다(커뮤니티 활동으로 모두가 귀결됐다) 그럼에도 불구하고 아쉬움이 많은 건 너무 짧은 세션 탓에 내용이 기억 속에서 섞이기도 했고, 운영 미숙, 장소의 불편함 등의 영향인 것 같다. 이런 자리가 귀하다고 생각해서 더 불평불만만 더 늘어놓은 것 같네. 나는 네트워킹 때 서버 개발자 분에게만 배정이 되어서… 음… 프론트 엔지니어 분이랑 이야기 못한 게 너무 아쉬울 뿐이다.","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"데이터 마이닝","slug":"data-mining","date":"2019-04-29T05:45:00.000Z","updated":"2019-04-29T11:03:46.227Z","comments":true,"path":"2019/04/29/data-mining/","link":"","permalink":"http://eunajjing.github.io/2019/04/29/data-mining/","excerpt":"","text":"데이터 마이닝 데이터로부터 알려지지 않은 특성(unknown properties)을 발견하는 기술에 중점 분석기법분류분석(Classification Analysis) 데이터가 어떤 그룹에 속하는지 예측하는데 사용 K-최근접 이웃(K-Nearest Neighborhood), 의사결정 나무(Decision Tree), 베이지안 정리(Bayesian Theorem)를 이용한 분류, 인공신경망(Artificial Neural Network), 지지벡터기계(Support Vector Machine) 등을 세부 기법으로 사용 회귀분석(Regression Analysis) 원인이 되는 변수(독립 변수)와 결과로 간주되는 변수(종속 변수) 관계가 성립될 때, 하나 또는 여러 개의 독립변수와 종속변수 간의 관계를 분석하는 통계 기법 입력 데이터에서 변수간의 관계를 가장 잘 설명할 수 있는 y = a + bx 형태의 선형방정식을 찾아내고, 이를 통해 주어진 독립변수에 대해 종속 변수의 값을 예측 독립변수의 개수에 따라 단순선형회귀와 다중회귀모형으로 나뉨(다중회귀모형이 많이 쓰인다) 군집분석Clustering Analysis) 특성에 따라 객체를 여러 개의 배타적인 집단으로 나누는 것 데이터의 자발적인 군집화를 유도 군집으로 나뉜 뒤 각 군집의 특성과 군집간의 차이 등에 대해 분석 계층적 군집 방법과 비계층적 군집 방법이 있음 계층적 군집 방법(Hierarchical Clustering) n개의 군집으로 시작해 점차 군집의 개수를 줄여나가는 방법이다. 비계층적 군집 방법(Nonhierarchical Clustering) n개의 개체를 g개의 군집으로 나눌 수 있는 모든 방법을 점검해 최적화한 군집을 형성 K-Means 군집화가 대표적인 예 장점 데이터의 내부구조에 대한 사전정보 없이 의미 있는 구조를 찾을 수 있으며, 객체간의 거리를 데이터 형태에 맞게 정의하면 모든 형태의 데이터에 대해 적용 가능 단점 가중치와 거리 정의가 어려우며 초기 군집수를 결정하기 어려움 연관분석(Association Analysis) 흔히 말하는 장바구니 분석, 서열 분석 빈발 항목 집합과 연관 규칙 도출에 중점 관련 도구머하웃 확장성 있는 기계학습 라이브러리 기본적으로 자바만 지원하나 MLlib와 혼용하면 스칼라와 파이썬까지 함께 쓸 수 있다. 머하웃 소프트웨어 스택은 아래와 같다. 주요 알고리즘 분류 군집화 추천 시스템 장바구니 분석 공식 사이트 및 지원 알고리즘 확인 Spark MLlib 현재 제일 많이 쓰임 하나에 귀속되지 않는 범용성 목적의 빅데이터 플랫폼 데이터를 메모리에 올리는 형태가 달라 머하웃과 같은 타 라이브러리와 비교 시 더 빠른 결과를 얻어낼 수 있어 많이 사용 2014년도 이후 머하웃에 추가된 알고리즘은 스파크 기반 위에서 언급한대로 자바, 스칼라, 파이썬을 지원하나 메인 언어는 스칼라 그래프 알고리즘 공식 사이트 및 활용법","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"깃허브에 클라이언트 단 파일 올리기","slug":"deploy-using-github","date":"2019-04-28T11:44:00.000Z","updated":"2019-04-28T11:45:00.173Z","comments":true,"path":"2019/04/28/deploy-using-github/","link":"","permalink":"http://eunajjing.github.io/2019/04/28/deploy-using-github/","excerpt":"","text":"깃허브를 이용해 html, css, js 파일 호스팅완성된 파일에 yarn build 명령어를 이용해 최적화한다. package.json 파일에 hompage라는 필드를 만들어준다. 1\"homepage\": \"https://&lt;github-username&gt;.github.io/&lt;project-repo&gt;\" gh-pages 플러그인을 설치한다. yarn add gh-pages -D package.json의 scripts 필드에 필드를 추가한다. 1\"deploy\" : \"npm run build&amp;&amp;gh-pages -d build\" cmd에 yarn run deploy 명령어 실행","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"react-lines-ellipsis","slug":"react-lines-ellipsis","date":"2019-04-28T09:21:00.000Z","updated":"2019-05-12T09:27:01.302Z","comments":true,"path":"2019/04/28/react-lines-ellipsis/","link":"","permalink":"http://eunajjing.github.io/2019/04/28/react-lines-ellipsis/","excerpt":"","text":"react-lines-ellipsis특정 텍스트가 너무 길 때 사용할 수 있는 리액트 기반 라이브러리 yarn add react-lines-ellipsis로 의존 설정을 더해준 뒤 사용하면 된다. 사용법 및 공식 문서는 다음과 같다","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트의 라이브러리","slug":"react-lib","date":"2019-04-06T06:13:18.000Z","updated":"2019-04-21T00:47:14.366Z","comments":true,"path":"2019/04/06/react-lib/","link":"","permalink":"http://eunajjing.github.io/2019/04/06/react-lib/","excerpt":"","text":"react 라이브러리 정리CSSnode-sassSass를 CSS로 변환 SCSS의 문법 변수의 사용 가능 mixin 생성 가능 재사용되는 스타일 블록을 함수처럼 사용 가능 $.자식요소 사용 가능 부모의 요소와 자식의 요소가 함께 사용됐을 때 @import 구문 사용 가능 open-colorSass 라이브러리 중 하나로 색상 팔레트임 사용을 위해선 @import &#39;~open-color/open-color&#39;; include-mediaSass 라이브러리 중 하나로 반응형 디자인을 쉽게 만들어줌 사용을 위해선 @import &#39;~include-media/dist/include-media&#39;; 구문 필요 123@include media(\"&gt;phone\", \"&lt;=tablet\") &#123;width: 50%;&#125; classnamesCSS 클래스를 조건부로 설정하거나 여러 종류의 파라미터를 조합해 CSS 클래스를 설정할 수 있음 classNames.bind() 사용 가능 styled-components자바스크립트 파일안에 스타일까지 작성 가능 123456const Box = styled.div` /* props 로 넣어준 값을 직접 전달해줄 수 있습니다. */ background: $&#123;props =&gt; props.color || 'blue'&#125;; padding: 1rem; display: flex;`; reduxredux상태 관리 로직을 컴포넌트 밖에서 관리하는 라이브러리 createStore(리듀서) combineReducers({객체}) 서브 리듀서들을 하나로 합쳐 통합 리듀서를 만들어주는 역할 bindActionCreators(액션 생성 함수가 있는 객체 모듈, dispatch) 액션 생성함수 자동 바인딩 applyMiddkeware() react-redux Provider 리액트 어플리케이션에 손쉽게 스토어를 연동할 수 있도록 돕는 컴포넌트 connect(stateToProps, dispatchToProps)(뷰 컴포넌트) 뷰단 컴포넌트를 어플리케이션의 데이터 레이어와 묶는다 react-actions createAction(액션정의) handleActions(액션에 따라 실행할 함수들이 담긴 객체, 기본 값) 리듀서 만들 때 활용 middlewareredux-loggerredux-thunk객체가 아닌 함수도 디스패치할 수 있게 하는 미들웨어 axios요청의 응답 정보를 지닌 객체를 반환 redux-promise-middlewarePromise 객체를 payload로 전달하면 요청을 시작, 성공, 실패할 때 액션의 뒷부분에 _PENDING, _FULFILLED, _REJECTED를 붙여서 반환 createPromise() redux-pender액션 객체 안 payload가 Promise 형태라면 액션의 뒷부분에 관련 접미사를 붙여 반환(redux-promise-middleware 와 유사하지만 객체가 온다는 게 좀 다름) penderMiddleware() pender() …pender({ type: 액션타입명, 함수 : (state, action) =&gt; {} }) type에 접미사를 붙인 액션 핸들러들이 담긴 객체를 생성 applyPenders() …pender() 를 여러 번 생성해야할 때 react-routerreact-router-dom Route Link NavLink BrowserRouter 웹 브라우저에서 사용하는 라우터 query-stringcross-env window의 경우 node_path를 쓰기 위함 ETCimmutable Map fromJS List react-loadable페이지 로딩을 할 때부터 청크파일들을 다른 자바스크립트파일들과 동일한 시점에서 로딩을 시작 할 수 있다. Loadable({}) preload()","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"react-loadable","slug":"2019-03-27-react-loadable","date":"2019-03-27T08:16:18.000Z","updated":"2019-04-06T07:19:34.162Z","comments":true,"path":"2019/03/27/2019-03-27-react-loadable/","link":"","permalink":"http://eunajjing.github.io/2019/03/27/2019-03-27-react-loadable/","excerpt":"","text":"react-loadableyarn add react-loadable 장점 페이지 로딩을 할 때부터 청크파일들을 다른 자바스크립트파일들과 동일한 시점에서 로딩을 시작 할 수 있다. 서버사이드 렌더링과 함께 쉽게 코드 스플리팅을 할 수 있다. 로딩 중일 때 렌더링할 컴포넌트를 따로 지정할 수 있다. 123456789101112131415import React from 'react';import Loadable from 'react-loadable';const Loading = () =&gt; &#123; return &lt;div&gt;로딩중...&lt;/div&gt;;&#125;;export const Home = Loadable(&#123; loader: () =&gt; import('./Home'), loading: Loading&#125;);export const About = Loadable(&#123; loader: () =&gt; import('./About'), loading: Loading&#125;); Preloading 렌더링되지 않아도 특정 함수를 호출하여 미리 불러온다. 링크 호버 시에 로딩을 시작한다 123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react';import &#123; Route, Link &#125; from 'react-router-dom';import &#123; About, Home &#125; from './pages';class App extends Component &#123; handleMouseOver = () =&gt; &#123; About.preload(); &#125;; render() &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about\" onMouseOver=&#123;this.handleMouseOver&#125;&gt; About &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 서버사이드렌더링과 함께 쓰는 방법","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"아직도 배울 게 많은 git","slug":"2019-03-27-git","date":"2019-03-27T02:22:18.000Z","updated":"2019-04-06T07:19:34.162Z","comments":true,"path":"2019/03/27/2019-03-27-git/","link":"","permalink":"http://eunajjing.github.io/2019/03/27/2019-03-27-git/","excerpt":"","text":"git commit 취소git reset --hard HEAD^ 이전 커밋으로 HEAD를 되돌린다. git reset --hard HEAD~2 두번 째 전 커밋으로 HEAD 되돌림","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"yarn eject 중 에러가 발생했다","slug":"2019-03-27-yarn-eject-error","date":"2019-03-27T01:58:18.000Z","updated":"2019-04-06T07:19:34.163Z","comments":true,"path":"2019/03/27/2019-03-27-yarn-eject-error/","link":"","permalink":"http://eunajjing.github.io/2019/03/27/2019-03-27-yarn-eject-error/","excerpt":"","text":"git commit -am &quot;commit message&quot;create-react-app으로 프로젝트를 생성 후 관련 설정을 바꾸기 위해 yarn eject을 실행하면 에러가 난다. 뭐라더라, 깃으로 쫓을 수 없는 파일들과 관련한 에러라고 어디선가 읽었는데, 이 에러는 많은 이들에게 발생해서인지 트러블슈팅이 꽤나 잘 되어있는 편. 정답은 깃에 커밋을 한 뒤에 시도하면 된다… 였는데 문제는 나의 경우 커밋을 해도 에러가 났다… 또 다시 시작되는 방황… 속에 만난 해결 방안! 다른 건 별로 없고, 커밋하는 방식의 차이였다. -m이 아니라 -am, 즉 명령어 a 무슨 역할을 해주는지 궁금해져서 다시 찾아봤는데 git add . 를 해주는 것과 같다고 했다. 근데 나는 분명히 커밋하기 전에 git add .를 사용한 뒤 커밋했는데, 왜 깃이 변경된 파일을 제대로 못 잡는 건진 잘 모르겠다. 하여튼 이 명령어를 치니까 잘된다.","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"리액트를 다루는 기술08","slug":"use-react08","date":"2019-03-27T00:44:18.000Z","updated":"2019-04-06T07:19:34.168Z","comments":true,"path":"2019/03/27/use-react08/","link":"","permalink":"http://eunajjing.github.io/2019/03/27/use-react08/","excerpt":"","text":"코드 스플리팅코드 스플리팅 : 코드를 분할한다. webpack에서 프로젝트를 번들링할 때 파일 하나가 아니라 파일 여러 개로 분리시켜서 결과물을 만든다. 즉 해당 파일을 필요한 시점에 불러올 수 있다. 청크(chunk) 생성특정 파일을 비동기적으로 불러올 때 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';class AsyncSplitMe extends Component &#123; state = &#123; SplitMe : null &#125; loadSplitMe = () =&gt; &#123; // 비동기적으로 코드를 불러온다. 함수는 Promise를 결과로 반환한다. import('./SplitMe').then((&#123;default: SplitMe&#125;) =&gt; &#123; /* import는 모듈의 전체 네임스페이스를 불러오므로 default를 직접 지정해야 한다. */ this.setState(&#123; SplitMe &#125;); &#125;); &#125; render() &#123; const &#123;SplitMe&#125; = this.state; return SplitMe ? &lt;SplitMe/&gt; : &lt;button onClick=&#123;this.loadSplitMe&#125;&gt;로딩&lt;/button&gt; &#125;&#125;export default AsyncSplitMe; 위의 코드가 로딩되면, 웹브라우저 개발자도구 네트워크 탭에서 chunk.js가 생성된 것을 확인할 수 있다. 라우트 코드 스플리팅비동기적으로 불러올 코드가 많으면 청크를 생성할 때마다 파일에 비슷한 코드들을 반복하여 작성해야 한다. 조금 더 편하게 구현하기 위해 이를 함수화한다. 123456789101112131415161718192021222324252627282930313233import React from 'react';export default function asyncComponent(getComponent) &#123; // getComponent = import('~') return class AsyncComponent extends React.Component &#123; static Component = null; state = &#123;Component : AsyncComponent.Component&#125;; constructor(props) &#123; // props = import('~') super(props); if(AsyncComponent.Component) return; getComponent().then((&#123;default: Component&#125;) =&gt; &#123; AsyncComponent.Component = Component; this.setState(&#123;Component&#125;); /* props로 들어온 컴포넌트는 해당 컴포넌트가 언마운트 후 다시 마운트 될 때 불러오지 않고, static 값으로 남아있는 이전 컴포넌트로 재사용한다. */ &#125;); &#125; render() &#123; const &#123;Component&#125; = this.state if(Component) &#123; return &lt;Component &#123;...this.props&#125; /&gt; &#125; return null; &#125; &#125;&#125; 1234567// index.jsimport asyncComponent from 'lib/asyncComponent';export const Home = asyncComponent(()=&gt; import('./Home'));export const About = asyncComponent(()=&gt; import('./About'));export const Post = asyncComponent(()=&gt; import('./Post'));export const Posts = asyncComponent(()=&gt; import('./Posts'));","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술07","slug":"use-react07","date":"2019-03-26T02:30:18.000Z","updated":"2019-04-06T07:19:34.167Z","comments":true,"path":"2019/03/26/use-react07/","link":"","permalink":"http://eunajjing.github.io/2019/03/26/use-react07/","excerpt":"","text":"react-router yarn add react-router-dom NODE_PATH 설정package.json에서 노드 패스를 설정해준다. 12345\"scripts\": &#123; \"start\": \"NODE_PATH=src react-scripts start\", \"build\": \"NODE_PATH=src react-scripts build\" (...)&#125; window의 경우, cross-env 의존설정을 해준다. 12345\"scripts\": &#123; \"start\": \"cross-env NODE_PATH=src react-scripts start\", \"build\": \"cross-env NODE_PATH=src react-scripts build\" (...)&#125; 최상위 컴포넌트를 Root.js로 바꾸고, 기존 App.js를 감싼다. 12345678910111213import React from 'react';import &#123;BrowserRouter&#125; from 'react-router-dom';import App from './App';const Root = () =&gt; &#123; return ( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; );&#125;;export default Root; App.js에서 라우터 설정 1234567891011121314151617181920import React from 'react';import &#123;Route&#125; from 'react-router-dom';import &#123;Home, About&#125; from 'pages';/*pages/index.js에서는export &#123;default as Home&#125; from './Home';export &#123;default as About&#125; from './About';처리*/const App = () =&gt; &#123; return ( &lt;div&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about\" component=&#123;About&#125; /&gt; &lt;/div&gt; );&#125;;export default App; exact 키워드path가 정확하게 일치할 때 보여주기 위해 사용. 만약 위의 코드에서 exact을 사용하지 않았더라면, 모든 페이지는 /이 포함되므로 모두 다 보였을 것 라우트 경로에 특정 값 넣기params1234567891011121314import React from 'react';import &#123;Route&#125; from 'react-router-dom';import &#123;Home, About&#125; from 'pages';const App = () =&gt; &#123; return ( &lt;div&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about/:name?\" component=&#123;About&#125; /&gt; &lt;/div&gt; );&#125;;export default App; 1234567891011121314import React from 'react';const About = (&#123;match&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h2&gt;소개&lt;/h2&gt; &lt;p&gt; 안녕하세요, 저는 &#123;match.params.name&#125;입니다. &lt;/p&gt; &lt;/div&gt; );&#125;;export default About; 만약 localhost:3000/about/react로 접속했다면, 안녕하세요, 저는 react입니다. 라는 글자가 출력될 것 localhost:3000/about만 친다면 저는 입니다, 만 나온다. Query Stringyarn add query-string 라우트 내부에서 설정해준다 해당 값들은 전부 String 형태의 값임에 유의한다 1234567891011121314151617import React from 'react';import queryString from 'query-string';const About = (&#123;location, match&#125;) =&gt; &#123; const query = queryString.parse(location.search); const &#123;color&#125; = query; return ( &lt;div&gt; &lt;h2 style=&#123;&#123;color&#125;&#125;&gt;소개&lt;/h2&gt; &lt;p&gt; 안녕하세요, 저는 &#123;match.params.name&#125;입니다. &lt;/p&gt; &lt;/div&gt; );&#125;;export default About; 만약 url을 localhost:3000/about/react?color=red라고 타이핑해 접근한다면, 콘솔에는 color라는 키와 그 키 값으로 red가 들어있는 객체가 찍힌다. 위의 소스는 이를 이용해서 style을 정의한 것 라우트 이동애플리케이션에서 다른 라우트로 이동할 때는, a 링크를 사용하면 페이지를 새로고침하면서 로딩하기 때문에 사용이 불가하다. 때문에 리액트 라우터 안에 있는 Link 컴포넌트들을 이용해야 한다. Link12345678910111213141516import React from 'react';import &#123;Link&#125; from 'react-router-dom';const Menu = () =&gt; &#123; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;홈&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about\"&gt;소개&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/about/react\"&gt;React 소개&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125;;export default Menu; 12345678910111213141516import React from 'react';import &#123;Route&#125; from 'react-router-dom';import &#123;Home, About&#125; from 'pages';import Menu from 'components/Menu';const App = () =&gt; &#123; return ( &lt;div&gt; &lt;Menu/&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/about/:name?\" component=&#123;About&#125; /&gt; &lt;/div&gt; );&#125;;export default App; NavLinkLink와 거의 유사한 기능이지만, 현재 주소와 해당 컴포넌트의 목적지 주소가 일치한다면 특정 스타일 또는 클래스를 지정할 수 있다. 즉 active 표시 가능 1234567891011121314151617181920import React from 'react';import &#123;NavLink&#125; from 'react-router-dom';const Menu = () =&gt; &#123; const activeStyle = &#123; color : 'green', fontSize: '2rem' &#125;; return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;NavLink exact to=\"/\" activeStyle=&#123;activeStyle&#125;&gt;홈&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink exact to=\"/about\" activeStyle=&#123;activeStyle&#125;&gt;소개&lt;/NavLink&gt;&lt;/li&gt; &lt;li&gt;&lt;NavLink to=\"/about/react\" activeStyle=&#123;activeStyle&#125;&gt;React 소개&lt;/NavLink&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; );&#125;;export default Menu; CSS를 적용하길 원한다면 activeClassName 값을 지정해준다. javascript를 이용한 이동로그인 같이 특정 경로로 이동을 시켜줘야 할 때 쓰는 방법 12345678910111213141516import React from 'react';const Home = (&#123; history &#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h2&gt;홈&lt;/h2&gt; &lt;button onClick=&#123;() =&gt; &#123; history.push('/about/javascript') &#125;&#125;&gt; 이동 &lt;/button&gt; &lt;/div&gt; );&#125;;export default Home; 라우트 안의 라우트123456789101112// 안의 라우트import React from 'react';const Post = (&#123; match &#125;) =&gt; &#123; return ( &lt;p&gt; 포스트 #&#123;match.params.id&#125; &lt;/p&gt; );&#125;;export default Post; 123456789101112131415161718192021// 밖의 라우트import React from 'react';import &#123;Post&#125; from 'pages';import &#123;Link, Route&#125; from 'react-router-dom';const Posts = (&#123;match&#125;) =&gt; &#123; return ( &lt;div&gt; &lt;h3&gt;포스트 목록&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;match.url&#125;/1`&#125;&gt;포스트 #1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;match.url&#125;/2`&#125;&gt;포스트 #2&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&#123;`$&#123;match.url&#125;/3`&#125;&gt;포스트 #3&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path=&#123;match.url&#125; render=&#123;()=&gt;(&lt;p&gt;포스트를 선택하세요&lt;/p&gt;)&#125;/&gt; &lt;Route exact path=&#123;`$&#123;match.url&#125;/:id`&#125; component=&#123;Post&#125;/&gt; &lt;/div&gt; );&#125;;export default Posts; location, match, historylocation123456&#123; \"pathname\" : \"/posts/3\", \"search\" : \"\", \"hash\" : \"\", \"key\" : \"xmsczi\"&#125; search 값에서 URL Query를 읽는데 사용하거나 주소를 바뀐 것을 감지하는데 사용 12345componentDidUpdate(prevProps, prevState) &#123; if(prevProps.location !== this.props.location) &#123; &#125; &#125; matchRoute 컴포넌트에서 설정한 path와 관련된 데이터들을 조회할 때 사용 주로 prams를 조회하거나 서브 라우트를 만들 때 현재 path를 참조하는데 사용 url이 같아도 다른 라우트에서 사용된 match는 다른 정보를 알려준다. 123456789&#123; isExact : true, params: &#123; id : \"2\" &#125;, path: \"/posts:id\", url: \"/posts/2\", (...)&#125; history현재 라우터를 조작할 때 사용 push(&#39;~&#39;) : 페이지 방문 기록 남음, replace(~) : 페이지 방문 기록 남지 않음, 페이지 이동 후 뒤로가기 버튼을 누르면 방금 전의 페이지가 아니라 방금 전의 전 페이지가 나타남","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술06","slug":"use-react06","date":"2019-03-22T08:13:18.000Z","updated":"2019-04-06T10:20:19.440Z","comments":true,"path":"2019/03/22/use-react06/","link":"","permalink":"http://eunajjing.github.io/2019/03/22/use-react06/","excerpt":"","text":"미들웨어1234567891011121314151617const loggerMiddleware = store =&gt; next =&gt; action =&gt; &#123; console.log('현재 상태', store.getState()); console.log('액션', action); const result = next(action); // 다음 차례(다른 미들웨어, 리듀서)로 넘긴다 console.log('액션 처리 후', store.getState()); console.log('그래서 리턴 값이', result); // store.dispatch(ACTION_TYPE) console.log('\\n'); return result; // store.dispatch(ACTION_TYPE)&#125;export default loggerMiddleware; 스토어 만드는 곳에서 12345678910import &#123; createStore, applyMiddleware &#125; from 'redux';import modules from './modules';import loggerMiddleware from './lib/loggerMiddleware';const store = createStore(modules, applyMiddleware(loggerMiddleware));/* 미들웨어가 여러 개일 때는 콤마로 주며 순서는 여기에서 전달한 파라미터 순.applyMiddleware(a, b, c);*/export default store; 외부 미들웨어의 사용redux-logger 1234import &#123;createLogger&#125; from 'redux-logger';const logger = createLogger();const store = createStore(modules, applyMiddleware(logger)); 비동기 작업 처리 미들웨어 redux-thunk redux-promise-middleware redux-pender redux-thunk객체가 아닌 함수도 디스패치할 수 있게 하는 미들웨어 리턴되는 함수는 액션 생성 함수가 아니라, thunk 생성 함수라 한다. thunk특정 작업을 나중에 하기 위해 함수로 감싼 것 thunk 생성 함수 dispatch와 getState를 파라미터로 가지는 새로운 함수를 만들어서 반환 네트워크 요청, 다른 종류의 액션들을 여러 번 디스패치도 가능 사용12345678910111213141516const ACTCION_NAME = 'ACTCION_NAME';function actionCreateFuc() &#123; return &#123; type : ACTION_NAME &#125;;&#125;function actionCreateAsyne() &#123; return dispatch =&gt; &#123; // 디스패치를 파라미터로 가지는 펑션을 리턴하는 것 setTimeout(()=&gt; &#123; dispatch(actionCreateFuc()); &#125;, 1000); &#125;&#125; 1234567891011121314function ignore() &#123; retrun (dispatch, getState) =&gt; &#123; cosnt &#123;store&#125; = getState(); // 리턴하는 함수의 파라미터로 디스패치와 겟스테이터스를 주기 때문에, 스토어 상태에 접근 가능 if (store % 2 === 0) &#123; // 조건문 실행해서 조건문 맞으면 디스패치 미실행 retrun; &#125; dispatch(actionCreateFuc()); &#125;;&#125; -일반 액션 객체로는 특정 액션을 디스패치한 후 몇 초 뒤에 실제로 반영시키거나 현재 상태에 따라 아예 무시하게 만들 수 없다- 예제 반영1234567891011121314151617181920212223242526// module.jsimport &#123; handleActions, createAction &#125; from 'redux-actions';const INCREMENT = 'INCREMENT';const DECREMENT = 'DECREMENT';export const increment = createAction(INCREMENT);export const decrement = createAction(DECREMENT);export const incrementAsync =() =&gt; dispatch =&gt; &#123; setTimeout( () =&gt; &#123;dispatch(increment())&#125;, 1000 );&#125;export const decrementAsync =() =&gt; dispatch =&gt; &#123; setTimeout( () =&gt; &#123;dispatch(decrement())&#125;, 1000 );&#125;export default handleActions(&#123; [INCREMENT]: (state, action) =&gt; state + 1, [DECREMENT]: (state, action) =&gt; state - 1&#125;, 0); 1234567891011121314// app.jsclass App extends Component &#123; render() &#123; const &#123; CounterActions, number &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &lt;button onClick=&#123;CounterActions.incrementAsync&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;CounterActions.decrementAsync&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; axiosyarn add axios 123456789101112import axios from 'axios';class App extends Component &#123; componentDidMount() &#123; axios.get('https://jsonplaceholder.typycode.com/posts/1') .then(response =&gt; console.log(response)); &#125; render() &#123; &#125;&#125; redux-thunk와 axios의 사용1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// post.jsimport &#123;handleActions, createAction&#125; from 'redux-actions';import axios from 'axios';function getPostAPI(postId) &#123; return axios.get(`https://jsonplaceholder.typicode.com/posts/$&#123;postId&#125;`);&#125;const GET_POST_PENDING = 'GET_POST_PENDING';const GET_POST_SUCCESS = 'GET_POST_SUCCESS';const GET_POST_FAILURE = 'GET_POST_FAILURE';const getPostPending = createAction(GET_POST_PENDING);const getPostSuccess = createAction(GET_POST_SUCCESS);const getPostFailure = createAction(GET_POST_FAILURE);export const getPost = (postId) =&gt; dispatch =&gt; &#123; dispatch(getPostPending()); return getPostAPI(postId).then((response) =&gt; &#123; dispatch(getPostSuccess(response)) // 요청이 성공했다면 서버 응답 내용을 payload로 설정해 성공 액션을 디스패치 // then에 전달하는 함수에서 response에 접근할 수 있게 한다. return response; &#125;).catch(error =&gt; &#123; dispatch(getPostFailure(error)); // 에러 처리를 던지되 한 번 더 catch 되도록 설정 throw(error); &#125;)&#125;const initialState = &#123; pending : false, error : false, data : &#123; title : '', body: '' &#125;&#125;export default handleActions(&#123; [GET_POST_PENDING] : (state, action) =&gt; &#123; return &#123; ...state, pending: true, error : false &#125;; &#125;, [GET_POST_SUCCESS] : (state, action) =&gt; &#123; const &#123;title, body&#125; = action.payload.data; return &#123; ...state, pending: false, error : false, data : &#123; title, body &#125; &#125;; &#125;, [GET_POST_FAILURE] : (state, action) =&gt; &#123; return &#123; ...state, pending: false, error: true &#125; &#125;&#125;, initialState); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// app.jsimport React, &#123; Component &#125; from 'react';import &#123; bindActionCreators &#125; from 'redux';import &#123; connect &#125; from 'react-redux';import * as counterActions from './modules/counter';import * as postActions from './modules/post';class App extends Component &#123; loadData = () =&gt; &#123; const &#123;PostActions, number&#125; = this.props; PostActions.getPost(number).then( (response) =&gt; &#123; console.log(response); &#125; ).catch( (error) =&gt; &#123; console.log(error); &#125; ); &#125; componentDidMount() &#123; this.loadData(); &#125; componentDidUpdate(prevProps, prevState) &#123; if (this.props.number !== prevProps.number) &#123; this.loadData(); &#125; &#125; render() &#123; const &#123; CounterActions, number, post, error, loading &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt;&#123;number&#125;&lt;/h1&gt; &#123; loading ? (&lt;h2&gt;로딩 중...&lt;/h2&gt;) : (error ? (&lt;h2&gt;오류 발생!&lt;/h2&gt;) : (&lt;div&gt;&lt;h2&gt;&#123;post.title&#125;&lt;/h2&gt; &lt;p&gt;&#123;post.body&#125;&lt;/p&gt; &lt;/div&gt;) ) &#125; &lt;button onClick=&#123;CounterActions.increment&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;CounterActions.decrement&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default connect( (state) =&gt; (&#123; number: state.counter, post: state.post.data, loading: state.post.pending, error: state.post.error &#125;), (dispatch) =&gt; (&#123; CounterActions: bindActionCreators(counterActions, dispatch), PostActions : bindActionCreators(postActions, dispatch) &#125;))(App); async/await만약 이런 코드가 있다고 가정한다면, 12345678910&gt; PostActions.getPost(number).then(&gt; (response) =&gt; &#123;&gt; console.log(response);&gt; &#125;&gt; ).catch(&gt; (error) =&gt; &#123;&gt; console.log(error);&gt; &#125;&gt; );&gt; ES7의 문법으로, 위의 코드를 이렇게 작성 가능하다. 12345678910&gt; loadData = async () =&gt; &#123;&gt; const &#123;PostActions, number&#125; = this.props;&gt; try &#123;&gt; const response = await PostActions.getPost(number);&gt; console.log(response);&gt; &#125; catch(e) &#123;&gt; console.log(e);&gt; &#125; &gt; &#125;&gt; 바벨 설정에 Async to generator transform 플러그인을 적용한다면 사용 가능한 문법. await를 쓸 함수 앞에 async 라는 키워드를 붙여주고, 기다려야 할 프로미스 앞에 await 키워드를 붙여주어야 한다. await를 사용했다면 반드시 try - catch 구문을 사용해 오류를 처리해야 한다. redux-promise-middlewareyarn add redux-promise-middleware Promise 객체를 payload로 전달하면 요청을 시작, 성공, 실패할 때 액션의 뒷부분에 _PENDING, _FULFILLED, _REJECTED를 붙여서 반환한다. 각 액션 타입을 선언할 필요가 없으며, 뒤에 붙는 접미사는 커스터마이징도 가능하다. 커스터마이징 방법은 아래와 같다. 1234567891011121314import &#123; createStore, applyMiddleware &#125; from 'redux';import modules from './modules';import &#123;createLogger&#125; from 'redux-logger';import &#123;createPromise&#125; from 'redux-promise-middleware';const logger = createLogger();const pm = createPromise(&#123; promiseTypeSuffixes: ['PENDING', 'SUCCESS', 'FAILURE']&#125;);const store = createStore(modules, applyMiddleware(logger, pm));export default store; redux-promise-middleware 미들웨어의 버전업으로 인해 책 내 기술된 사용 방법과 다르다. 자세한 사항은 해당 미들웨어 공홈에서 알 수 있었다. 123456789101112131415161718import &#123;handleActions&#125; from 'redux-actions';import axios from 'axios';function getPostAPI(postId) &#123; return axios.get(`https://jsonplaceholder.typicode.com/posts/$&#123;postId&#125;`);&#125;const GET_POST = 'GET_POST';const GET_POST_PENDING = 'GET_POST_PENDING';const GET_POST_SUCCESS = 'GET_POST_SUCCESS';const GET_POST_FAILURE = 'GET_POST_FAILURE';// 해당 액션들이 기술되어야 리듀서에서 사용이 된다.export const getPost = (postId) =&gt; (&#123; type: GET_POST, payload: getPostAPI(postId)&#125;); redux-pender액션 객체 안의 payload 가 Promise 형태라면 시작하기 전, 완료 또는 실패를 했을 때 뒤에 PENDING, SUCCESS, FAILURE 접미사를 붙인다. 요청을 관리하는 리듀서가 포함되어 있으며 요청 관련 액션들을 처리하는 액션 핸들러 함수들을 자동으로 만들어주는 도구들도 들어 있다. 요청 중인 액션을 취소할 수도 있다. 12345678910// post.jsimport &#123; createStore, applyMiddleware &#125; from 'redux';import modules from './modules';import &#123;createLogger&#125; from 'redux-logger';import penderMiddleware from 'redux-pender';const logger = createLogger();const store = createStore(modules, applyMiddleware(logger, penderMiddleware()));export default store; 1234567891011// index.jsimport &#123; combineReducers &#125; from 'redux';import counter from './counter';import post from './post';import &#123;penderReducer&#125; from 'redux-pender';export default combineReducers(&#123; counter, post, pender: penderReducer&#125;); 해당 리듀서는 요청 상태를 관리한다. 이 리듀서의 상태 구조는 다음과 같다. 12345&#123; pending : &#123;&#125;, success: &#123;&#125;, failure: &#123;&#125;&#125; 프로미스 기반 액션을 디스패치하면 상태는 이렇게 변경된다. 1234567891011&#123; pending : &#123; 'ACTION_NAME': true &#125;, success: &#123; 'ACTION_NAME': false &#125;, failure: &#123; 'ACTION_NAME': false &#125;&#125; 요청이 끝나고, 해당 요청이 성공이면 1234567891011&#123; pending : &#123; 'ACTION_NAME': false &#125;, success: &#123; 'ACTION_NAME': true &#125;, failure: &#123; 'ACTION_NAME': false &#125;&#125; 반대로, 해당 요청이 실패이면 1234567891011&#123; pending : &#123; 'ACTION_NAME': false &#125;, success: &#123; 'ACTION_NAME': false &#125;, failure: &#123; 'ACTION_NAME': true &#125;&#125; 모듈의 코드는 다음과 같이 변경된다. 1234567891011121314151617181920212223242526272829303132333435// post.jsimport &#123;handleActions, createAction&#125; from 'redux-actions';import axios from 'axios';import &#123;pender&#125; from 'redux-pender'; function getPostAPI(postId) &#123; return axios.get(`https://jsonplaceholder.typicode.com/posts/$&#123;postId&#125;`);&#125;const GET_POST = 'GET_POST';export const getPost = createAction(GET_POST, getPostAPI);const initialState = &#123; data : &#123; title : '', body: '' &#125; // 연결했는지, 에러가 있는지 여부는 따로 관리를 할 필요가 없어진다.&#125;export default handleActions(&#123; ...pender(&#123; type: GET_POST, onSuccess: (state, action) =&gt; &#123; // onPending과 onFailure가 존재 const &#123;title, body&#125; = action.payload.data; return &#123; data : &#123; title, body &#125; &#125; &#125; &#125;)&#125;, initialState); 만약 여러 개를 관리한다면, ...pender 를 여러 번 사용하거나 applyPenders를 사용하면 된다. applyPenders당연한 이야기겠지만 ...pender와 같이 쓰니 에러가 난다. 1234567891011121314151617181920212223242526272829303132333435363738// post.js 모듈import &#123;handleActions, createAction&#125; from 'redux-actions';import axios from 'axios';import &#123;applyPenders&#125; from 'redux-pender'; function getPostAPI(postId) &#123; return axios.get(`https://jsonplaceholder.typicode.com/posts/$&#123;postId&#125;`);&#125;const GET_POST = 'GET_POST';export const getPost = createAction(GET_POST, getPostAPI);const initialState = &#123; data : &#123; title : '', body: '' &#125;&#125;const reducer = handleActions(&#123; // 다른 일반 액션 관리&#125;, initialState);export default applyPenders(reducer, [ // 첫 번째 파라미터는 일반 리듀서, 두 번째 파라미터는 pender 관련 객체를 배열로 &#123; type: GET_POST, onSuccess: (state, action) =&gt; &#123; const &#123;title, body&#125; = action.payload.data; return &#123; data : &#123; title, body &#125; &#125; &#125; &#125;, // 다른 pender 액션들을 위와 같은 객체 형태로 쓴다.]); 1234567891011121314// App.js의 커넥트에서도export default connect( (state) =&gt; (&#123; number: state.counter, post: state.post.data, loading: state.pender.pending['GET_POST'], error: state.pender.failure['GET_POST'] &#125;), (dispatch) =&gt; (&#123; CounterActions: bindActionCreators(counterActions, dispatch), PostActions: bindActionCreators(postActions, dispatch) &#125;))(App); @@redux-penderPromise 기반 액션을 시작하면 액션 두 개가 디스패치된다. ACTION_NAME_RESULT(ex : GET_POST_PENDING) @@redux-pender/RESULT(ex : @@redux-pender/PENDING) : 해당 액션의 payload 값에는 액션 이름이 들어가고, 이에 따라 pender 리듀서의 상태가 변화된다. onCancel요청을 취소했을 때 특정 작업을 하고 싶다면, ...pender를 사용하는 부분에서 onCancel 함수를 추가하면 된다. 단, 이 함수는 웹 요청을 취소하는 게 아니라 무시하는 것일 뿐 123456789101112131415161718192021222324// post.jsexport default handleActions(&#123; ...pender(&#123; type: GET_POST, onSuccess: (state, action) =&gt; &#123; const &#123;title, body&#125; = action.payload.data; return &#123; data : &#123; title, body &#125; &#125; &#125;, onCancel: (state, action) =&gt; &#123; return &#123; data : &#123; title: '요청 취소', body: '요청 취소' &#125; &#125; &#125; &#125;)&#125;, initialState); 참고 12345678910111213141516171819202122232425262728293031323334353637&gt; // app.js&gt; class App extends Component &#123;&gt; &gt; cancelRequest = null&gt; handleCancel = () =&gt; &#123;&gt; if(this.cancelRequest) &#123;&gt; this.cancelRequest();&gt; this.cancelRequest = null;&gt; &#125;&gt; &#125;&gt; &gt; loadData = async () =&gt; &#123;&gt; const &#123; PostActions, number &#125; = this.props;&gt; &gt; try &#123;&gt; const p = PostActions.getPost(number);&gt; this.cancelRequest = p.cancel;&gt; const response = await p;&gt; console.log(response);&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt; &#125;&gt; &gt; componentDidMount() &#123;&gt; this.loadData();&gt; window.addEventListener('keyup', (e) =&gt; &#123;&gt; if(e.key === 'Escape') &#123;&gt; this.handleCancel();&gt; &#125;&gt; &#125;)&gt; &#125;&gt; &gt; (...)&gt; &gt; &#125;&gt;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"no such file or directory, copyfile","slug":"2019-03-22-Error","date":"2019-03-22T07:54:18.000Z","updated":"2019-04-06T07:19:34.162Z","comments":true,"path":"2019/03/22/2019-03-22-Error/","link":"","permalink":"http://eunajjing.github.io/2019/03/22/2019-03-22-Error/","excerpt":"","text":"yarn error 기록언제부터인가 계속 Error: ENOENT: no such file or directory, copyfile로 시작하는 에러가 발생했다. 에러가 발생한 디렉토리 구조를 보니까, 내가 뭘 만지거나 해서 생긴 것 같진 않고 안에서 꼬인 것 같았다. 해당 에러를 구글에 검색해보니 나 같은 사람이 역시나 있었고(고마워요 스택옾) 도움을 받은 링크도 미래의 나를 위해 함께 기록 핵심 코드는 다음과 같다. rm -rf node_modules &amp;&amp; yarn cache clean &amp;&amp; yarn install 에러가 발생한 디렉토리인 node_modules를 지우고, yarn 캐시 지우고, 다시 설치. 지난 번에는 이렇게 하니까 잘 되던데, 지금 노드 모듈 파일 지우는 중이라 이번에도 먹힐지 모르겠다. 만약 해당 방법을 썼는데도 안된다면저 에러가 나다못해 이제 create-react-app까지 먹지 않기 시작했다. 일단 구글링을 통해서 비슷한 이슈를 확인했고, 아래 답변대로 진행하니 현재로서는 잘 된다. 먼저 폴더를 만들고(mkdir 폴더명), 해당 폴더 안에 /.gitignore 파일 생성(touch 폴더명/.gitignore) 그리고 다시 create-react-app 폴더명","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"리액트를 다루는 기술05 (실습)","slug":"use-react05-ex","date":"2019-03-21T07:23:18.000Z","updated":"2019-04-06T07:19:34.166Z","comments":true,"path":"2019/03/21/use-react05-ex/","link":"","permalink":"http://eunajjing.github.io/2019/03/21/use-react05-ex/","excerpt":"","text":"Ducks 모듈 구현input.js1234567891011121314151617181920import &#123;Map&#125; from 'immutable';import &#123;handleActions, createAction&#125; from 'redux-actions';const SET_INPUT = 'input/SET_INPUT';// 액션타입의 이름을 js이름/액션타입으로 정해준다.export const setInput = createAction(SET_INPUT);// 액션 생성함수const initialState = Map(&#123; value: ''&#125;);// 초기 값export default handleActions(&#123; [SET_INPUT]: (state, action) =&gt; &#123; return state.set('value', action.payload) &#125;&#125;, initialState);// 리듀서 정의 todos.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123;Map, List&#125; from 'immutable';import &#123;handleActions, createAction&#125; from 'redux-actions'const INSERT = 'todos/INSERT';const TOGGLE = 'todos/TOGGLE';const REMOVE = 'todos/REMOVE';export const insert = createAction(INSERT);export const toggle = createAction(TOGGLE);export const remove = createAction(REMOVE);const initaialState = List([ Map(&#123; id: 0, text: '리액트 공부하기', done: true &#125;), Map(&#123; id: 1, text: '컴포넌트 스타일링 해보기', done: false &#125;)]);export default handleActions(&#123; [INSERT]: (state, action) =&gt; &#123; const &#123;id, text, done&#125; = action.payload; // 이 액션이 어떤 데이터를 처리하는지 알기 위해 기입 return state.push(Map(&#123; id, text, done &#125;)); // 그냥 state.push(Map(action.payload)) 해도 된다. &#125;, [TOGGLE]: (state, action) =&gt; &#123; const &#123; payload: id&#125; = action; // const id = action.payload와 같다. payload의 값을 쉽게 볼 수 있게 비구조화 할당 진행 const index = state.findIndex(todo =&gt; todo.get('id')===id); return state.updateIn([index, 'done'], done =&gt; !done); // state.setIn([index, 'done'], !state.getIn([0, index])); &#125;, [REMOVE]: (state, action) =&gt; &#123; const &#123;payload: id&#125; = action; const index = state.findIndex(todo =&gt; todo.get('id')===id); return state.delete(index); &#125;&#125;, initaialState); index.js12345678import input from './input';import todos from './todos';import &#123;combineReducers&#125; from 'redux';export default combineReducers(&#123; input, todos&#125;); index.js에서는123456789101112131415161718import React from 'react';import ReactDOM from 'react-dom';import './styles/main.scss';import App from './components/App';import * as serviceWorker from './serviceWorker';import modules from './modules';import &#123; createStore &#125; from 'redux';import &#123; Provider &#125; from 'react-redux';const store = createStore(modules, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());// 스토어를 모듈로 만들어 넣는다는 게 핵심ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'));serviceWorker.unregister(); Container의 생성12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// TodoInputContainer.jsimport React, &#123; Component &#125; from 'react';import TodoInput from '../components/TodoInput';import &#123; connect &#125; from 'react-redux';import &#123; bindActionCreators &#125; from 'redux';import * as inputActions from '../modules/input';import * as todosActions from '../modules/todos';class TodoInputContainer extends Component &#123; id = 1 getId = () =&gt; ++this.id; handleChange = (e) =&gt; &#123; console.log(\"handleChange\"); const &#123; value &#125; = e.target; const &#123; inputActions &#125; = this.props; inputActions.setInput(value); &#125; handleInsert = () =&gt; &#123; console.log(\"handleInsert\"); const &#123; inputActions, todosActions, value &#125; = this.props; const todo = &#123; id: this.getId(), text: value, done: false &#125;; todosActions.insert(todo); inputActions.setInput(''); &#125; render() &#123; const &#123; value &#125; = this.props; /* 해당 value는 import * as inputActions from '../modules/input'; import * as todosActions from '../modules/todos'; 중 inputActions에서 온다 */ const &#123; handleChange, handleInsert &#125; = this; return ( &lt;TodoInput onChange=&#123;handleChange&#125; onInsert=&#123;handleInsert&#125; value=&#123;value&#125; /&gt; ); &#125;&#125;export default connect( (state) =&gt; (&#123; value: state.input.get('value') &#125;), (dispatch) =&gt; (&#123; inputActions: bindActionCreators(inputActions, dispatch), todosActions: bindActionCreators(todosActions, dispatch) &#125;))(TodoInputContainer); 12345678910111213141516171819202122232425262728293031323334//TodoListContainer.jsimport React, &#123; Component &#125; from 'react';import TodoList from '../components/TodoList';import &#123; connect &#125; from 'react-redux';import &#123; bindActionCreators &#125; from 'redux';import * as todosActions from '../modules/todos';class TodoListContainer extends Component &#123; handleToggle = (id) =&gt; &#123; const &#123; todosActions &#125; = this.props; todosActions.toggle(id); &#125; handleRemove = (id) =&gt; &#123; const &#123; todosActions &#125; = this.props; todosActions.remove(id); &#125; render() &#123; const &#123; todos &#125; = this.props; // 해당 todos는 import * as todosActions from '../modules/todos';요기에서 온다 const &#123; handleRemove, handleToggle &#125; = this; return ( &lt;TodoList todos=&#123;todos&#125; onToggle=&#123;handleToggle&#125; onRemove=&#123;handleRemove&#125; /&gt; ); &#125;&#125;export default connect( (state) =&gt; (&#123; todos: state.todos &#125;), (dispatch) =&gt; (&#123; todosActions: bindActionCreators(todosActions, dispatch) &#125;))(TodoListContainer);","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술05","slug":"use-react05","date":"2019-02-27T07:06:18.000Z","updated":"2019-04-06T07:19:34.166Z","comments":true,"path":"2019/02/27/use-react05/","link":"","permalink":"http://eunajjing.github.io/2019/02/27/use-react05/","excerpt":"","text":"Immutable12345678910const &#123;Map&#125; = Immutable;const data = Map(&#123; a: 1, b: 2, c: Map(&#123; d: 3, e: 4, f: 5 &#125;)&#125;); 여러 층으로 구성된 객체를 만들 때 매번 Map({})을 쓰는 게 귀찮으므로 이를 해결해줄 fromJS 사용12345678910const &#123;Map, fromJS&#125; = Immutable;const data = fromJS(&#123; a: 1, b: 2, c: &#123; d: 3, e: 4, f: 5 &#125;&#125;); 사용법 data.toJS() : 자바스크립트 객체로 변환 data.get(&#39;a&#39;) : 특정 키의 값을 불러올 때 data.getIn([&#39;c&#39;, &#39;d&#39;]) : 내부의 키 값을 가져오려고 할 때 c 안의 d의 값을 부르는 것 data.set(&#39;a&#39;, 4) : 새로운 값을 넣은 map 생성 기존 map이 수정되는 것이 아니다 const newData = data.set(&#39;a&#39;, 4) 12345678910const &#123;Map, fromJS&#125; = Immutable;const newData = fromJS(&#123; a: 4, b: 2, c: &#123; d: 3, e: 4, f: 5 &#125;&#125;); data.setIn([&#39;c&#39;, &#39;d&#39;], 10) : 내부의 키에 값을 넣는 map을 생성하려고 할 때 마찬가지로 기존 객체가 변경되지는 않는다. data.updateIn([&#39;c&#39;, &#39;d&#39;], 불리언값 =&gt; !불리언값) : 해당 값을 바꾸려 할 때 data.merge({a: 10, b: 10}) : 값 여러 개를 동시에 바꾸려고 할 때 data.mergeIn([&#39;c&#39;], {d: 10, e: 10}) : 내부의 값 여러 개를 동시에 바꾸려고 할 때 체이닝 방식으로도 기술 가능하다 12const newData = data.setIn(['c', 'd'], 10) .setIn(['c', 'e'], 10); List 사용배열 대신 사용하는 것 map, filter, sort, push, pop을 내장하고 있다. 마찬가지로 List 자체를 변경하는 게 아니라, 새로운 List를 반환한다. 12const &#123;List&#125; = Immutable;const list = List([0, 1, 2, 3, 4,]); 객체들의 list를 만들어야 할 때는 123456789101112const &#123;List, Map, fromJS&#125; = Immutable;const list1 = List([ Map(&#123;value: 1&#125;), Map(&#123;value: 2&#125;)]);// orconst list2 = fromJS([ &#123;value: 1&#125;, &#123;value: 2&#125;]); 메서드들도 똑같이 쓸 수 있다. list.toJS() list1.get(0) // 이 경우 반환되는 것은 {value:1} 객체 list.getIn([0, &#39;value&#39;]) // 이 경우 0번 째 방의 value라는 키의 값, 즉 1 list.set(0, Map({value: 10})) // 이 경우 0번째 방의 객체를 바꾸겠다 list.setIn([0, &#39;value&#39;], 10) // 이 경우 0번째 방의 객체의 value 키의 값을 바꾸겠다 list.update(0, item =&gt; item.set(&#39;value&#39;, item.get(&#39;value&#39;)*5)) // 기존 값을 참고해서 업데이트 해야할 때 // 0번 방의 value 필드의 값을 기존 value 값에 * 5를 한 것으로 바꾸겠다 첫 번째 파라미터 : 선택할 인덱스 값 두 번째 파라미터 : 선택한 원소를 업데이트하는 메서드 list.setIn([0, &#39;value&#39;], list.ginIn([0, &#39;value&#39;]*5))와 같다 list.push(Map({value:3})) 마찬가지로 기존 것에 push 하는 게 아니라, 새로운 것을 만들어 push한다는 것에 유의 list.unshift(Map({value:0})) // 맨 앞에 넣고 싶을 때 list.delete(1) // 1번 방에 있는 객체 삭제 list.pop()은 맨 끝에 있는 것 list.size // length가 아니다 list.isEmpth()도 가능 bindActionCreatorsconnect 시에 사용하는 mapDispatchToProps 메서드에 사용할 수 있는 외부 모듈로 각각의 액션에 dispatch 설정을 해줄 필요가 없다. 12345678910111213141516export default connect( (state) =&gt; (&#123; value: state.input.get('value') &#125;), (dispatch) =&gt; (&#123; inputActions: bindActionCreators(inputActions, dispatch), /* inputActions: &#123; setInput: (value) =&gt; dispatch(inputActions.setInput(value)) // 액션생성함수들을 자동으로 연결시킴 &#125; */ todosActions: bindActionCreators(todosActions, dispatch) // 첫 번째 파라미터는 액션 생성 함수가 들어있는 객체 모듈, 두 번째 파라미터는 dispatch &#125;))(TodoInputContainer); Ducks액션 타입, 액션 생성 함수, 리듀서 모두 한 파일에서 모듈화하여 관리하는 파일 구조 규칙 export default를 이용하여 리듀서, 액션 생성 메서드를 내보내야 한다. 액션 타입의 명명규칙은 npm-module-or-app/reducer/ACTION_TYPE 형식이다. 여러 프로젝트로 나누거나 라이브러리를 만든 게 아니라면 npm-module-or-app/reducer/은 생략이 가능하다. 외부 리듀서에서 액션 타입이 필요할 때는 액션 타입 또한 내보내도 된다. redux-actions을 통한 관리yarn add redux-action으로 의존 설정을 해준 뒤 import {createAction, handleActions} from &#39;redux-actions&#39;으로 불러 실행한다. createAction액션 생성 메서드를 단축한다. 123456789101112131415161718192021222324// 액션 생성 메서드export const increment = createAction(types.INCREMENT);export const setColor = createAction(types.SET_COLOR);// setColor는 파라미터를 계속 객체로 받는다면,// 가독성을 위해 해당 부분을 명시해도 좋다.// export const setColor = createAction(types.SET_COLOR, (&#123;index, color&#125;) =&gt; (&#123;index, color&#125;))// 생성할 때increment(3);setColor(&#123;index:5, color:'#fff'&#125;)/*&#123; type: 'INCREAMENT', payload : 3&#125;&#123; type: 'SET_COLOR', payload : &#123; index : 5, color: '#fff' &#125;&#125;*/ handleActions12345678910const reducer = handleActions(&#123; INCREMENT: (state, action) =&gt; (&#123; counter: state.counter + action.payload &#125;), INCREMENT: (state, action) =&gt; (&#123; counter: state.counter - action.payload &#125;)&#125;, &#123;counter: 0&#125;);// 첫 번째 파라미터는 액션에 따라 실행할 함수를 가진 객체를 넣는다// 두 번째 파라미터는 기본 값을 넣는다","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술04 (실습)","slug":"use-react04-ex","date":"2019-02-27T01:06:18.000Z","updated":"2019-04-06T07:19:34.166Z","comments":true,"path":"2019/02/27/use-react04-ex/","link":"","permalink":"http://eunajjing.github.io/2019/02/27/use-react04-ex/","excerpt":"","text":"리덕스 사용해보기yarn add redux react-redux로 의존 설정을 더해준다. 함수형 컴포넌트의 경우 이전 기초 예제들과 거의 유사하다. 1234567891011121314151617181920212223import React from 'react';const Counter = (&#123;number, color, onIncrement, onDecrement, onSetColor&#125;) =&gt; &#123; return ( &lt;div className=\"Counter\" onClick=&#123;onIncrement&#125; onContextMenu=&#123;(e) =&gt; &#123; // onContextMenu : 오른쪽 버튼 클릭 시의 이벤트 e.preventDefault(); // 해당 이벤트를 막는다 onDecrement(); &#125;&#125; onDoubleClick=&#123;onSetColor&#125; style=&#123;&#123;backgroundColor: color&#125;&#125;&gt;&#123;number&#125;&lt;/div&gt; );&#125;;Counter.defaultProps = &#123; number: 0, color: 'black', onIncrement: () =&gt; console.warn(\"증가 아직 안됨\"), onDecrement: () =&gt; console.warn(\"감소 아직 안됨\"), onSetColor: () =&gt; console.warn(\"컬러 변경 아직 안됨\")&#125;export default Counter; 액션액션 정의12345// actionType.jsexport const INCREMENT = 'INCREMENT';export const DECREMENT = 'DECREMENT';export const SET_COLOR = 'SET_COLOR'; 액션 생성 메서드12345678910111213141516// action.jsimport * as types from './ActionTypes';export const increment = () =&gt; (&#123; type: INCREMENT&#125;);export const decrement = () =&gt; (&#123; type: DECREMENT&#125;);export const setColor = (color) =&gt; (&#123; type: SET_COLOR, color&#125;);// color의 경우 객체 자체를 넣는다. 리듀서12345678910111213141516171819202122232425262728293031import * as types from '../actions/ActionTypes';// 초기값 설정const initialState = &#123; color: 'black', number: 0&#125;function counter(state=initialState, action) &#123; switch (action.type) &#123; case types.INCREMENT: return &#123; ...state, number: state.number+1 &#125;; case types.DECREMENT: return &#123; ...state, number: state.number-1 &#125;; case types.SET_COLOR: return &#123; ...state, color: action.color &#125;; default: return state; &#125;&#125;export default counter; 관련 라이브러리 사용1234567891011121314import React from 'react';import ReactDOM from 'react-dom';import App from './containers/App';import &#123;createStore&#125; from 'redux';import reducers from './reducers';import &#123;Provider&#125; from 'react-redux';const store = createStore(reducers);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')); store를 생성하며 아까 만든 reduces를 파라미터로 넣어준다. 최상위 컴포넌트를 Provider로 감싸주고 props로 store를 보낸다. 컨테이너 생성12345678910111213141516171819202122232425262728293031323334353637383940import Counter from '../components/Counter';// 함수형 컴포넌트를 받아와서 하단의 커넥트로 묶어줌import * as actions from '../actions';import &#123;connect&#125; from 'react-redux';export function getRandomColor() &#123; const color=[ '#495057', ... ]; const random = Math.floor(Math.random() * 13); return color[random];&#125;// connect 메서드에 들어가는 파라미터 함수로,// 옵션이며 현재 스토어의 상태를 받아 컴포넌트의 props로 사용할 객체 반환const mapStateToProps = (state) =&gt; (&#123; color: state.color, number: state.number&#125;);// 액션 생성 메서드를 사용해 액션 생성 후// 해당 액션을 디스패치하는 메서드를 만든 후 이를 props로 연결const mapDispatchToProps = (dispatch) =&gt; (&#123; onIncrement: () =&gt; dispatch(actions.increment()), onDecrement: () =&gt; dispatch(actions.decrement()), onSetColor: () =&gt; &#123; const color = getRandomColor(); dispatch(actions.setColor(color)); &#125;&#125;);// 뷰단 컴포넌트를 애플리케이션의 데이터 레이어와 묶는 역할을 한다const CounterContainer = connect( mapStateToProps, mapDispatchToProps)(Counter);export default CounterContainer; 최상위 컴포넌트에서 컨테이너 받아오기1234567891011121314import React, &#123; Component &#125; from 'react';import CounterContainer from './CounterContainer';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;CounterContainer /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 서브 리듀서 사용해보기위의 코드와 거의 비슷한데, 일단 리듀서들을 두 개 작성한다. 1234567891011121314151617181920212223// number.jsimport * as types from '../actions/ActionTypes';const initialState = &#123; number: 0&#125;;const number = (state=initialState, action) =&gt; &#123; switch (action.type) &#123; case types.INCREMENT: return &#123; number: state.number+1 &#125;; case types.DECREMENT: return &#123; number: state.number-1 &#125;; default: return state; &#125;&#125;export default number; 그리고 통합 리듀서에서 이들을 합친다. 1234567891011import color from './color';import number from './number';import &#123;combineReducers&#125; from 'redux';// 서브 리듀서들을 하나로 합치는 라이브러리const reducers = combineReducers(&#123; numberData : number, colorData : color&#125;);export default reducers; 컨테이너에서 state 참조는 이렇게 한다. 123456//CounterContainer.jsconst mapStateToProps = (state) =&gt; (&#123; color: state.colorData.color, number: state.numberData.number&#125;); list 형태 데이터 사용액션 생성 함수에 인덱스를 넣는다 123456789101112131415161718192021222324252627// index.jsimport * as types from './ActionTypes';// 액션 타입 정의를 받아온다export const create = (color) =&gt; (&#123; type: types.CREATE, color&#125;);export const remove = () =&gt; (&#123; type: types.REMOVE&#125;);export const increment = (index) =&gt; (&#123; type: types.INCREMENT, index&#125;);export const decrement = (index) =&gt; (&#123; type: types.DECREMENT, index&#125;);export const setColor = (&#123;color, index&#125;) =&gt; (&#123; type: types.SET_COLOR, color, index&#125;); 리듀서가 복잡해진다. 가독성이 떨어지므로 추후 다른 것을 이용해 대체한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// index.jsimport * as types from '../actions/ActionTypes';const initaialState = &#123; counters: [ &#123; color: 'black', number: 0 &#125; ]&#125;;function counter(state = initaialState, action) &#123; const &#123;counters&#125; = state; switch(action.type) &#123; case types.CREATE: return &#123; counters: [ ...counters, &#123; color: action.color, number: 0 &#125; ] &#125;; case types.REMOVE: return &#123; counters : counters.slice(0, counters.length - 1) &#125;; case types.INCREMENT: return &#123; counters: [ ...counters.slice(0, action.index), &#123; ...counters[action.index], number: counters[action.index].number + 1 &#125;, ...counters.slice(action.index+1, counters.length) ] &#125;; case types.DECREMENT: return &#123; counters: [ ...counters.slice(0, action.index), &#123; ...counters[action.index], number: counters[action.index].number - 1 &#125;, ...counters.slice(action.index+1, counters.length) ] &#125;; case types.SET_COLOR: return &#123; counters: [ ...counters.slice(0, action.index), &#123; ...counters[action.index], color : action.color &#125;, ...counters.slice(action.index+1, counters.length) ] &#125;; default: return state; &#125;&#125;export default counter; 함수형 컴포넌트12345678910111213// Buttons.jsimport React from 'react';const Buttons = (&#123;onCreate, onRemove&#125;) =&gt; &#123; return ( &lt;div className=\"Buttons\"&gt; &lt;div className=\"btn add\" onClick=&#123;onCreate&#125;&gt;생성&lt;/div&gt; &lt;div className=\"btn remove\" onClick=&#123;onRemove&#125;&gt;제거&lt;/div&gt; &lt;/div&gt; );&#125;export default Buttons; 123456789101112131415161718192021222324// CounterList.jsimport React from 'react';import Counter from './Counter';// 이 형태의 배열을 만들 것const CounterList = (&#123;counters, onIncrement, onDecrement, onSetColor&#125;) =&gt; &#123; const counterList = counters.map( (counter, i) =&gt; &#123; return ( &lt;Counter key=&#123;i&#125; index=&#123;i&#125; &#123;...counter&#125; onIncrement=&#123;onIncrement&#125; onDecrement=&#123;onDecrement&#125; onSetColor=&#123;onSetColor&#125;/&gt; )&#125; ); return ( &lt;div className=\"CounterList\"&gt; &#123;counterList&#125; &lt;/div&gt; );&#125;;CounterList.defaultProps = &#123; counters: []&#125;export default CounterList; 12345678910111213141516171819202122232425262728293031// Counter.jsimport React from 'react';const Counter = (&#123;number, color, index, onIncrement, onDecrement, onSetColor&#125;) =&gt; &#123; return ( &lt;div className=\"Counter\" onClick=&#123;() =&gt; onIncrement(index)&#125; onContextMenu=&#123;(e) =&gt; &#123; e.preventDefault(); onDecrement(index); &#125;&#125; onDoubleClick=&#123;() =&gt; onSetColor(index)&#125; style=&#123;&#123; backgroundColor: color &#125;&#125;&gt; &#123;number&#125; &lt;/div&gt; );&#125;;Counter.defaultProps = &#123; index: 0, number: 0, color: 'black', onIncrement: () =&gt; console.warn('onIncrement not defined'), onDecrement: () =&gt; console.warn('onDecrement not defined'), onSetColor: () =&gt; console.warn('onSetColor not defined')&#125;;export default Counter; 컨테이너 생성123456789101112131415161718192021import CounterList from '../components/CounterList';import * as actions from '../actions';import &#123;connect&#125; from 'react-redux';import getRandomColor from '../lib/getRandomColor';const mapStateToProps = (state) =&gt; (&#123;counters: state.counters&#125;);// store 안의 state 값을 props로 연결const mapDispatchToProps = (dispatch) =&gt; (&#123; onIncrement : (index) =&gt; dispatch(actions.increment(index)), onDecremant : (index) =&gt; dispatch(actions.decrement(index)), onSetColor : (index) =&gt; &#123; const color = getRandomColor(); dispatch(actions.setColor(&#123;index, color&#125;)); &#125;&#125;)const CounterListContainer = connect(mapStateToProps, mapDispatchToProps)(CounterList);export default CounterListContainer; 버튼에 대한 컨테이너가 없기 때문에 앱에서 해당 내용 처리 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import Buttons from '../components/Buttons';import CounterListContainer from './CounterListContainer';import getRandomColor from '../lib/getRandomColor';import &#123;connect&#125; from 'react-redux';import * as actions from '../actions';class App extends Component &#123; render() &#123; const &#123;onCreate, onRemove&#125; = this.props; return ( &lt;div className=\"App\"&gt; &lt;Buttons onCreate=&#123;onCreate&#125; onRemove=&#123;onRemove&#125; /&gt; &lt;CounterListContainer /&gt; &lt;/div&gt; ); &#125;&#125;const mapToDispatch = (dispatch) =&gt; (&#123; onCreate: () =&gt; dispatch(actions.create(getRandomColor())), onRemove: () =&gt; dispatch(actions.remove())&#125;);export default connect(null, mapToDispatch)(App);","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술04","slug":"use-react04","date":"2019-02-26T06:09:18.000Z","updated":"2019-04-06T07:19:34.166Z","comments":true,"path":"2019/02/26/use-react04/","link":"","permalink":"http://eunajjing.github.io/2019/02/26/use-react04/","excerpt":"","text":"리덕스 state를 컴포넌트 밖에서 관리하기 위해 사용 용어 스토어: state 저장하고 있는 객체 액션 : 상태에 변화를 일으켜야 할 때 스토어에 전달하는 객체 리듀서 : 액션을 참고해서 스토어의 state를 어떻게 바꿀 것인지 결정해서 바꿈 디스패치 : 액션을 전달하는 행위 규칙 스토어는 단 한 개이다 리듀서는 여러 개를 만들 수 있다 모든 변화는 리듀서 함수로 일어나야 한다. 리듀서 함수에서 외부 네트워크, 데이터베이스에 직접 접근해선 안된다. 리듀서 함수 내부에서는 new Date()와 Math.random()을 사용하면 안된다. 액션123&#123; type: \"INCREMENT\"&#125; type 어떤 작업을 하는 액션인지 정의 대문자와 _로 구성한다. 필수 값이다. 값은 고정이다. 예시 1234&#123; type: \"INCREMENT\", text: '리액트 배우기'&#125; 12345678&#123; type: \"INCREMENT\", todos: &#123; id: 1, text: '리액트 배우기', done: false &#125;&#125; 액션 생성함수1234567891011const INCREMENT = 'INCREMENT';const DECREMENT = 'DECREMENT';const increment = (diff) =&gt; &#123; type: INCREMENT diff: diff&#125;const decrement = (diff) =&gt; &#123; type: DECREMENT diff: diff&#125; 리듀서 파라미터 현재 상태 액션 객체 initialState 값을 설정해준다 1234// 액션 함수를 위에 쓴 뒤에const initialState = &#123; number: 0&#125;; 리듀서 함수 시작 12345678910function counter(state = initialState, action) &#123; switch(action.type)&#123; case INCREMENT: retrun &#123;number: state.number + action.diff&#125;; case DECREMENT: retrun &#123;number: state.number - action.diff&#125;; default: retrun state; &#125;&#125; 만약 액션 객체 안에 많은 속성들이 있다면 1234567891011121314151617181920const initialState = &#123; number: 0, foo: 'bar', baz: 'qux'&#125;;function counter(state = initialState, action) &#123; switch(action.type)&#123; case INCREMENT: retrun Object.assign(&#123;&#125;, state, &#123; number: state.number + action.diff &#125;); case DECREMENT: retrun Object.assign(&#123;&#125;, state, &#123; number: state.number - action.diff &#125;); default: retrun state; &#125;&#125; Object.assign파라미터로 전달된 객체들을 순서대로 합친다. 역순으로 객체를 왼쪽으로 덮어쓰면서 새 객체를 만들어준다. 1234567891011121314&gt; const target = &#123; a: 1, b: 2 &#125;;&gt; &gt; console.log(target);&gt; // expected output: Object &#123; a: 1, b: 2 &#125;&gt; &gt; const source = &#123; b: 4, c: 5 &#125;;&gt; const returnedTarget = Object.assign(target, source);&gt; &gt; console.log(target);&gt; // expected output: Object &#123; a: 1, b: 4, c: 5 &#125;&gt; // assign 메서드 진행하며 이미 값이 바뀜&gt; console.log(returnedTarget);&gt; // expected output: Object &#123; a: 1, b: 4, c: 5 &#125;&gt; 근데 이렇게 쓰는 것보다 전개 연산자를 이용해서 더 많이 쓴다. 1234567891011&gt; function counter(state= initalState, action) &#123;&gt; switch(action.type) &#123;&gt; case INCREMENT:&gt; return &#123;&gt; ...state,&gt; number: state.number + action.diff&gt; &#125;;&gt; case ....&gt; &#125;&gt; &#125;&gt; 스토어createStore(counter) 스토어 생성 메서드 파라미터 리듀서 함수(필수) 기본값(옵션) 1const store = createStore(counter); store.subscribe(콜백함수) 보통 react-redux의 connect()가 대신함 1234567const unsubscribe = store.subscribe(() =&gt; &#123; // 스토어 상태에 변화가 일어날 때마다 실행된다. console.log(store.getState()); // 현재 스토어 상태를 콘솔에 찍음 // 구독을 취소하는 unsubscribe()가 반환된다. // 나중에 구독을 취소할 때는 unsubscribe()을 부르면 됨&#125;);","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"mobx","slug":"2019-02-26-리액트를-다루는-기술04","date":"2019-02-26T04:26:18.000Z","updated":"2019-04-28T09:20:37.762Z","comments":true,"path":"2019/02/26/2019-02-26-리액트를-다루는-기술04/","link":"","permalink":"http://eunajjing.github.io/2019/02/26/2019-02-26-리액트를-다루는-기술04/","excerpt":"","text":"MOBX 책에 있는 내용이 아닌, 저자 블로그를 보고 개념을 익힘 하다가 굳이 mobx를 할 필요가 있겠냐는 말을 들어서(hook과 관련된 말이었다) 일단 리덕스를 더 해보기로 결정… ~홀드~ observable관찰 받고 있는 상태, Observable State를 만들어준다. 123456import &#123; observable, reaction, computed, autorun &#125; from 'mobx';const calculator = observable(&#123; a: 1, b: 2&#125;); reaction관찰 받고 있는 상태가 바뀔 때 사용 1234567reaction( () =&gt; calculator.a, (value, reaction) =&gt; &#123; console.log(`a 값이 $&#123;value&#125; 로 바뀌었네요!`); &#125;);// 이 경우 A의 값이 바뀔 때마다 실행된다. computed연산된 값을 사용해야 할 때 사용 의존하는 값이 바뀔 때 미리 값을 계산해놓고 조회할 때 캐싱된 데이터를 사용한다. 1234567const sum = computed(() =&gt; &#123; return calculator.a + calculator.b;&#125;);sum.observe(() =&gt; calculator.a);// a 값을 주시, a 값이 바뀔 때마다 자동으로 실행sum.observe(() =&gt; calculator.b); // b 값을 주시 autorunreaction(), computed()의 observe()대신 쓸 수 있다. 함수 내에서 조회하는 값을 자동으로 주시하고 있다. 123autorun(() =&gt; console.log(`a 값이 $&#123;calculator.a&#125; 로 바뀌었네요!`));autorun(() =&gt; console.log(`b 값이 $&#123;calculator.b&#125; 로 바뀌었네요!`));autorun(() =&gt; sum.get()); computed 로 만든 값의 .get() 함수를 호출해주면, 하나하나 observe 해주지 않아도 된다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술03 - css","slug":"use-react03","date":"2019-02-19T00:47:18.000Z","updated":"2019-04-06T07:19:34.165Z","comments":true,"path":"2019/02/19/use-react03/","link":"","permalink":"http://eunajjing.github.io/2019/02/19/use-react03/","excerpt":"","text":"모든 출처는 벨로퍼티 님 블로그 보면서 따라한 내용 / 혼자 검색해서 볼 것 같은 내용을 정리 SCSSSass를 CSS로 변환해주는 node-sass라는 라이브러리를 설치한다. 1$ yarn add node-sass 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 변수 사용하기$red: #fa5252;$orange: #fd7e14;$yellow: #fcc419;$green: #40c057;$blue: #339af0;$indigo: #5c7cfa;$violet: #7950f2;// mixin 만들기 (재사용되는 스타일 블록을 함수처럼 사용 할 수 있음)@mixin square($size) &#123; $calculated: 32px * $size; width: $calculated; height: $calculated;&#125;.SassComponent &#123; display: flex; .box &#123; background: red; // 일반 CSS 에선 .SassComponent .box 와 마찬가지 cursor: pointer; transition: all 0.3s ease-in; &amp;.red &#123; // .red 클래스가 .box 와 함께 사용 됐을 때 // &amp;는 부모를 레퍼런스할 때 쓴다. background: $red; @include square(1); // mixin 사용 &#125; &amp;.orange &#123; background: $orange; @include square(2); &#125; &amp;.yellow &#123; background: $yellow; @include square(3); &#125; &amp;.green &#123; background: $green; @include square(4); &#125; &amp;.blue &#123; background: $blue; @include square(5); &#125; &amp;.indigo &#123; background: $indigo; @include square(6); &#125; &amp;.violet &#123; background: $violet; @include square(7); &#125; &amp;:hover &#123; // .box 에 마우스 올렸을 때 background: black; &#125; &#125;&#125; sass-loader 설정 커스터마이징경로가 너무 길어질 경우 Webpack에서 sass-loader 설정을 커스터마이징하여 해결할 수 있다. 이 때 create-react-app으로 만들어진 것은 세부 설정들이 숨어있으므로 명령어를 통해 설정을 밖으로 꺼내준다. 1yarn eject 원본 1234567891011121314&#123; test: sassRegex, exclude: sassModuleRegex, use: getStyleLoaders( &#123; importLoaders: 2, sourceMap: isEnvProduction ? shouldUseSourceMap : isEnvDevelopment, &#125;, 'sass-loader' ), sideEffects: true,&#125; 교체 123456789101112131415&#123; test: sassRegex, exclude: sassModuleRegex, use: getStyleLoaders(&#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap &#125;).concat(&#123; loader: require.resolve('sass-loader'), options: &#123; includePaths: [paths.appSrc + '/styles'], sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap &#125; &#125;), sideEffects: true&#125; 이 설정을 하게 되면 해당 파일 경로가 어디에 위치하더라도, 상대 경로를 입력하지 않고 styles 디렉토리 기준 절대경로로 불러올 수 있다. 만약 모든 곳에서 import가 필요한 css라면 옵션 설정을 해준다. 12345678910111213141516&#123; test: sassRegex, exclude: sassModuleRegex, use: getStyleLoaders(&#123; importLoaders: 2, sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap &#125;).concat(&#123; loader: require.resolve('sass-loader'), options: &#123; includePaths: [paths.appSrc + '/styles'], sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap, data: `@import 'utils';` &#125; &#125;), sideEffects: true &#125;, node_modules 에서 불러오기open-color나 include-media 등의 모듈을 사용했을 경우, 관련 scss 파일들이 node_modules 에 있다. 이를 가져오는 방법! 1@import'~include-media/dist/include-media'; CSS ModuleCSS 클래스를 불러와서 사용 할 때 [js 파일이름]_[클래스이름]__[해쉬값] 형태로 클래스네임을 자동으로 고유한 값으로 만들어주어서 컴포넌트 스타일 중첩현상을 방지해주는 기술 이를 사용하기 위해서는 파일 이름을 JS 파일 이름.module.css 이런 식으로 저장해야 함 12345678910111213141516171819202122/* 자동으로 고유해질 것이므로 흔히 사용되는 단어를 클래스 이름으로 마음대로 사용가능*/.wrapper &#123; background: black; padding: 1rem; color: white; font-size: 2rem;&#125;.inverted &#123; color: black; background: white;&#125;/* 글로벌 CSS 를 작성하고 싶다면 */:global &#123; .something &#123; font-weight: 800; color: aqua; &#125;&#125; src/CSSModule.js 123456789101112import React from &apos;react&apos;;import styles from &apos;./CSSModule.module.css&apos;;const CSSModule = () =&gt; &#123; return ( &lt;div className=&#123;`$&#123;styles.wrapper&#125; $&#123;styles.inverted&#125;`&#125;&gt; 안녕하세요, 저는 &lt;span className=&quot;something&quot;&gt;CSS Module!&lt;/span&gt; &lt;/div&gt; );&#125;;export default CSSModule; 이 때 {sytles.wrapper}에 반환되는 객체는 {wrapper: &quot;CSSModule_wrapper__CUMkx&quot;}로 CSS Module 에서 사용한 클래스 이름과, 해당 이름을 고유화시킨 값이 key-value 형태로 들어있다. 만약 CSS Module이 아닌 파일에서 CSS Module을 쓰고 싶다면12345:local &#123; .wrapper &#123; /* 스타일 */ &#125;&#125; classNames CSS 클래스를 조건부로 설정할 때 쓰는 라이브러리 1$ yarn add classnames 기본 사용법 123456789import classNames from 'classnames';classNames('one', 'two'); // 'one two'classNames('one', &#123; two: true &#125;); // 'one two'classNames('one', &#123; two: false &#125;); // 'one'classNames('one', ['two', 'three']); // 'one two three'const myClass = 'hello';classNames('one', myClass, &#123; myCondition: true &#125;); //'one hello myCondition' 123const MyComponent = (&#123; highlighted, theme &#125;) =&gt; &#123; &lt;div className=&#123;classNames('MyComponent', &#123; highlighted &#125;, theme)&#125;&gt;Hello&lt;/div&gt;&#125; highlighted 값이 뭔가에 따라 적용 여부가 달라진다. classnames/bind123456789101112131415import React from 'react';import classNames from 'classnames/bind';import styles from './CSSModule.module.css';const cx = classNames.bind(styles); // 미리 styles 에서 클래스를 받아오도록 설정하고const CSSModule = () =&gt; &#123; return ( &lt;div className=&#123;cx('wrapper', 'inverted')&#125;&gt; 안녕하세요, 저는 &lt;span className=\"something\"&gt;CSS Module!&lt;/span&gt; &lt;/div&gt; );&#125;;export default CSSModule; Tagged Template Literal내부에 JavaScript 객체나 함수가 전달 될 때 이를 따로 추출할 때 사용 123&gt; `hello $&#123;&#123;foo: 'bar' &#125;&#125; $&#123;() =&gt; 'world'&#125;!`&gt; // 결과: \"hello [object Object] () =&gt; 'world'!\"&gt; 문자열이 출력되어야 하는 곳에 [object Object]라고 나온다. 그래서 사용하는 방법 12345&gt; function tagged(...args) &#123;&gt; console.log(args);&gt; &#125;&gt; tagged`hello $&#123;&#123;foo: 'bar' &#125;&#125; $&#123;() =&gt; 'world'&#125;!`&gt; styled-components 하나의 자바스크립트 파일안에 스타일까지 작성 할 수 있다는 장점이 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React from 'react';import styled, &#123; css &#125; from 'styled-components';const Box = styled.div` /* props 로 넣어준 값을 직접 전달해줄 수 있습니다. */ background: $&#123;props =&gt; props.color || 'blue'&#125;; padding: 1rem; display: flex; /* 기본적으로는 1024px 에 가운데 정렬을 하고 가로 크기가 작아짐에 따라 사이즈를 줄이고 768px 미만으로 되면 꽉 채웁니다 */width: 1024px;margin: 0 auto;@media (max-width: 1024px) &#123; width: 768px;&#125;@media (max-width: 768px) &#123; width: 100%;&#125;`;const Button = styled.button` background: white; color: black; border-radius: 4px; padding: 0.5rem; display: flex; align-items: center; justify-content: center; box-sizing: border-box; font-size: 1rem; font-weight: 600; /* &amp; 문자를 사용하여 Sass 처럼 자기 자신 선택 가능 */ &amp;:hover &#123; background: rgba(255, 255, 255, 0.9); &#125; /* 다음 코드는 inverted 값이 true 일 때 특정 스타일을 부여해줍니다. */ $&#123;props =&gt; props.inverted &amp;&amp; css` background: none; border: 2px solid white; color: white; &amp;:hover &#123; background: white; color: black; &#125; `&#125;; &amp; + button &#123; margin-left: 1rem; &#125;`;const StyledComponent = () =&gt; ( &lt;Box color=\"black\"&gt; &lt;Button&gt;안녕하세요&lt;/Button&gt; &lt;Button inverted=&#123;true&#125;&gt;테두리만&lt;/Button&gt; &lt;/Box&gt;);export default StyledComponent; box의 media css의 경우 이렇게도 넣을 수 있다. 123456789101112131415161718192021222324252627282930import React from 'react';import styled, &#123; css &#125; from 'styled-components';const sizes = &#123; desktop: 1024, tablet: 768&#125;;// 위에있는 size 객체에 따라 자동으로 media 쿼리 함수를 만들어줍니다.// 참고: https://www.styled-components.com/docs/advanced#media-templatesconst media = Object.keys(sizes).reduce((acc, label) =&gt; &#123; acc[label] = (...args) =&gt; css` @media (max-width: $&#123;sizes[label] / 16&#125;em) &#123; $&#123;css(...args)&#125;; &#125; `; return acc;&#125;, &#123;&#125;);const Box = styled.div` /* props 로 넣어준 값을 직접 전달해줄 수 있습니다. */ background: $&#123;props =&gt; props.color || 'blue'&#125;; padding: 1rem; display: flex; width: 1024px; margin: 0 auto; $&#123;media.desktop`width: 768px;`&#125; $&#123;media.tablet`width: 768px;`&#125;;`; 스타일링 된 엘리먼트를 만들 때는 12345import styled from &apos;styled-components&apos;;const MyComponent = styled.div` font-size: 2rem;`; 혹은 태그가 유동적이거나 특정 컴포넌트에 스타일링을 해야하는 상황이라면 (특정 컴포넌트에 스타일링을 해야하는 상황이 무슨 뜻이지) 12345678// 문자열로 styled 의 인자로 전달const MyInput = styled('input')` background: gray;`// 아예 컴포넌트 형식의 값을 넣어줌const StyledLink = styled(Link)` color: blue;`","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술02","slug":"use-react02","date":"2019-02-17T07:51:18.000Z","updated":"2019-04-06T07:28:48.098Z","comments":true,"path":"2019/02/17/use-react02/","link":"","permalink":"http://eunajjing.github.io/2019/02/17/use-react02/","excerpt":"","text":"이 포스트는 리액트를 다루는 기술이라는 책을 보며 혼자 공부한 기록을 남기는데 의미를 두고 있습니다. 책의 요약도 있긴 하지만 대체로 저 개인이 중요하다고 생각하는 포인트들과 이해한 영역에 대해 이야기합니다. 포스트는 언제든 삭제가 될 가능성이 있습니다…. refhtml에서 id를 사용해 DOM에 이름을 다는 것처럼, 리액트 프로젝트 내부에서 DOM에 이름을 다는 방법 DOM을 꼭 직접적으로 건드려야 할 때 쓰인다. 리액트 컴포넌트 안에서도 id를 사용할 수 있지만, 특수한 경우가 아니면 권장되지 않음 같은 컴포넌트를 여러 번 사용할 때, id가 유일하지 못하기 때문 ref는 컴포넌트 내부에서만 작동하기 때문에 전역적이 아님 syntax &lt;input ref={(ref) =&gt; {this.input=ref}}/&gt; 123456789101112131415161718192021222324class ValidationSample extends Component &#123; handleButtonClick = () =&gt; &#123; this.setState(&#123; clicked: true, validated: this.state.password === '0000' &#125;); this.password.focus(); // this.password는 ref가 password인 컴포넌트를 부르는 것 &#125; render() &#123; return ( &lt;div&gt; &lt;input type=\"password\" name=\"password\" onChange=&#123;this.handleChange&#125; className=&#123;this.state.validated ? 'success' : 'failure'&#125; ref=&#123;(ref) =&gt; this.password=ref&#125; /&gt; &#123;*/이 때 ref는 password가 된다 만약 다른 이름으로 지정하고 싶다면 this.하고_싶은_이름 = ref /*&#125; &lt;button onClick=&#123;this.handleButtonClick&#125;&gt;검증하기&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; 컴포넌트 자체에도 ref를 붙일 수 있고, 이 ref를 이용해 컴포넌트 내부 메서드 및 멤버 변수에도 접근이 가능하다. ES6의 비구조화 할당 문법객체에서 특정 값을 추출해 따로 레퍼런스를 만들 때 유용 1234567891011121314&gt; const object = &#123;&gt; foo: 1,&gt; bar: 2&gt; &#125;&gt; &gt; const &#123;foo, bar&#125; = object;&gt; console.log(foo, bar);&gt; &gt; function print(&#123;foo, bar&#125;) &#123;&gt; console.log(foo, bar);&gt; &#125;&gt; &gt; print(object);&gt; 외부 레퍼런스 전개 연산자 ...외부 레퍼런스 1234&gt; function test(a, b, c) &#123;&#125;&gt; let x = [1, 2, 'd'];&gt; text(...x);&gt; 이 때 test의 파라미터로 1, 2, d가 간다. x는 배열이다. 즉, 배열의 내용을 복사하되 껍데기인 []를 지운다. 123456789101112131415161718192021222324252627// ScrollBox.jsclass ScrollBox extends Component &#123; scrollToBottom = () =&gt; &#123; const &#123; scrollHeight, clientHeight &#125; = this.box; this.box.scrollTop = scrollHeight - clientHeight; &#125; render() &#123;..&#125;&#125;export default ScrollBox;// app.jsimport ScrollBox from './ScrollBox';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;ScrollBox ref=&#123;(ref) =&gt; this.scrollBox=ref&#125;/&gt; &lt;button onClick=&#123;() =&gt; this.scrollBox.scrollToBottom()&#125;&gt;밑으로&lt;/button&gt; // 컴포넌트가 렌더링될 때, 아직 자식 컴포넌트는 렌더링되기 전이므로 // 새로운 함수를 만들어 실행하는 것 &lt;/div&gt; ); &#125;&#125; map()syntax : arr.map(callback, [thisArg]) callback : 새로운 배열 요소를 생성하는 함수 파라미터들 currentValue : 현재 처리하고 있는 요소 index : 현재 처리하고 있는 요소의 index 값 array : 현재 처리하고 있는 원본 배열 thisArg : 옵션 항목. 콜백 함수 내부에서 사용할 this 레퍼런스 1234567891011class IterationSample extends Component &#123; render() &#123; const names = ['눈사람', '얼음', '눈', '바람']; const nameList = names.map((name) =&gt; (&lt;li&gt;&#123;name&#125;&lt;/li&gt;)); return ( &lt;ul&gt; &#123;nameList&#125; &lt;/ul&gt; ); &#125;&#125; key컴포넌트 배열을 렌더링했을 때 어떤 원소에 변동이 있었는지 알아내기 위해 사용 위의 소스는 실행되지만, 콘솔에는 key가 없다는 에러가 난다. 1234567891011class IterationSample extends Component &#123; render() &#123; const names = ['눈사람', '얼음', '눈', '바람']; const nameList = names.map((name, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;name&#125;&lt;/li&gt;); return ( &lt;ul&gt; &#123;nameList&#125; &lt;/ul&gt; ); &#125;&#125; concat()1234567891011121314151617181920212223242526272829303132class IterationSample extends Component &#123; state = &#123; names: ['눈사람', '얼음', '눈', '바람'], name: '' &#125; handleChange = (e) =&gt; &#123; this.setState(&#123; name: e.target.value &#125;); &#125; handleInsert = () =&gt; &#123; this.setState(&#123; names: this.state.names.concat(this.state.name), name: '' &#125;); &#125; render() &#123; const nameList = this.state.names.map((name, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;name&#125;&lt;/li&gt;); return ( &lt;div&gt; &lt;div&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.name&#125;/&gt; &lt;button onClick=&#123;this.handleInsert&#125;&gt;추가&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123;nameList&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125;&#125; slice()어떤 배열의 begin부터 end까지(end 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환 12345678910var animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];console.log(animals.slice(2));// expected output: Array [\"camel\", \"duck\", \"elephant\"]console.log(animals.slice(2, 4));// expected output: Array [\"camel\", \"duck\"]console.log(animals.slice(1, 5));// expected output: Array [\"bison\", \"camel\", \"duck\", \"elephant\"] 숫자는 0부터 시작한다. end는 그냥 -1로 기억하자. (begin부터 end-1까지 반환된다) 123456789101112131415class IterationSample extends Component &#123; handleRemove = (index) =&gt; &#123; const &#123;names&#125; = this.state; this.setState(&#123; names: [...names.slice(0, index), ...names.slice(index+1)] &#125;) &#125; render() &#123; const nameList = this.state.names.map((name, index) =&gt; &lt;li key=&#123;index&#125; onClick=&#123;() =&gt; this.handleRemove(index)&#125;&gt; &#123;name&#125; &lt;/li&gt;); return () &#125;&#125; filter()이렇게 romove를 구현할 수도 있다. 123456789101112131415class IterationSample extends Component &#123; handleRemove = (index) =&gt; &#123; const &#123;names&#125; = this.state; this.setState(&#123; names: names.filter((item, i) =&gt; &#123; // item에는 각각의 값이 오고 // (사용하지 않는 파라미터라 삭제하려고 했는데 // 삭제 후 동작이 안되는 걸 보니 옵셔널이 아닌 것 같다) // i는 인덱스 return i !== index // filter는 배열을 리턴한다. &#125;) &#125;) &#125;&#125; ​ 라이프 사이클1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class LifeCycleSample extends Component &#123; state = &#123; number: 0, color: null, &#125; myRef = null; // ref 를 설정 할 부분 constructor(props) &#123; super(props); console.log('constructor'); &#125; static getDerivedStateFromProps(nextProps, prevState) &#123; // nextProps : 부모가 전달한 값 // prevState : 내가 가지고 있는 값 console.log('getDerivedStateFromProps'); if (nextProps.color !== prevState.color) &#123; return &#123; color: nextProps.color &#125;; &#125; return null; &#125; componentDidMount() &#123; console.log('componentDidMount'); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('shouldComponentUpdate'); // 숫자의 마지막 자리가 4면 리렌더링하지 않습니다 return nextState.number % 10 !== 4; &#125; componentWillUnmount() &#123; console.log('componentWillUnmount'); &#125; handleClick = () =&gt; &#123; this.setState(&#123; number: this.state.number + 1 &#125;); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; console.log('getSnapshotBeforeUpdate'); // 그 전에 부모가 내게 줬던 값과 내가 가지고 있던 상태 값 if (prevProps.color !== this.props.color) &#123; return this.myRef.style.color; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; console.log('componentDidUpdate'); if (snapshot) &#123; console.log('업데이트 되기 직전 색상: ', snapshot); &#125; &#125; render() &#123; console.log('render'); const style = &#123; color: this.props.color &#125;; return ( &lt;div&gt; &lt;h1 style=&#123;style&#125; ref=&#123;ref =&gt; this.myRef = ref&#125;&gt; &#123;this.state.number&#125; &lt;/h1&gt; &lt;p&gt;color: &#123;this.state.color&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; 더하기 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트를 다루는 기술01","slug":"use-react01","date":"2019-02-17T05:31:18.000Z","updated":"2019-04-06T07:19:34.163Z","comments":true,"path":"2019/02/17/use-react01/","link":"","permalink":"http://eunajjing.github.io/2019/02/17/use-react01/","excerpt":"","text":"이 포스트는 리액트를 다루는 기술이라는 책을 보며 혼자 공부한 기록을 남기는데 의미를 두고 있습니다. 책의 요약도 있긴 하지만 대체로 저 개인이 중요하다고 생각하는 포인트들과 이해한 영역에 대해 이야기합니다. 포스트는 언제든 삭제가 될 가능성이 있습니다…. 렌더링사용자 화면에 뷰를 보여주는 것 초기 렌더링 : 리액트 컴포넌트가 최초로 실행하는 렌더링 리렌더링 : 컴포넌트의 데이터 변경으로 재실행되는 렌더링 용어 정리 빌드 : 여러 파일로 분리된 프로젝트를 한 파일로 합친다. 번들링 : 파일을 묶듯이 연결한다. React는 왜 가상 DOM을 만드는가실제 DOM은 변화가 일어나면 웹 브라우저가 css를 다시 연산하고, 레이아웃을 구성하고, 페이지를 리페인트한다. 즉, 시간이 허비된다. 리액트는 가상 DOM 방식을 사용하여 DOM 업데이트를 추상화하고, DOM 처리 횟수를 최소화해 효율적으로 진행한다. 실제 DOM이 업데이트되는 과정 데이터 업데이트 전체 UI를 가상 DOM에 리렌더링 이전 가상 DOM과 리렌더링한 가상 DOM 비교 바뀐 부분만 실제 DOM에 적용 컴포넌트 props의 전달&lt;MyComponent name={3}/&gt; 문자열 종류 외의 값을 전달할 때는 {}로 감싸야 한다. propTypes의 종류 array bool func number object string symbol : ES6에 추가된 것으로 유일한 식별자의 역할을 한다. 외부 레퍼런스 node : 렌더링할 수 있는 모든 것 element : 리액트 요소 instanceOf(MyClass) : 특정 클래스의 인스턴스 oneOf([&#39;~&#39;, &#39;~&#39;]) : 주어진 배열 요소 중 하나의 값 oneOfType([React.PropTypes.~, React.PropTypes.~]) : 주어진 배열 안의 종류 중 하나 arrayOf(React.PropTypes.~) : 주어진 종류로 구성된 배열 objectOf(React.PropTypes.~) : 주어진 종류의 값을 가진 객체 shape({ ~: React.PropTypes.~, ~: React.PropTypes.~}) : 주어진 스키마를 가진 객체 any : 아무 종류 state의 사용1234567891011121314151617181920class MyComponent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; number: 0 &#125; &#125; // 만약 생성자를 만들지 않는다면 Component 클래스의 생성자 메서드를 사용한다. // 생성자를 사용해 추가 작업을 하려면, 메서드 내부에서 부모 클래스인 // Component의 생성자를 호출해야하고, // 이를 위해 super()를 사용 // 컴포넌트를 만들 때 props의 값들을 사용할 것이므로 메서드의 파라미터로 보낸다. render() &#123; return( &lt;div&gt; 안뇽, 내 이름은 &#123;this.props.name&#125; 이얌! &lt;/div&gt; ) &#125;&#125; 굳이 생성자에서 하지 않아도 되긴 한다. 12345class MyComponent extends Component &#123; state = &#123; number: 0 &#125;&#125; setState의 사용1234this.setState(&#123; 수정할 필드명: 값, 수정할 필드명: 값&#125;) ES6의 화살표 함수123456789101112131415161718192021222324252627&gt; function BlackDog() &#123;&gt; this.name = '흰둥';&gt; return &#123;&gt; name: '검둥',&gt; bark: function() &#123;&gt; console.log(this.name + '멍멍');&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; function WhiteDog() &#123;&gt; this.name = '흰둥';&gt; return &#123;&gt; name: '검둥',&gt; bark: () =&gt; &#123;&gt; console.log(this.name + '멍멍');&gt; &#125;&gt; &#125;&gt; &#125;&gt; &gt; const blackDog = new BlackDog();&gt; blackDog.bark();&gt; // 검둥 : 멍멍&gt; const whiteDog = new WhiteDog();&gt; whiteDog.bark();&gt; // 흰둥 : 멍멍&gt; 일반 함수는 자신이 종속된 객체를 this로 가리키나, 화살표 함수는 자신이 종속된 인스턴스를 가리킨다. 12&gt; const test = (value) =&gt; value*3&gt; 따로 {}를 하지 않으면 연산 값을 리턴하겠다는 뜻 메서드의 바인딩컴포넌트의 생성자에서 각 메서드를 this와 바인딩하는 작업이 필요하나, 바벨의 transform-class-properties 문법을 사용해 간단하게 화살표 함수로 구현이 가능 1234567891011121314151617181920212223class EventPractice extends Component &#123; state = &#123; message: '' &#125; handleChange = (e) =&gt; &#123; this.setState(&#123; message: e.target.value &#125;) &#125; handleClick = () =&gt; &#123; console.log(this.state.message); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;이벤트 연습&lt;/h2&gt; &lt;input type=\"text\" name=\"message\" onChange=&#123;this.handleChange&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;확인&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; ​ e.target.name해당 input의 name을 가리키는 이벤트 객체의 값 이를 이용해서 이렇게 핸들링도 가능하다. 12345handleChange = (e) =&gt; &#123; this.setState(&#123; [e.target.name]: e.target.value &#125;)&#125; ​ onKeyPress 핸들링12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react';class EventPractice extends Component &#123; state = &#123; username: '', message: '' &#125; handleChange = (e) =&gt; &#123; this.setState(&#123; [e.target.name]: e.target.value &#125;) &#125; handleClick = () =&gt; &#123; console.log(this.state.username + \":\" + this.state.message); &#125; handleKeyPress = (e) =&gt; &#123; if (e.key === 'Enter') &#123; // 만약 키가 엔터이면 this.handleClick(); &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;이벤트 연습&lt;/h2&gt; &lt;input type=\"text\" name=\"message\" onChange=&#123;this.handleChange&#125; onKeyPress=&#123;this.handleKeyPress&#125;/&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;확인&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default EventPractice;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트 인 액션 PART2 - 렌더링과 생명주기 메서드","slug":"react02-1","date":"2019-02-16T15:20:18.000Z","updated":"2019-02-19T13:44:31.304Z","comments":true,"path":"2019/02/17/react02-1/","link":"","permalink":"http://eunajjing.github.io/2019/02/17/react02-1/","excerpt":"","text":"이 포스트는 리액트 인 액션이라는 책을 보며 혼자 공부한 기록을 남기는데 의미를 두고 있습니다. 책의 요약도 있긴 하지만 대체로 저 개인이 중요하다고 생각하는 포인트들과 이해한 영역에 대해 이야기합니다. 포스트는 언제든 삭제가 될 가능성이 있습니다…. 생명 주기 메서드이벤트 없이도 자동으로 특정 행동을 수행해야 할 경우 사용하는 것. 크게 컴포넌트가 동작을 시작하는 시점 동작 중인 시점 완료되는 시점 을 표기한다. 즉 클래스 기반 리액트 컴포넌트에 추가된 것으로 컴포넌트의 생명주기 내의 특정 시점에 실행되는 메서드 (함수형 컴포넌트는 this.setState 처럼 이 생명 주기 메서드 또한 쓸 수 없다, 부모로부터 데이터를 받아 갱신할 수만 있다.) 렌더링뭔가를 만드는 것, 즉 애플리케이션을 화면에 그려내는 것 리액트는 컴포넌트를 해석해 UI로 변경시킨다. 분류초기화컴포넌트 클래스의 인스턴스가 생성되는 시점 defaultProps 부모 컴포넌트가 속성을 제공하지 않은 경우this.props에 기본적으로 설정되는 값 컴포넌트가 마운트되기 전이어서 this.props를 쓸 수 없을 때 사용 인스턴스가 공유하는 복합 객체를 리턴한다. state : 생성자 내에서 컴포넌트의 초기 상태를 설정하는데 사용 마운팅컴포넌트가 DOM에 삽입되는 시점, 해당 메서드들은 한 번만 호출된다. 부모 컴포넌트의 defaultProps 와 state 설정 자식 컴포넌트의 defaultProps 와 state 설정 부모 컴포넌트의 componentWillMount() 호출, 즉 마운트 되기 전 호출 부모 컴포넌트의 render() 실행 자식 컴포넌트의 componentWillMount() 호출, 즉 마운트 되기 전 호출 자식 컴포넌트의 render() 실행 마운트, DOM에 존재하며 컴포넌트에 연결된 DOM 인스턴스 생성 자식 컴포넌트의 componentDidMount() 실행 자식 컴포넌트의 render() 실행 부모 컴포넌트의 componentDidMount() 실행 부모 컴포넌트의 render() 실행 componentWillMount() 최초의 렌더링이 실행되기 직전에 한 번만 호출된다. 마운트되기 전 상태를 결정하거나 다른 동작을 수행할 때 쓴다. 만약 이 메서드가 아닌 다른 곳에서 상태를 변경하면 다시 랜더링 과정이 실행된다. 잉? componentDidMount() 컴포넌트가 DOM에 삽입될 때 한 번 호출된다. 컴포넌트의 상태, 속성, 참조에 접근할 수 있다. 응답으로 전달받은 데이터를 이용해 컴포넌트 상태를 갱신하는 작업을 주로 수행한다. DOM을 조작하는 서드파티 라이브러리를 호출한다. 갱신컴포넌트 상태나 속성으로 전달된 새 데이터에 의해 갱신되는 시점 마운팅된 부모의 컴포넌트에서 갱신 발생 componentWillReceiveProps(nextProps) 실행 shouldComponentUpdate(nextProps, nextState)가 true라면 (항상 true 리턴) componentWillUpdate(nextProps, nextState) 실행 render() 실행 componentDidUpdate(prevProps, prevState) 실행 false라면 (상태를 항상 불변 객체로 처리하고 render() 메서드 내에서 속성과 상태를 읽기 전용으로만 사용할 경우) render() 를 포함한 메서드들이 실행되지 않는다. componentWillReceiveProps(nextProps) this.state를 이용해 상태를 갱신한 후 갱신 과정에서 render()가 호출되기 전 상태를 전환하기 위한 용도로 활용 기존 속성은 this.props를 통해 접근 this.setState()를 호출해서 렌더링이 추가적으로 실행되지는 않음 shouldComponentUpdate 리액트가 제공하는 메서드들로 충분하지 않은 경우에만 사용하는 게 좋다. 컴포넌트에 새 속성이나 상태가 전달되었을 때, 렌더링이 이루어지기 직전에 호출된다. 렌더링 최초에는 호출되지 않는다. componentWillUpdate(nextProps, nextState) 갱신이 이루어지기 전 준비 절차를 수행할 때 사용 setState()를 사용할 수 없음 갱신이 실행되기 직전에 호출됨 렌더링 최초에는 호출되지 않음 componentDidUpdate(prevProps,prevState) 컴포넌트가 갱신된 후 DOM을 조작할 때 사용 컴포넌트가 갱신된 직후 호출 렌더링 최초에는 호출되지 않음 예제 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Child extends React.Component &#123; static defaultProps = () =&gt; &#123; console.log(&apos;자식 컴포턴트의 defaultProps에서 찍힌 log&apos;); &#125; constructor(props) &#123; super(props); console.log(&apos;자식 컴포넌트의 생성자에서 찍힌 log&apos;); this.state = &#123; name: &apos;Mark&apos; &#125;; &#125; componentWillMount() &#123; console.log(&apos;자식 컴포넌트의 componentWillMount()&apos;); &#125; componentDidMount() &#123; console.log(&apos;자식 컴포넌트의 componentDidMount()&apos;); &#125; componentWillReceiveProps(nextProps) &#123; console.log(&apos;자식 컴포넌트의 componentWillReceiveProps&apos;); console.log(nextProps); &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log(&apos;자식 컴포넌트의 shouldComponentUpdate&apos;); console.log(nextProps); // 부모가 던져준 속성 값 console.log(nextState); // 자신이 가지고 있는 상태 값 return true; &#125; componentWillUpdate(nextProps, nextState) &#123; console.log(&apos;자식 컴포넌트의 componentWillUpdate&apos;); console.log(nextProps); console.log(nextState); &#125; componentDidUpdate(previousProps, previousState) &#123; console.log(&apos;자식 컴포넌트의 componentDidUpdate&apos;); console.log(previousProps); // name: &quot;&quot; 이렇게 찍히는데 왜 그럴까 console.log(previousState); // 자신이 가지고 있는 상태 값 &#125; render() &#123; console.log(&apos;자식 컴포넌트의 render에서 찍힌 log&apos;); return( &lt;div key=&quot;name&quot;&gt;name: &#123;this.props.name&#125; &lt;/div&gt; ); &#125;&#125;;class Parent extends React.Component &#123; static defaultProps = () =&gt; &#123; console.log(&apos;부모 컴포넌트의 defaultProps&apos;); return &#123; true: false &#125;; &#125; constructor(props) &#123; super(props); this.state = &#123; text: &apos;&apos; &#125; this.onInputChange = this.onInputChange.bind(this); &#125; componentWillMount() &#123; console.log(&apos;부모 컴포넌트의 componentWillMount()&apos;); &#125; componentDidMount() &#123; console.log(&apos;부모 컴포넌트의 componentDidMount()&apos;); &#125; onInputChange(e) &#123; this.setState(&#123;text: e.target.value&#125;); &#125; render() &#123; console.log(&apos;부모 컴포넌트에서 rander에서 찍힌 Log&apos;); return [ &lt;h2 key=&quot;h2&quot;&gt;컴포넌트의 라이프사이클을 배우자&lt;/h2&gt;, &lt;input key=&quot;input&quot; value=&#123;this.state.text&#125; onChange=&#123;this.onInputChange&#125;/&gt;, &lt;Child key=&quot;Child&quot; name=&#123;this.state.text&#125;/&gt; ] &#125;&#125;;ReactDOM.render(&lt;Parent/&gt;, document.getElementById(&apos;root&apos;)); 콘솔 언마운팅컴포넌트가 DOM에서 제거되는 시점 componentWillUnmount()로 만들 수 있다. componentDidUnmount 메서드는 존재하지 않는다. 컴포넌트가 일단 제거되면 그 수명은 끝나기 때문에, 작업 수행이 불가하기 때문이다. 에러componentDidCatch(err, errorInfo)를 이용해서 처리가 가능하다. 그러나 책 내 예제를 아무리 살펴봐도 에러가 나는 터라 실행을 해보진 않았다. componentDidCatch(error, errorInfo) 에러가 발생한 컴포넌트 및 트리 구조 상의 하위 컴포넌트를 언마운트한다 생성자, 생명주기 메서드, render()에서 에러가 발생한 경우 호출된다","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"리액트 인 액션 PART1","slug":"react01","date":"2019-02-11T07:06:18.000Z","updated":"2019-02-19T13:44:24.990Z","comments":true,"path":"2019/02/11/react01/","link":"","permalink":"http://eunajjing.github.io/2019/02/11/react01/","excerpt":"","text":"이 포스트는 리액트 인 액션이라는 책을 보며 혼자 공부한 기록을 남기는데 의미를 두고 있습니다. 책의 요약도 있긴 하지만 대체로 저 개인이 중요하다고 생각하는 포인트들과 이해한 영역에 대해 이야기합니다. 포스트는 언제든 삭제가 될 가능성이 있습니다…. React의 가상 DOM일단 DOM이란 뭘까 Java Script program이 다양한 종류의 문서(HTML, XML 등)을 다루기 위한 프로그래밍 인터페이스 XML 문서의 계층 구조를 반영한 트리 구조 왜 가상 DOM이 필요한가 웹 페이지의 요소를 갱신하거나 조회할 때 사용하는 메서드나 속성이를테면 getElementById, innerHTML 등은 호스트 환경(ex. 브라우저)가 제공하고, Java Script는 이들을 이용해 DOM 조작 대형 애플리케이션의 경우 요소 갱신이 복잡해짐 가상 DOM의 동작 방법 리액트가 메모리에 가상 DOM을 생성하고 관리 리액트 DOM과 같은 랜더러는 가상 DOM 변경 사항을 브라우저 DOM에 반영 랜더러 : 코드의 결과를 브라우저에 렌더링하는 기능을 제공하는 라이브러리 React의 가상 DOM 브라우저에 존재하는 문서 객체 모델(DOM)을 흉내 내거나 반영하는 데이터 구조 또는 데이터 구조의 모음 가상 DOM은 애플리케이션 코드와 실제 브라우저 DOM 사이에 위치하는 중간 계층의 역할을 담당 React의 컴포넌트특징 캡슐화 재사용 및 재구성 가능 반드시 한 번은 재사용할 컴포넌트를 만들어야 한다 (뭔 소리죠) 그러니까 간단히 설명하면 기능을 단위 별로 캡슐화하는 리액트의 기본 단위 Java Script 함수 또는 클래스로, 속성들을 입력으로 받아들임 내부적으로 각자의 상태를 관리 특정 형식의 컴포넌트의 대해 생명주기 메서드 제공 웹 API(Application Programming Interface) 소프트웨어를 개발하기 위한 루틴과 프로토콜의 집합 프로그램이나 플랫폼과 상호작용을 하기 위해 정해진 것을 외부에 노출하는 방법 예제를 보자12// index.jsconst node = document.getElementById(&quot;root&quot;); 요소에 대한 참조를 해당 변수에 저장한다. 이제부터 개발할 리액트 앱은 이 DOM 내에 렌더링된다. 12&lt;!-- index.html --&gt;&lt;div id-\"root\"&gt;&lt;/div&gt; 여기까지가 리액트 라이브러리 다운로드, root라는 id를 지닌 DOM 요소를 찾는 것 여기서 컴포넌트를 생성하려면 ReactDOM.render 메서드 실행 신텍스는 아래와 같다. 12345ReactDOM.render( ReactElement element, DOMElement container, [function calllback]) ReactDOM 은 ReactElement 타입의 요소와 DOM 요소를 필요로 한다. ReactElement 요소 경량 상태 없음 내부 상태 변경 불가 ReactComponentElement React 컴포넌트를 표현하는 함수나 클래스에 대한 참조를 의미 ReactDOMElement DOM 요소를 가상으로 표현한 객체 React.createElementReactElement 를 생성할 때 쓰는 메서드 신텍스 1234567891011React.createElement( String / ReactClass type, // html 요소의 태그 이름을 문자열로 전달하거나 리액트 클래스 전달 // 즉 리액트가 생성할 타입 지정 &#123;props:value, ...&#125;, // html 요소에 지정될 특성(attributes) 지정하거나 // 컴포넌트 클래스 인스턴스에 사용할 속성 지정 [Children], ... // 여기에 또 다른 자식 컴포넌트를 넣을 수 있다. // 컴포넌트는 중첩된다.) React의 상태상태 : 어느 특정한 시점의 어떤 것에 대한 정보 this.state : 변경 가능(mutable) 상태와 this.props : 변경 불가능한(immutable) 상태 로 나뉜다. 리액트에서 쓰이는 컴포넌트 는 React.Component 클래스를 확장한 자바스크립트 클래스로 정의하며 가변(state)/불변(props) 상태를 모두 관리할 수 있다. 반면 함수를 이용해 생성한 컴포넌트(immutable)는 불변 상태(props)만을 관리할 수 있다. 상태가 있는(stateful) 컴포넌트React Class생성방법 1234567891011class ReactClassName extends Component &#123; // React.Component 추상 클래스를 상속하는 자바스크립트 클래스 선언 render() &#123;&#125; // 리액트 요소를 리턴하는 render 메서드 정의 // ver 16부터는 배열을 이용해 여러 개의 리액트 요소 리턴도 가능 // 해당 메서드는 내부 데이터(컴포넌트에 저장된 상태)와 // 컴포넌트 메서드 // React.Component 추상 클래스 기반 클래스로부터 상속된 추가 메서드에도 접근 가능 // React는 이런 컴포넌트에 대한 보조 인스턴스를 생성하기 때문에 저장된 상태는 컴포넌트 전체가 활용 가능&#125; 클래스를 이용해 컴포넌트를 생성하면 props 객체에 접근 가능 props 객체 컴포넌트에 전달할 수 있는 데이터 컴포넌트 생성 시점에 지정도 가능 컴포넌트 내부에서 수정해서는 안된다. thisJava Script의 키워드로 컴포넌트의 인스턴스를 가리킨다. 기본 상태의 설정123456789101112131415161718192021222324class CreateComment extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; content: &quot;&quot;, user: &quot;&quot; &#125;; // 생성자 안에서 super 함수를 호출해 클래스 인스턴스 state 속성에 기본 상태 객체를 대입 &#125; render() &#123; return React.createElement( &quot;form&quot;, &#123; className: &quot;createComment&quot; &#125;, React.createElement(&quot;input&quot;, &#123; type: &quot;text&quot;, placeholder: &quot;Your name&quot;, value: this.state.user // 이렇게 상태에 접근 &#125;) ); &#125;&#125; this.state의 속성은 직접 덮어쓸 수 없다 this.setState 메서드를 호출해야 한다. 123setState(function(preState, props) -&gt; nextState, callback) -&gt; void 갱신 함수를 매개변수로 전달받아 다시 지원 인스턴스를 갱신한 후, 새로운 값을 DOM에 적용한다는 특징이 있다. 리액트가 상태를 일괄적으로 변경하기에, setState 메서드를 호출한다고 해서 그 결과가 곧바로 적용되지 않는다. 리액트는 사용자 입력에 대한 응답으로 갱신이 이루어진다. React의 이벤트가상 DOM을 구현하는 것의 일부로 모의(synthetic) 이벤트 시스템을 구현한다. 브라우저에서 이벤트가 발생하면, 리액트 애플리케이션 이벤트로 변환한다. 자바스크립트가 이벤트를 처리하는 방법대로, 브라우저에서 발생하는 이벤트에 반응할 이벤트 핸들러를 설정하면 된다. 리액트의 이벤트핸들러는 리액트 요소나 컴포넌트 자체에 설정된다. 때문에 이렇게 설정된 이벤트가 전달하는 데이터를 이용해 컴포넌트 상태를 갱신할 수도 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176class Post extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return React.createElement( &quot;div&quot;, &#123; className: &quot;post&quot; &#125;, React.createElement( &quot;h2&quot;, &#123; className: &quot;postAuthor&quot;, id: this.props.id &#125;, this.props.user, React.createElement( &quot;span&quot;, &#123; className: &quot;postBody&quot; &#125;, this.props.content ), this.props.children ) ); &#125;&#125;class Comment extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return React.createElement( &quot;div&quot;, &#123; className: &quot;comment&quot; &#125;, React.createElement( &quot;h2&quot;, &#123; className: &quot;commentAuthor&quot; &#125;, this.props.user, React.createElement( &quot;span&quot;, &#123; className: &quot;commentContent&quot; &#125;, this.props.content ) ) ); &#125;&#125;class CreateComment extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; content: &quot;&quot;, user: &quot;&quot; &#125;; this.handleUserChange = this.handleUserChange.bind(this); this.handleTextChange = this.handleTextChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); // 클래스로 생성한 컴포넌트는 메서드를 자동으로 바인딩하지 않는다. // 때문에 생성자 내에서 이 메서드들을 직접 바인딩해줘야 한다. // 이전 버전의 리액트의 경우 메서드가 자동 바인딩되었으나, 자바스크립트 클래스로 변환되며 직접 해줘야 함 &#125; handleUserChange(event) &#123; const val = event.target.value; // val에는 input에 사용자가 입력한 텍스트가 들어온다. this.setState(() =&gt; (&#123; user: val &#125;)); &#125; handleTextChange(event) &#123; const val = event.target.value; this.setState(&#123; content: val &#125;); &#125; handleSubmit(event) &#123; event.preventDefault(); this.props.onCommentSubmit(&#123; user: this.state.user.trim(), content: this.state.content.trim() &#125;); this.setState(() =&gt; (&#123; user: &quot;&quot;, content: &quot;&quot; &#125;)); &#125; render() &#123; return React.createElement( &quot;form&quot;, &#123; className: &quot;createComment&quot;, onSubmit: this.handleSubmit &#125;, React.createElement(&quot;input&quot;, &#123; type: &quot;text&quot;, placeholder: &quot;Your name&quot;, value: this.state.user, onChange: this.handleUserChange &#125;), React.createElement(&quot;input&quot;, &#123; type: &quot;text&quot;, placeholder: &quot;Thoughts?&quot;, value: this.state.content, onChange: this.handleTextChange &#125;), React.createElement(&quot;input&quot;, &#123; type: &quot;submit&quot;, value: &quot;Post&quot; &#125;) ); &#125;&#125;class CommentBox extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; comments: this.props.comments // 부모에게 comments를 보낸다 &#125;; this.handleCommentSubmit = this.handleCommentSubmit.bind(this); &#125; handleCommentSubmit(comment) &#123; // 제일 큰 특징은 복사본을 생성해서 대입한다는 것 const comments = this.state.comments; comment.id = Date.now(); const newComments = comments.concat([comment]); this.setState(&#123; comments: newComments &#125;); &#125; render() &#123; return React.createElement( &quot;div&quot;, &#123; className: &quot;commentBox&quot; &#125;, React.createElement(Post, &#123; id: this.props.post.id, content: this.props.post.content, user: this.props.post.user &#125;), this.state.comments.map(function(comment) &#123; return React.createElement(Comment, &#123; key: comment.id, id: comment.id, content: comment.content, user: comment.user &#125;); // map 메서드를 이용해 각 댓글에 대응하는 리액트 요소를 생성해 리턴한다. &#125;), React.createElement(CreateComment, &#123; onCommentSubmit: this.handleCommentSubmit // CreateComment에게 handleCommentSubmit 메서드 전달 &#125;) ); &#125;&#125;render( React.createElement(CommentBox, &#123; comments: data.comments, post: data.post &#125;), node); PropTypes 속성의 유효성 검사를 할 수 있는 것 prop-types 패키지 설치 후 사용이 가능 React.Component 클래스에 popTypes 속성 추가 필요 책 내에서는 propTypes의 커스터마이징까지는 다루고 있지 않아 외부 레퍼런스 참조 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from &quot;react&quot;;import &#123; render &#125; from &quot;react-dom&quot;;// React와 React-dom 라이브러리를 가져온다.import PropTypes from &quot;prop-types&quot;;// PropTypes 패키지 설치const node = document.getElementById(&quot;root&quot;);class Post extends Component &#123; render() &#123; return React.createElement( ... ); &#125;&#125;Post.propTypes = &#123; // Post라는 리액트 클래스의 props에 대한 유효성 검사 user: PropTypes.string.isRequired, // user라는 props에는 String 자료형만 들어갈 수 있다. id: PropTypes.number.isRequired // id라는 props에는 number 자료형만 들어갈 수 있다.&#125;;// 이런 형태는 너무 기본적인 기능이기에 잘 사용되지 않는다고 함!render(App, node); 이렇게도 쓸 수 있다고 한다. 12345678910Post.propTypes = &#123; config: PropTypes.shape(&#123; series: PropTypes.array.isRequired, xAxis: PropTypes.shape(&#123; categories: PropTypes.array, &#125;), &#125;).isRequired, chartType: PropTypes.arrayOf(PropTypes.string).isRequired, currentChartType: PropTypes.oneOf([&apos;view&apos;, &apos;conversion&apos;]),&#125;; 그런데 아직 외부 레퍼런스의 모든 내용을 이해한 건 아니라서…. 점차 공부하면서 덧붙여볼 예정 JSX반드시 바벨과 같은 JSX 전처리기 프로그램이 필요하다. 전처리기 프로그램 : JSX 코드를 자바스크립트 코드로 바꾸는 것 특징 특성 표현식 &lt;User a = &quot;this.props.b&quot;/&gt;가 아니라, &lt;User a = {this.props.b}/&gt; 불리언 특성 &lt;Planactive/&gt;, &lt;Input checked/&gt; 의 경우 리액트에서 true 값이다. 만약 false를 주고 싶다면 attribute={false} 같은 특성 표현식이 필요하다. 중첩 표현식 요소 내 표현식의 값을 추가할 때도 &lt;p&gt;{this.props.content}&lt;/p&gt;로 써주어야 한다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"React","slug":"개발공부/React","permalink":"http://eunajjing.github.io/categories/개발공부/React/"}],"tags":[]},{"title":"maria DB if SQL","slug":"2019-01-29-maria-DB-if-SQL","date":"2019-01-29T08:55:18.000Z","updated":"2019-01-29T14:38:38.206Z","comments":true,"path":"2019/01/29/2019-01-29-maria-DB-if-SQL/","link":"","permalink":"http://eunajjing.github.io/2019/01/29/2019-01-29-maria-DB-if-SQL/","excerpt":"","text":"maria DB IF문mysql의 문법처럼, maria DB 또한 if문을 쓸 수 있다. 그런데 내가 궁금한 건 select절에도 if문을 쓸 수 있느냐 여부였다. 즉 이렇게! 12select .... if (칼럼명 = '~', 참일 때 실행, 거짓일 때 실행) \"별칭\" 백문이 불여일실행이라고, 해당 쿼리를 실행해보았다. 123456select r.rno, r.isFrom, r.targetTypeCode, r.targetCode, r.reasonCode, r.rContent, r.processCode, if (r.targetTypeCode='BOARD', (select mid from board where bno=r.targetCode), (select id from comment where cno=r.targetCode)) \"isTo\", b.title from report r join board b on r.targetCode=b.bno; 처음에는 괄호를 안 써서 에러가 났다. 문법 자체가 잘못된 건지 모르겠어서 강사 님께 문의를 드렸는데, 논리에 맞지 않는다고 하셨다. 그런데 웃긴 게 내가 어쩌다가 실행한 sql이 되는 걸 확인을 했고 (문제는 그 저장된 sql이 워크밴치가 응답없음이 뜨면서 날아가서…) 계속 미련을 못 버리다가 괄호를 잘 치니까 되었다!!!! 근데 위의 쿼리는 내가 원하는 값을 가져오질 못했다ㅠㅠㅠㅠ 원하는 값을 가져오려면 프로시저를 써야 했다. 하여튼 문법적으로는 되는 쿼리다!","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"serialize 사용 시 controller 어노테이션","slug":"2019-01-29-serialize-사용-시-controller-어노테이션","date":"2019-01-29T08:37:18.000Z","updated":"2019-01-29T14:38:38.207Z","comments":true,"path":"2019/01/29/2019-01-29-serialize-사용-시-controller-어노테이션/","link":"","permalink":"http://eunajjing.github.io/2019/01/29/2019-01-29-serialize-사용-시-controller-어노테이션/","excerpt":"","text":"그래서 직렬화해서 어떻게 받나요…serialize()에 대해서는 수업을 받은 적이 있고, 그 수업 내용은 블로그에도 있다. 그런데 아무리 고민해도 controller에서 어떻게 받아야 하는지 잘 모르겠더라. 그래서 포풍 검색을 했지만 잘 나오지 않았고… 계속 삽질하다 알아낸 것 기록 @ModelAttribute 어노테이션 기입 후 자료형을 vo에 맞춰서 받아준다!","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"트리거 내 루프 제어","slug":"2019-01-29-트리거-내-루프-제어","date":"2019-01-29T08:37:18.000Z","updated":"2019-01-29T14:38:38.207Z","comments":true,"path":"2019/01/29/2019-01-29-트리거-내-루프-제어/","link":"","permalink":"http://eunajjing.github.io/2019/01/29/2019-01-29-트리거-내-루프-제어/","excerpt":"","text":"트리거 내 루프123456789101112131415161718192021222324create trigger suggestionAlarm after update on suggestion FOR EACH ROWbeginDECLARE done INT DEFAULT FALSE;DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;declare _id cursor for select id from likelist where bno=new.bno;declare tempid VARCHAR(40);if new.statusCode = 'S02' then insert into alarm(alarmcode, bno, isFrom) values('A02-1', new.bno, new.id); open _id; ins_loop: LOOP fetch _id into tempid; if done then leave ins_loop; end if; insert into alarm(alarmcode, bno, isFrom) values('A03', new.bno, tempid); end loop; close _id; else insert into alarm(alarmcode, bno, isFrom) values('A02-2', new.bno, new.id);end if;end; 사실 루프문은 처음 트리거 생성 때 트러블슈팅으로 넣어놨던 것이라 고생은 별로 안했는데, 하다보니 알게 된 것들을 기록 커서 핸들러가 정확한 위치에 정의되지 않으면 에러가 발생에러 내용은 다음과 같다.Variable or condition declaration after cursor or handler declaration 루프문 제어의 경우 다양한 방식이 있는데, 나는 커서를 이용했기 때문에 위의 sql를 치는 것이 좋은 것 같다만약 커서를 사용하지 않았더라면 123456789101112131415161718192021222324create trigger suggestionAlarm after update on suggestion FOR EACH ROWbegindeclare _id cursor for select id from likelist where bno=new.bno;declare tempid VARCHAR(40);declare x int ;if new.statusCode = 'S02' then insert into alarm(alarmcode, bno, isFrom) values('A02-1', new.bno, new.id); if((select count(*) from likelist where bno=new.bno) &gt; 0) then set x = 1; open _id; while x &lt; (select count(*) from likelist where bno=new.bno) do fetch _id into tempid; insert into alarm(alarmcode, bno, isFrom) values('A03', new.bno, tempid); set x = x+1; end while; close _id; end if;else insert into alarm(alarmcode, bno, isFrom) values('A02-2', new.bno, new.id);end; 이렇게 해도 됐겠지만… 위 소스를 그대로 치면 1과 같은 에러가 난다. 커서 핸들러가 없다고.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"mybatis 프로시저 매핑 문제 트러블슈팅","slug":"2019-01-29-mybatis-프로시저","date":"2019-01-29T07:20:18.000Z","updated":"2019-01-29T14:38:38.207Z","comments":true,"path":"2019/01/29/2019-01-29-mybatis-프로시저/","link":"","permalink":"http://eunajjing.github.io/2019/01/29/2019-01-29-mybatis-프로시저/","excerpt":"","text":"mybatis - 프로시저 매핑만든 프로시저 123456789101112131415161718192021222324252627DELIMITER //create procedure `selectOneBoard`(IN bno int(11))begin declare result int(4); set result = (select count(*) from suggestion where bno=bno and statusCode='S02'); if (result &gt; 0) then select bno, b.mid \"mid\", b.title \"title\", b.bContent \"bContent\", DATE_FORMAT(b.writeDate,'%Y-%m-%d') \"WriteDate\", b.readCount \"readCount\", b.thumbNail \"thumbNail\", b.categoryCode \"categoryCode\", b.bDelete \"bDelete\" s.link \"link\" from board b join suggestion s using(bno) where b.bDelete='0'; ELSE SELECT bno, mid, title, bContent, DATE_FORMAT(writeDate,'%Y-%m-%d') WriteDate, readCount, thumbNail, categoryCode, bDelete FROM board WHERE bDelete='0' and bno = bno; end if;end;//DELIMITER ; call selectOneBoard(~)를 하면 DB 단에서는 정말 잘 실행되는데, 결과 값인 vo를 가지고 못하는 문제가 발생했다. 찾아보니 이런 문서를 발견했다. 즉 resultMap을 이용해서 받거나, 파라미터로 보내는 vo로 리턴을 받아야 한다는 것! :&lt;… 너모 어렵다… 나는 resultMap으로 받아냈다!","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"complainZero 프로젝트 회고","slug":"2019-01-29-complainZero-프로젝트-회고","date":"2019-01-29T06:58:18.000Z","updated":"2019-01-29T14:38:38.206Z","comments":true,"path":"2019/01/29/2019-01-29-complainZero-프로젝트-회고/","link":"","permalink":"http://eunajjing.github.io/2019/01/29/2019-01-29-complainZero-프로젝트-회고/","excerpt":"","text":"뉴딜 과정이 끝났다ComplainZero 비교적 짧은 시간 내에 구현해야했던 는 많은 기능을 배제하고 할 수 있는 것에만 집중하기로 팀원들 내 합의 후 진행한 프로젝트였다. 원래는 게시판 겸 펀딩 사이트를 구현하려고 했는데 몸집이 너무 커지기도 커져서… 결국 중계 사이트를 만들었다. 유스케이스는 그리지 않아 권한 별 설정을 보여주기 위해 만든 PT… 프로젝트 전반에 대한 회고시간 압박에 쫓겨 개인적으로 배우는 프로젝트였다기보단 빨리 빨리 구현에 중점을 둔 프로젝트였다. 코드를 타이핑하는데에 급급해 문서 작성을 하지 않았고, 이 때문에 불필요한 작업들을 여러 번 하는 경우도 있었다. 내가 한 줄의 코드를 짜는 것보다 타인과 소통하며 협업하는 게 더 중요하다는 걸 배웠지만…. 소통이 안되는 건 내 문제인가….. 하하… 프로젝트 구현구현에 있어 제일 힘들었던 것은 프로시저와 트리거 내 루프문 제어였다. 포스팅을 통해 트러블 슈팅을 기록하겠지만, 왜 안되는지 알 수 없는… 그런 거였다. 레퍼런스가 많기에 구현에 그다지 오래 걸리지 않으리라 생각했는데 데이터베이스마다 조금씩 문법 차이가 있어 레퍼런스 예제 소스가 전혀 적용이 안됐다ㅠㅠㅠ 사용한 maria DB는 insert all과 같이 mysql에서 제공하는 다중 데이터 insert 문을 제공해주지 않았고, 트리거 내에서도 사용이 힘들었다. 이에 모든 걸 DB에서 처리해야겠다는 계획을 변경해 서비스 단에서 트랜젝션을 이용해 제어를 시도했다. 프로시저 또한 힘들었다. 이것도 정말… 트러블 슈팅 꼭 기록할 것. 프로젝트 내 게시물 상세보기는 조건에 따라 join테이블이 달라지는데, 조건을 사용해야 했기에 결과적으로 DB 처리를 원하면 프로시저를 사용해야한다는 것을 알았다. 트랜젝션을 생성해 DB GUI 툴에서 실행했을 때 정상적인 값을 가지고 오는 것을 확인했건만 호출 결과와 mybatis의 연동이 자동으로 되지 않아 원인을 찾는데 많은 시간이 소비되었다. 아쉬운 점 전반 회고 맥락과 비슷하게, 기능적으로는 배우는 게 많이 없었던 프로젝트였다. 이미 해보거나 잘하는 기능을 맡아 구현했다. 욕심 부리지 않기 위해 프로젝트 규모를 작게 잡아 되레 인원에 비해 너무 소소한 프로젝트였다고 생각한다. 사실… 우리가 4명이었지만 거의 3명인 조였고… 하아… 만약 기회가 된다면 펀딩 사이트처럼 연계 알림 후 결제 시스템을 구현해보거나, 카카오나 네이버 아이디를 이용한 회원가입을 구현해도 재밌었으리라 생각한다. 처음에 하지 않은 문서 작업이 뒤에서 크게 발목을 잡으리라 생각치 못한 프로젝트였다. 폴더 구조를 짜두고 시작한 것이 아닌 터라, 나중에 시큐리티 패턴식을 적용하거나 타일즈를 구현할 적마다 폴더 구조를 다시 맞춰야 하는 번거로움이 발생했고, 후에 적용하면 할수록 팀원 간 혼동도 잦았다. 또한 트러블슈팅을 하지 않아 팀원 내 똑같은 에러가 발생해도 팀원 내부에서 도움을 주지 못하고, 문제가 발생한 회원이 다시 레퍼런스를 찾아봐야 하는 등의 비효율적인 측면도 두드러진 프로젝트였다. 특별한 api를 적용하는 경험은 하지 못했지만 문서 작업과 협업에 대해 생각해보는 계기였다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"스프링 시큐리티 3","slug":"spring_security_check","date":"2019-01-20T14:48:18.000Z","updated":"2019-01-29T14:38:59.452Z","comments":true,"path":"2019/01/20/spring_security_check/","link":"","permalink":"http://eunajjing.github.io/2019/01/20/spring_security_check/","excerpt":"","text":"j_spring_security_check로그인 폼 이번 프로젝트는 진행하면서 왜이리 화가 나는지 모르겠다… 아니 프로젝트 할 때마다 늘 화가 났던가. 언제쯤 분노에 익숙해질지 모르겠다.","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"몽고DB","slug":"mongo DB","date":"2019-01-16T00:39:18.000Z","updated":"2019-01-19T05:11:56.181Z","comments":true,"path":"2019/01/16/mongo DB/","link":"","permalink":"http://eunajjing.github.io/2019/01/16/mongo DB/","excerpt":"","text":"몽고 DB세팅 1mongod.exe --dbpath data_폴더_경로 몽고DB의 포트번호는 : 27017 GUI 툴 GUI 세팅 노드에서 사용하기 일단 npm install mongodb로 드라이버를 설치한다 데이터 베이스를 얻는다 123var MongoClient = require('mongodb').MongoClient;MongoClient.connect(url,options,callback); 데이터베이스와 연결 1234567var MongoClient = require('mongodb').MongoClient var url = 'mongodb://localhost:21017/데이터베이스이름'; var db; MongoClient.connect(url,function(err,database)&#123; &#125;); 컬렉션 다루기 12345678910db.COLLECTION.insertdb.COLLECTION.find ex) 노드에서 var movies = db.collection('movies'); movies.insert();ex) gui에서 db.컬렉션명.insert(&#123;name:'euna'&#125;) db.getCollection('컬렉션명').find(&#123;&#125;) 튜플, 로우 추가(insert)123insert(document,options,callback)insertMany(document,options,callback)insertOne(document,options,callback) insert 함수 결과 result : MongoDB의 insert 결과 ops : _id를 포함한 새로 추가된 Document(row) 정보 connection : insert 함수가 동작한 연결 정보 123456789101112function addMovie(req,res)&#123; var movies =db.collection('movies'); movies.insert(&#123;title:'인스',director:'크리스' ,year:2018&#125;, function(err,result)&#123; var result = &#123; result : 'success', newId : result.insertedIds[0] &#125;; res.json(result); &#125; );&#125; insertOne 12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); var obj = &#123;title:\"new\" , day:\"everyday\" , importance : \"high\"&#125;; dbopen.collection(\"customers\").insertOne(obj,function(err,res)&#123; if(err) throw err; console.log(\"one data insert\"); db.close(); &#125;);&#125;); insertMany 12345678910111213141516171819var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); var obj = [ &#123;title:\"new\" , day:\"everyday\" , importance : \"high\"&#125;, &#123;title:\"new\" , day:\"everyday\" , importance : \"high\"&#125;, &#123;title:\"new\" , day:\"everyday\" , importance : \"high\"&#125;, &#123;title:\"new\" , day:\"everyday\" , importance : \"high\"&#125;, ]; dbopen.collection(\"customers\").insertMany(obj,function(err,res)&#123; if(err) throw err; console.log(\"multi data insert\" + res.insertedCount); // 몇 건이 들어갔는지 insertedCount로 나온다 db.close(); &#125;);&#125;); data 추가콜백 기반123456789101112MongoClient.connect(url,function(err,db)&#123; var movies = db.collection('movies'); movies.insert( &#123;title:'인스',director:'크리스' ,year:2018&#125;, function(err,results)&#123; //if(err) ... console.log(results); db.close(); &#125; );&#125;); 프로미스 기반123456789MongoClient.connect(url,function(err,db)&#123; var movies = db.collection('movies'); movies.insert(&#123;title:'인스',director:'크리스' ,year:2018&#125;).then(function(result)&#123; console.log(result); &#125;,function(err)&#123; console.log(err); &#125;);&#125;); selectDocument find() &gt;&gt; select * , select * ...where id= find(query) -&gt; Cursor (data 집합) each , forEach 결과 도큐먼트를 순회 123456var cursor = colletion.find(...); cursor.forEach(function(doc)&#123; &#125;,function(err)&#123; &#125;); toArray() 도큐먼트의 배열 반환 1234567891011121314MongoClient.connect(url,function(err.db)&#123; //컬렉션 얻기 var movies = db.collection('movies'); //2000 년이후 &gt; 2000 movies.find(&#123;year:&#123;$gt:2000&#125;&#125;).toArray(function(err,docs)&#123; //&#123;year:&#123;$gt:2000&#125;&#125; : year가 2000년 이후인 조건 //docs 배열 객체 for(var i = 0 ; i &lt; docs.length ; i++)&#123; var doc = doc[i]; console.log(doc['title'] , doc['director']); &#125; &#125; &#125;); findOne(query,options,callback) 이 경우 결과 값이 하나라고 생각하기에 순회를 돌지 않는다 맨 처음 발견되는 하나의 값만이 리턴된다 firstOne 상위에 있는 한 건의 데이터만 조회 123456789101112var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); dbopen.collection(\"customers\").firstOne(&#123;&#125;,function(err,result)&#123; if(err) throw err; console.log(result); //또는 result.title 식으로 원하는 column 데이터만 출력 가능 db.close(); &#125;); &#125;); 정규표현식을 이용한 조건 조회 123456789101112131415var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\"; MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); var query = &#123;title : /^e/&#125;; dbopen.collection(\"customers\").find(query).toArray(function(err,result)&#123; if(err) throw err; console.log(result); db.close(); &#125;); &#125;); // e로 시작하는 .... title 이 e로 시작하는 데이터 sort123456789101112131415var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var mysort = &#123; name: 1 &#125;; // 이 경우 name 오름차순 // -1이 내림차순 dbo.collection(\"customers\").find().sort(mysort).toArray(function(err, result) &#123; if (err) throw err; console.log(result); db.close(); &#125;);&#125;); 1234567891011121314var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); var query = &#123;title : 1&#125;; //title 기준 오름 차순 정렬하기 &gt;&gt; &#123;title : -1&#125; 내림차순 정렬 dbopen.collection(\"customers\").find().sort(sort).toArray(function(err,result)&#123; if(err) throw err; console.log(result); db.close(); &#125;);&#125;); delete12345678910111213var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); var myquery = &#123; address: 'Mountain 21' &#125;; dbo.collection(\"customers\").deleteOne(myquery, function(err, obj) &#123; if (err) throw err; console.log(\"1 document deleted\"); db.close(); &#125;);&#125;); update12345678910111213141516var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); var query = &#123;title : \"supeman\"&#125;; //검색 var newvalues = &#123;$set : &#123;day:\"update week\"&#125;&#125; //변경 dbopen.collection(\"dbopen\").updateOne(query,newvalues,function(err,result)&#123; if(err) throw err; console.log(result); db.close(); &#125;);&#125;); 123456789101112131415var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); var query = &#123;title :/^e/&#125;; //검색 var newvalues = &#123;$set : &#123;day:\"update week\"&#125;&#125; //변경 dbopen.collection(\"dbopen\").updateOne(query,newvalues,function(err,result)&#123; if(err) throw err; console.log(result); db.close(); &#125;);&#125;); limit123456789101112131415var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); var query = &#123;title : \"supeman\"&#125;; //검색 var newvalues = &#123;$set : &#123;day:\"update week\"&#125;&#125; //변경 dbopen.collection(\"customers\").find().limit(3).toArray(function(err,result)&#123; if(err) throw err; console.log(result); db.close(); &#125;);&#125;); join($lookup을 통한 left outer join) 데이터 예시 12345678910//orders[ &#123; _id: 1, product_id: 154, status: 1 &#125;]// products[ &#123; _id: 154, name: 'Chocolate Heaven' &#125;, &#123; _id: 155, name: 'Tasty Lemons' &#125;, &#123; _id: 156, name: 'Vanilla Dreams' &#125;] 실행 123456789101112131415161718192021var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://127.0.0.1:27017/\";MongoClient.connect(url, function(err, db) &#123; if (err) throw err; var dbo = db.db(\"mydb\"); dbo.collection('orders').aggregate([ &#123; $lookup: &#123; from: 'products', localField: 'product_id', foreignField: '_id', as: 'orderdetails' &#125; &#125; ]).toArray(function(err, res) &#123; if (err) throw err; console.log(JSON.stringify(res)); db.close(); &#125;);&#125;); 결과 12345[ &#123; \"_id\": 1, \"product_id\": 154, \"status\": 1, \"orderdetails\": [ &#123; \"_id\": 154, \"name\": \"Chocolate Heaven\" &#125; ] &#125;] drop1234567891011121314var MongoClient = require('mongodb').MongoClient;var url = \"mongodb://localhost:27017/\";MongoClient.connect(url, function(err,db)&#123; if(err) throw err; var dbopen = db.db(\"mymongodb\"); dbopen.collection(\"customers\").drop(function(err,delok)&#123; // dbopen.dropCollection(\"customers\",function()&#123;&#125;) if(err) throw err; if(delok) console.log(\"collection deleted\"); db.close(); &#125;);&#125;); MongoDb Query 특성 MongoDB에서 모든 쿼리는 단일 컬렉션에서 사용된다. 사용자는 limit, skips 및 sort order를 사용하여 쿼리를 수정할 수 있다. sort()가 설정되지 않으면 쿼리에서 반환된 다큐먼트 순서는 정의되지 않는다. 기존의 다큐먼트를 update하는 동작은 Query가 갱신하려는 다큐먼트를 선택하는 것과 동일한 쿼리 문법을 사용한다. $match 파이프라인 작업은 집계 파이프라인에서 MongoDB 쿼리에 접근한다 ProjectionMongoDB에서 쿼리는 기본적으로 매칭된 모든 다큐먼트 내부의 필드를 반환합니다. 따라서 MongoDB가 애플리케이션으로 전송하는 데이터의 양을 줄이기 위해 쿼리에 프로젝션을 추가하여 사용할 수 있습니다. field : 1 //출력 필드 지정 field : 0// 출력 필드 제외 12345db.getCollection('student').find(&#123;student_:id&#123;$gt:10&#125;&#125;, &#123;\"homework\":0, \"score\":0&#125;);// homework와 score 필드 제외됨// 1을 주면은 1을 쓴 필드만 나오므로 주의// _id 필드는 무조건 나온다(1을 주지 않더라도 디폴드 값임, 없애려면 명시적으로 0을 준다) 즉 제한할 수 있다. 특성 기본적으로 _id 필드는 결과에 포함된다. 결과 셋에서 _id 필드를 제거하려면 프로젝션 다큐먼트에서 _id를 0으로 설정해야 한다. 몽고 DB는 배열이 포함된 필드에서 $elemMatch, $slice, $와 같은 프로젝션 연산자를 제공한다. ex) 결과 셋에서 1개 필드 추출하기db.grades.find( {&quot;student_id&quot; : {$lt : 42} }, {&quot;homework&quot; : 0}) 2개 필드와 _id 필드를 추출하기db.grades.find( {&quot;student_id&quot; : {$lt : 42} }, {&quot;type&quot; : 1, &quot;score&quot; : 1 }) _id 필드를 제외하고 2개 필드 추출하기db.grades.find( {&quot;student_id&quot; : {$lt : 42} }, {&quot;_id&quot; : 0, &quot;type&quot; : 1, &quot;score&quot; : 1 }) 도큐먼트 개수 가져오기1db.collection.count(query , options, callback);","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"면접 준비 - 자바","slug":"2019-01-15-java","date":"2019-01-15T10:48:18.000Z","updated":"2019-01-15T12:43:53.183Z","comments":true,"path":"2019/01/15/2019-01-15-java/","link":"","permalink":"http://eunajjing.github.io/2019/01/15/2019-01-15-java/","excerpt":"","text":"자바JAVA의 좋은점 객체지향형 프로그래밍 언어 플랫폼에 독립적 라이브러리 지향적 보안성 등 객체지향 언어의 장점 코드의 재사용성 코드의 유지보수성 보안성 등 객체 지향 3요소 캡슐화프로그램 내에서 같은 기능을 목적으로 작성된 코드를 모아서 다른 곳(클래스)에서 안보이게 숨기는 것 클래스에 정의된 속성(Attribute)는 숨기고(Private), 객체가 수행할 기능(Function)은 공개(Public)하는 것을 의미 다형성 Overriding Overloading 상속 JAVA의 데이터 타입기본형 boolean byte char short long int double float 참조형 클래스 인터페이스 배열 JAVA 컬렉션의 대표적인 인터페이스List 순서가 있다 데이터의 중복을 허용한다 구현클래스 ArrayList 데이터 배열의 형식 자료의 최대 개수에 영향을 받는다 무작위 접근 가능 자동 동기화 삭제 LinkedList 주소 배열의 형식 개수 영향 없음 순차적 접근 가능 Stack Vector 가변 길이 배열 무조건 동기화(단일 쓰레드 처리에서 성능 떨어짐) Set 순서가 없다 데이터의 중복을 허용하지 않는다 구현 클래스 HashSet TreeSet: 오름차순으로 데이터 정렬 Map HashMap TreeMap : 키에 대한 정렬 개념 배열과 컬렉션의 차이배열은 하나의 자료형만을, 컬렉션은 복수의 자료형 저장지정한 자료형 타입 한 가지만 저장하기 위해 나온 것이 제네릭 멀티쓰레드 두 가지의 작업을 동시에 실행하는 것 Thread 클래스 상속 Runnable 인터페이스 상속 Wrapper 클래스기본 자료형을 객체로 만들 경우 그러한 기능을 제공하는 클래스 인터페이스 사용 이유클래스 간의 결합도를 낮추고 응집도를 올리기 위해 가비지 콜렉터할당된 메모리 영역 가운데 더 이상 사용할 수 없게 된 영역을 탐지하여 자동으로 해제하는 기법 동기화하나의 자원을 여러 테스크가 사용하려 할 때 하나만이 사용할 수 있도록 하는 것 프로세스현재 실행 중인 프로그램 쓰레드프로세스 내 실제 작업을 수행하는 단위","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"면접 준비 - 웹","slug":"2019-01-15-면접-준비---웹","date":"2019-01-15T10:48:18.000Z","updated":"2019-01-19T05:11:56.181Z","comments":true,"path":"2019/01/15/2019-01-15-면접-준비---웹/","link":"","permalink":"http://eunajjing.github.io/2019/01/15/2019-01-15-면접-준비---웹/","excerpt":"","text":"WEBServlet init() service() destroy() 개념 서블릿자바를 사용하여 웹페이지를 동적으로 생성하는 서버측 프로그램 쿠키클라이언트에서 실행되어 보안이 취약하고 속도가 빠름 세션서버에서 실행되어 속도는 느리지만 보안이 강력함 XML데이터의 구조화가 목적인 HTML의 한계를 극복하기 위해 만들어짐 MVC 모델 : 정보 뷰 컨트롤러 : 로직 상호작용 mybatis프레임워크의 일종으로 소스코드에서 SQL 문장을 분리하여 별도의 xml 파일로 저장하고, 이 둘을 서로 연결시켜준다","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"메이븐 업데이트가 안된다","slug":"2019-01-14-maven_err","date":"2019-01-14T08:07:18.000Z","updated":"2019-01-15T12:43:53.182Z","comments":true,"path":"2019/01/14/2019-01-14-maven_err/","link":"","permalink":"http://eunajjing.github.io/2019/01/14/2019-01-14-maven_err/","excerpt":"","text":"메이븐 선생님 이게 무슨 일인가요 왜 업데이트가 안돼죠 프로젝트 진행 중에 브랜치 여러 개를 옮기며 병합했더니 갑자기 메이븐 업데이트가 되질 않았다. An internal error occurred during: “Updating Maven Project”. java.lang.NullPointerException 이렇게 메시지가 떠서, 해당 에러 메시지를 구글링했더니 역시 스텍오브플로우 짱 요약하자면 .settings 폴더 삭제 .project 파일 삭제 sts 툴도 껐다가 다시 켰다. 왜 이런 에러가 발생하는 걸까?","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"copyNpaste 프로젝트를 마친 뒤 홀로 회고","slug":"copyNpaste","date":"2019-01-13T12:16:25.000Z","updated":"2019-01-13T12:51:03.674Z","comments":true,"path":"2019/01/13/copyNpaste/","link":"","permalink":"http://eunajjing.github.io/2019/01/13/copyNpaste/","excerpt":"","text":"copyNpaste 프로젝트 회고취업 준비를 본격적으로 시작하면서 이력서를 작성 중인 요즘, 이력서 양식에서 프로젝트를 회고할 일이 있어 블로그에 함께 기록해둔다. 수료 발표 영상이 드디어 업로드 되었다 플젝 깃허브 주소 프로젝트 시작 경위사실 이 사이트의 아이디어는 내가 낸 것인데 나는 이 아이디어를 라는 독립 잡지와(현재 이 잡지는 전자책으로도 구매할 수 있다 구매링크) 연예인 전현무 님에게서 얻었다. 전현무 님이 아나운서 시절 워낙 많은 시말서를 써서, 그 시말서 자료들을 동료 아나운서들도 참고해서 쓴다더라… 하는 이야기였는데 정확히 어떤 프로그램에서 본 건지는 기억이 나질 않는다. 아무튼 사이트 첫 아이디어는 ‘어쨌든 살면서 누구나 한 번쯤은 쓰지만 일상적으로 쓰지 않는 문서의 문장들을 제공해주고, 관련 템플릿이나 작성에 요긴한 기능들이 있으면 좋겠다’ 였다. 나의 경우 대학 시절 성적 정정 메일을 보낼 때 이런 사이트가 있으면 좋겠다라는 생각을 많이 하기도 했었고. 다행히도 팀원들이 모두 좋은 아이디어라고 해줘서, 이런 서비스를 제공하는 사이트를 만들기로 했다 유저에게 보다 쉬운 글 작성을 돕는 사이트 그리하여 시작된 문서 작성의 늪 불행인지 다행인지 우리 팀은 대부분의 팀원들이 다 꼼꼼한 성격이었다. 그래서… 정말… 엄청난 회의록들과 트러블 슈팅 등… 프로젝트 산출물들이 기수 내 팀에서 제일 많이 나온 팀이었고… 물론 지금 와서 그 문서들의 소중함을 알기에 유의미했다고 생각하지만, 하는 내내 조금 불행했다. 프로그래밍 == 코드 타이핑이라고 생각했기 때문에. 근데 나중에서야 알고 보니 실무에 가서도 문서 작업이 굉장히 많다는 걸 알았다. db 모델링의 경우 거의 혼자하다시피 했는데(…) PK 설정 부분에 대해 많이 고민할 수 있던 시간들이었다. 다행히도 언니들이 DB는 하고 싶은대로 하라고 해주셔서… 진짜 내가 맞다고 생각하는대로 해봤다. 물론 논리적인 문제는 없는지 강사님도 봐주시긴 했지만, 설계 전반을 혼자 해보는 경험이 인상적이었다. 그리고 대망의 유스케이스(와 요구사항 명세서) 포트폴리오에서 그대로 가져오다보니 내가 뭘 맡았는지도 가져오게 되었다 이거 하는데 정말 많이 싸웠다. 사이트에 있으면 좋을 것 같다는 기능들이 각자 다 달라서… 뭐가 필요하니, 뭐가 경제적이니 진짜 멱살 잡기 전까지 싸웠다. 요구사항 명세가 끝나고 나니까 이제 스토리보드 대환장의 서막이 열렸고… 스토리보드 만드는 것도 진짜 더럽게 많이 싸웠다… 그리고 이 때서야 드디어 문서 작성의 중요성을 깨달았는데, 기존 회의록이 나의 옳음이나 틀림을 증명할 수 있는 증거가 되었다. (이러라고 있는 회의록이 아니겠지만) 프로젝트 구현이 프로젝트는 백 로직을 시작하기 전 모든 프론트를 만들고 시작하자는 팀 내의 합의가 있었다. 스프링 설정을 모두 마친 뒤 팀원 한 명이 우선적으로 하나의 jsp를 맡아 구현하는 방식으로 업무를 진행했고, 구현이 끝난 팀원은 또 다른, 아직 구현되지 않은 jsp를 할당 받아 구현하는 식이었다. 이 때문에 사이트 내 전체적인 통일성이 옅어졌고, 모든 소스를 통합한 뒤 한 번 더 프론트를 매만져야 하는 상황이 발생했다. 또한 Tiles를 적용했기에 중복적으로 사용되는 jsp의 경우 병합 후 스크립트 일부가 제대로 동작하지 않기도 했다. 결국 나는 스크립트 단 코드를 번복해서 짜야만 했다. 이 사건을 통해 프로젝트 처음 세팅 단계에서 폴더 구조를 명확히 해야하고, 뷰 컴포넌트에 대한 협의의 필요성을 배웠다. 웹소켓 적용의 경우 기존에 블로그에 포스팅하기도 했지만 이 프로젝트에서 내가 맡은 로직 중 가장 많은 시간이 들었던 부분이었다. 알림을 보내는 유저와 받는 유저가 모두 로그인 되어 있는 상태에서 알림 서비스를 구현한 예제들은 많았지만, 알림을 받아야 하는 대상이 로그아웃 되어있을 때에 대한 예제는 많지 않았다. 처음에는 이런 기능을 구현한 사이트들은 어떤 방식으로 했는지를 찾아봤으나 사용 언어나 DB가 맞지 않아 적용이 힘듦을 알았다. 결국 이 작업을 DB의 트리거와 프로시저로 연관시켜 구현을 시도했고, 찾을 수 있었던 레퍼런스 코드들을 프로젝트의 요구사항에 맞게 변경해 적용을 시켜야 했다. 처음으로 트리거를 만들어보았고 조건문에 따른 로직을 처리했다. 프로시저도 만들어 호출해보는 등 이론적으로만 배웠던 부분을 실제로 적용하며 많이 배울 수 있는 시간이었다. 또한 효율적인 데이터 관리를 위해 DB 설계를 어떻게 하는 게 좋을지에 대해 고민하는 시간도 되었으며 요구사항에 따라 DB나 언어 선택을 다르게 하는 이유에 대해 생각해보는 계기도 되었다. (이력서 그대로 긁어옴) 아쉬운 점 ​ Vue.js나 React 미적용 많은 기능들이 비동기로 구현되기에 완성된 사이트는 실제 호스팅되는 사이트들보다 로딩이 느렸다. 또한 CDN으로 많은 프레임워크의 기능을 가져와 사용하기에 더더욱 느렸던 것 같다. 프론트 단을 템플릿을 사용하지 않고 만든 만큼, 차라리 vue.js나 react를 배워 조금이나마 해당 기능을 적용하려는 노력이 있었더라면, 혹은 해당 기능을 기반으로 하는 탬플릿을 사용하되 기능을 이해하려는 공부가 있었더라면 완성된 사이트가 보다 효율적이지 않았을까 싶다. 이 프로젝트 이후로 리액트와 뷰에 대해 관심을 가지게 되었는데, 리액트보다는 일단 뷰를 하고 싶다는 생각이 들었다. 회고 시간 부재 구현을 마친 뒤 수료 발표를 위한 준비-문서 작업, 영상 편집, 발표 연습 등-에 너무 많은 시간을 할애한 탓에 팀원 각각이 구현한 소스에 대해 함께 보고, 왜 이렇게 구현했는지, 더 나은 방법은 없었을지 등에 대해 고민하는 회고 시간이 없었던 게 아쉽다. 개인적으로 프로젝트를 리팩토링해보고 싶은 욕심이 있어 수료 후 혼자 소스 분석하고 조금씩 손을 대보고 있는데, 타 팀원이 왜 이렇게 구현했을지를 고민하며 진행하니 어려움이 많은 요즘. 협업 툴 미사용 프로젝트를 진행하며 깃허브, 칸반보드, 구글 드라이브, 카카오톡 그룹 채팅, 면대면 대화 등을 활용해 팀원들과 협업했다. 위에서 언급한 협업 툴을 사용하는데도 조금씩 미숙했던 터라 팀원 모두가 더 효율적인 협업 툴을 찾아 적응하기보다는, 기존에 사용 중이던 협업 툴을 더 완벽하게 숙지해 사용하는데 중점을 두게 되었다. 나중에 프로젝트가 끝난 뒤, 학원 외부에서 토이 프로젝트를 하며 찾아보니 몰랐던 많은 협업 툴들이 시중에 나와 있었고 해당 툴들을 사용했더라면 보다 실용적이었으리라 생각된다. 총평힘들고 즐거웠다. 이론을 배울적, 머리로는 분명 이해했다고 생각했는데 실제로 코드를 치면서 이해를 못하고 있음을 깨닫는 날도 있었고, 새로 구현해야 하는 기능 때문에 레퍼런스를 보고 예제 코드를 봐도 이해를 못하는 나 자신이 무척 싫어지는 날도있었다. 그렇게 몇 날 며칠을 고생해 코드가 구현되었을 때는 고생했던 기억들이 씻은 듯 사라지며즐거웠다.","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"GraphQL","slug":"graphql01","date":"2019-01-12T06:43:18.000Z","updated":"2019-04-23T06:38:33.765Z","comments":true,"path":"2019/01/12/graphql01/","link":"","permalink":"http://eunajjing.github.io/2019/01/12/graphql01/","excerpt":"","text":"GraphQL 페이스북에서 만든 어플리케이션 레이어 쿼리 언어 API를 위한 쿼리 언어 기존에 백엔드와 프론트엔드를 통신하기 위해 REST API 를 썼던 것처럼, REST API 와 다른 Sever API 개발 방법론 특정한 데이터베이스, 스토리지 엔진과 관계가 없고 기존 코드와 데이터에 의해 대체됨 일반적인 REST API 는 여러 URL에서 데이터를 받아야와야 할 경우 예시 GET /accounts 123456789101112131415161718192021222324252627282930313233343536&#123; \"accounts\": [ &#123; \"id\": \"1\", \"username\": \"velopert\", \"email\": \"public.velopert@gmail.com\", \"friends\": [ \"2\", \"3\" ], \"first_name\": \"Minjun\", \"last_name\": \"Kim\" &#125;, &#123; \"id\": \"2\", \"username\": \"jn4kim\", \"email\": \"jn4kim@gmail.com\", \"friends\": [ \"1\", \"3\" ], \"first_name\": \"Jayna\", \"last_name\": \"Kim\" &#125;, &#123; \"id\": \"3\", \"username\": \"abet\", \"email\": \"abet@gmail.com\", \"friends\": [ \"2\" ], \"first_name\": \"Abet\", \"last_name\": \"Bane\" &#125; ]&#125; 만약 이 데이터에서 특정 id의 friends 의 이름을 가져온다면 요청 url은 GET /accounts/1/?include_friend_details=username,first_name 이다. 혹은 GET /accounts_with_friend_details/1 REST API 의 문제는 어플리케이션 규모가 커지면 수많은 endPoint 들이 생성된다. endPoint : 기능에서 필요로하는 정보들에 호응할 수 있는 포인트 endPoint와 그에 걸맞는 데이터를 반환해주는 API를 개발해야 했음 GraphQL 의 등장 요청하는 리소스마다 endPoint 가 다른 REST API 와는 달리 클라이언트측에서 쿼리를 만들어서 서버로 보내면 우리가 원하는대로 결과를 반환 query 123456789101112query &#123; account(id: \"1\") &#123; username email firstName lastName friends &#123; firstName username &#125; &#125;&#125; result 1234567891011121314151617181920&#123; \"data\": &#123; \"account\": &#123; \"username\": \"velopert\", \"email\": \"public.velopert@gmail.com\", \"firstName\": \"Minjun\", \"lastName\": \"Kim\", \"friends\": [ &#123; \"firstName\": \"Jayna\", \"username\": \"jn4kim\" &#125;, &#123; \"firstName\": \"Abet\", \"username\": \"abet\" &#125; ] &#125; &#125;&#125; 필요한 정보를 쿼리로 만들어서 서버에 전달하면 서버가 알아서 주어진 틀대로 데이터를 보여준다 쿼리를 통해 딱 필요한 데이터만 fetching하기 때문에 overfetch, underfetch를 할 걱정이 없다 GraphQL 스키마 언어1234567891011type Character &#123;// 객체 타입// ! = non-nullable name: String! // 필드명 : String 타입이며 null일 수 없음 appearsIn: [Episode]! // 필드명 : Episode 객체의 배열이며 null이 아님 // 만약 필드명 : [Episode!]라면 // 리스트 자체는 null일 수 있어도 null을 가질 수 없음&#125; 인자1234567type Starship &#123; length(unit: LengthUnit = METER): Float // length라는 필드는 하나의 인자(unit)를 지닌다. // 만약 unit 인자를 전달받지 못한다면 // default 값은 'METER'이다. // 자료형은 Float이다.&#125; 스칼라 타입123456789101112131415161718192021// 쿼리&#123; hero &#123; name appearsIn &#125;&#125;// 결과&#123; \"data\": &#123; \"hero\": &#123; \"name\": \"R2-D2\", \"appearsIn\": [ \"NEWHOPE\", \"EMPIRE\", \"JEDI\" ] &#125; &#125;&#125; name 과 appearIn 은 하위 쿼리가 없으므로 스칼라 타입이다. 타입 종류 Int: 부호가 있는 32비트 정수. Float: 부호가 있는 부동소수점 값. String: UTF-8 문자열. Boolean: true 또는 false. ID: ID 스칼라 타입은 객체를 다시 요청하거나 캐시의 키로써 자주 사용되는 고유 식별자를 나타냅니다. ID 타입은 String 과 같은 방법으로 직렬화된다. 열거형 타입(Enums) 특정 값들로 제한되는 특별한 종류의 스칼라 타입의 인자가 허용된 값 중 하나임을 검증 123456enum Episode &#123; NEWHOPE EMPIRE JEDI&#125;// Episode 타입이라면 반드시 위의 셋 중 하나 커스텀 타입1scalar Date 이거는 사실 이해를 못하겠다. 믿는다 미래의 나…! 특수 타입 모든 GraphQL 서비스는 query 타입을 가진다. mutation 타입은 가질 수도 있고 가지지 않을 수도 있다. 1234567891011121314151617query &#123; hero &#123; name &#125; droid(id: \"2000\") &#123; name &#125;&#125;// 이 쿼리를 실행시키려면 우선 선행적으로// hero와 droid 필드가 있는 Query 타입이 필요type 타입명 &#123; hero(episode: Episode): Character // 객체 타입 droid(id: ID!): Droid&#125; 다형성 지원 인터페이스로 공통 필드 정의 가능 123456789101112131415161718192021222324252627interface Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]!&#125; // Character를 구현한 모든 타입은 이러한 인자와 리턴 타입을 가진 정확한 필드를 가져야 함 type Human implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! starships: [Starship] totalCredits: Int&#125;type Droid implements Character &#123; id: ID! name: String! friends: [Character] appearsIn: [Episode]! primaryFunction: String&#125; // 추가 필드 구현도 가능 union 타입으로 여러 타입을 하나로 묶을 수 있음 1union SearchResult = Human | Droid | Starship 유니온 타입의 멤버는 구체적인 객체 타입이어야 한다. 즉 Human, Droid, Starship 은 객체 타입이다. 인터페이스, 유니온 타입에서 다른 유니온 타입 사용이 불가하다 만약 유니온 타입 반환 필드를 쓰고자 하면 프래그먼트를 사용해야 한다. 123456789101112131415161718// search가 유니온 타입을 반환하는 필드를 쿼리한다는 가정&#123; search(text: \"an\") &#123; ... on Human &#123; name height &#125; ... on Droid &#123; name primaryFunction &#125; ... on Starship &#123; name length &#125; &#125;&#125; 입력 타입1234input ReviewInput &#123; stars: Int! commentary: String&#125; 뮤테이션에서 특히 유용하다. 1234567891011121314mutation CreateReviewForEpisode($ep: Episode!, $review: ReviewInput!) &#123; createReview(episode: $ep, review: $review) &#123; stars commentary &#125;&#125;&#123; \"ep\": \"JEDI\", \"review\": &#123; \"stars\": 5, \"commentary\": \"This is a great movie!\" &#125;&#125; 입력 객체 타입을 참조할 수 있지만, 입력 및 룰력 타입을 스키마에 혼합할 수 없다. 필드에 인자를 가질 수 없다. GraphQL API 의 구성 GraphQL은 스키마가 미리 정의되어 있는 강타입 언어 주석은 # 으로 시작 GraphQL 문서에 쿼리 하나만 있는 경우가 아니면 명시적으로 쿼리임을 나타내야 한다. 12345query sampleQuery &#123;// 쿼리임을 명시적으로 선언 post users&#125; selection set1234567891011// 쿼리&#123; id text&#125;// 결과&#123; \"id\": 42, \"text\": \"Hello, world!\"&#125; 필드에는 인자를 넘길 수 있다123456789101112&#123; pictureURL(width: 50, height: 50)&#125;// 혹은&#123; human(id: \"1000\") &#123; name height &#125;&#125; 필드 이름은 별명(alias) 지정이 가능같은 필드를 다른 인자로 가져올 때도 사용 12345&#123; fullName: name smallPic: profilePic(size: 64) bigPic: profilePic(size: 1024)&#125; 필드가 객체나 list 타입이라면 하위 객체의 selection set를 반드시 명기123456789101112&#123; id text author &#123; name pictureURL(width: 50, height: 50) posts &#123; id text &#125; &#125;&#125; GraphQL 쿼리의 가장 바깥 selection set는 ‘쿼리 루트’ 객체로부터 시작하도록 정해져 있다. 12345678&#123; me &#123; name &#125; post(id: \"42\") &#123; title &#125;&#125; 프래그먼트(fragment) 같은 selection set이 한 쿼리 안에서 중복될 수 있다. 글쓴이의 프로필과 댓글 작성자의 프로필이 같은 컴포넌트라면 같은 필드가 필요하기 때문 중복을 제거하는데 프래그먼트를 사용할 수 있다. 123456789101112131415161718query sampleQuery &#123; post(id: \"4\") &#123; id text author &#123; ...basicUserInfo &#125; &#125; users &#123; ...basicUserInfo &#125;&#125;// User 타입에 대한 프래그먼트임을 명시fragment basicUserInfo on User &#123; name pictureURL(width: 50, height: 50)&#125; 1234567891011121314query samplePolymorphicQuery &#123; timeline &#123; data &#123; // data가 Post 리스트일 때 // 인라인 프래그먼트를 이렇게 지정 ... on Post &#123; title &#125; // 인라인 프래그먼트가 아닐 때는 이렇게 지정 ...basicUserInfo &#125; &#125;&#125; 메타 필드 리턴될 타입을 모르는 상황이 발생하면 클라이언트에서 데이터 처리를 어떻게 할 것인지 결정해야 함 __typename 을 사용하면 그 시점의 객체 타입의 이름이 리턴된다. 1234567891011121314151617181920212223242526272829303132333435&#123; search(text: \"an\") &#123; __typename // 일단 어떤 타입이든 어떤 객체 타입인지 데이터가 출력됨 ... on Human &#123; // 만약 객체 타입이 Human이라면 name &#125; ... on Droid &#123; name &#125; ... on Starship &#123; name &#125; &#125;&#125;// 결과&#123; \"data\": &#123; \"search\": [ &#123; \"__typename\": \"Human\", \"name\": \"Han Solo\" &#125;, &#123; \"__typename\": \"Human\", \"name\": \"Leia Organa\" &#125;, &#123; \"__typename\": \"Starship\", \"name\": \"TIE Advanced x1\" &#125; ] &#125; 변수 지정도 가능1234567891011121314151617181920212223query HeroComparison($first: Int = 3) &#123; // 쿼리나 뮤테이션에 선언된 변수는 // 프래그먼트에 접근이 가능하다. leftComparison: hero(episode: EMPIRE) &#123; ...comparisonFields &#125; rightComparison: hero(episode: JEDI) &#123; ...comparisonFields &#125;&#125;fragment comparisonFields on Character &#123; name friendsConnection(first: $first) &#123; // 이 경우 프래그먼트에 3이 접근한다. totalCount edges &#123; node &#123; name &#125; &#125; &#125;&#125; 변수의 정의 ($episode: Episode) 정적타입 언어의 함수에 대한 인자 정의 $ 접두사가 붙은 모든 변수를 나열하고 그 뒤에 타입이 온다 선언된 변수는 스칼라, 열거형, input object type이어야 한다. Episode 타입 옆에 !가 없다면 옵셔널이다. 지시어123456789101112131415&#123; \"episode\": \"JEDI\", \"withFriends\": false &#125;query Hero($episode: Episode, $withFriends: Boolean!) &#123; hero(episode: $episode) &#123; name friends @include(if: $withFriends) &#123; name &#125; &#125;&#125;// true와 false의 결과가 다름을 확인할 수 있다 @include(if: Boolean) : 참일 때만 필드가 결과에 포함된다. @skip(if: Boolean) 인자가 true 이면 이 필드를 건너뛴다. mutation 데이터의 읽기 외에 쓰기(변형)도 지원함 쿼리는 필드를 순서 없이 평가 mutation의 필드는 항상 순서대로 평가, 즉 하나의 요청에서 두 개의 뮤테이션 건을 보낸다면 첫 번째 뮤테이션은 두 번째 요청 전에 완료가 보장된다. 12345mutation sampleMutation &#123; setName(name: \"Zuck\") &#123; newName &#125;&#125; 참고 레퍼런스 graphql-kr 매력적인 쿼리 언어, GraphQL GraphQL 강좌 1편: GraphQL이 무엇인가? 한 단계씩 배워보는 GraphQL 가장 현대적인 웹을 만들자 GraphQL 살펴보기","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"GraphQL","slug":"개발공부/GraphQL","permalink":"http://eunajjing.github.io/categories/개발공부/GraphQL/"}],"tags":[]},{"title":"node.js와 DB 사용","slug":"2019-01-09-node.js와-DB-사용","date":"2019-01-09T02:52:18.000Z","updated":"2019-01-15T12:43:53.182Z","comments":true,"path":"2019/01/09/2019-01-09-node.js와-DB-사용/","link":"","permalink":"http://eunajjing.github.io/2019/01/09/2019-01-09-node.js와-DB-사용/","excerpt":"","text":"node.js와 DB 사용 npm install mysql 모듈 설치 mysql.createConnection(DATABASE-CONFIG); 커넥션 커넥션 설정 host, port : DMBS 주소와 포트(기본 3306) user, password : DBMS 사용자 계정과 암호 database : 데이터베이스 이름 multipleStatements : 동시에 여러 SQL 실행. 보안에 주의 connectTimeout : DBMS 연결 타임 아웃 시간. 기본은 10,000 ms 1234567var dbConfig = &#123; host : 'localhost', user : 'root', password : '1234' database : 'Moviest'&#125;;var connection = mysql.createConnection(dbConfig); 커넥션 연결과 닫기 12345678connection.connect(function(err) &#123; if (err) &#123; console.error('error connecting: ' + err.stack); return; &#125;console.log('connected as id ' +v connection.threadId);connection.end();&#125;); 커넥션 풀 사용하기 생성 1mysql.createPool(Option) 풀의 옵션풀 옵션 waitForConnections : 풀에 여유 커넥션이 없는 경우 대기 여부 connectionLimit : 최대 커넥션 개수. 기본 10개 123456var pool = mysql.createPool(&#123; host : 'localhost', user : 'user', password : '1234’, connectionLimit : 50&#125;); 풀에서 커넥션 얻기 123pool.getConnection(function(err, connection&#123; // connected! (unless `err` is set)&#125;); 풀에 커넥션 반환 conn.release(); 풀 닫기 pool.end(); 커넥션 모듈 분리 DB 커넥션 모듈 123var mysql = require('mysql');var dbPool = mysql.createPool(dbConfig);module.exports = dbPool; 모듈 사용 12var pool = require(‘./dbconnection’);pool.getConnection(function(err, conn) &#123;&#125;); SQL 문 실행 12345678var sql = 'INSERT INTO movies ...';connection.query(sql,function(err, results) &#123; if ( err ) &#123; console.error('INSERT Error', err); &#125; else &#123; console.log('results : ', results); &#125;&#125;); 12345var sql = 'INSERT INTO movies (title, director, year) VALUES (?, ?, ?);';// 인터스텔라, 크리스퍼 놀란, 2015가 순차적으로 들어간다connection.query(sql, ['인터스텔라', '크리스토퍼 놀란', 2015],function(err, results)&#123; // 에러와 결과 처리&#125;); insert 문 실행 1234567891011var data = &#123; title : '메멘토', director : '크리스토퍼 놀란', year : 2000&#125;;var sql = 'INSERT INTO movies SET ?';connection.query(sql, data, function(err, results) &#123; // 에러 처리 // 결과 사용 connection.release();&#125;); 실행 결과 affectedRow : 영향을 받은 열의 갯수 insertID : 새로 추가한 경우 Primary Key changedRow : 변경된 열의 수 select 문 실행 123456789101112var sql = &apos;SELECT * FROM movies&apos;;conn.query(sql, function(err, results) &#123; if ( err ) &#123; console.error(&apos;Error&apos;, err); return; &#125; for (var i = 0 ; i &lt; results.length ; i++) &#123; var movieInfo = results[i]; console.log(&apos;제목 : &apos; + movieInfo.title + &apos; 감독 : &apos; + movieInfo.director); &#125; conn.release(); &#125;); movieInfo에 하나의 레코드가 반환된다 SQL Injection 방지하기mysql.escape()을 사용하거나 PlaceHolder 사용하기 (?,?,?) 트랜잭션conn.beginTransaction(function(err) { } ); conn.commit() : 트랜잭션 내 변경 확정 conn.rollback() : 트랜잭션 내 변경 되돌리기 예제 123456789101112131415conn.beginTransaction(function(err) &#123; conn.query(sql1, function(err, result) &#123; if ( err ) &#123; conn.rollback(); return; &#125; conn.query(sql2, function(err, result) &#123; if ( err ) &#123; conn.rollback(); return; &#125; conn.commit(); &#125;); &#125;);&#125;);","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"Express","slug":"2019-01-08-Express","date":"2019-01-08T05:45:18.000Z","updated":"2019-01-09T13:57:34.253Z","comments":true,"path":"2019/01/08/2019-01-08-Express/","link":"","permalink":"http://eunajjing.github.io/2019/01/08/2019-01-08-Express/","excerpt":"","text":"Express 경량 HTTP 웹 프레임워크 요청과 응답 미들웨어 사용 템플릿 엔진 사용 가능 Express 미들웨어 요청 분석 , 처리하는 모듈을 여러 개 쓸 수 있음 app.use(미들웨어)로 사용 12345app.use(function(req,res)&#123; res.send('Express');&#125;);// 이 경우 어떤 요청에 대한 함수인지 알 수 없음 npm install express로 시작 Express 생성 및 시작12345678910111213var express = require('express');var app = express();// 객체 생성하는 것과 유사// 여기까지가 세팅app.use(function(req, res) &#123; res.send('Hello World'); // 미들웨어로 익명함수 // res.write와 비슷함 // http보다 편하게 사용 가능&#125;);app.listen(3000);// 포트번호 3000번에서 대기 Http 모듈 서버와 Express 혼용1234var http = require('http');var express = require('express');var app = express();http.createServer(app).listen(3000); Express 라우팅 (routing) 요청에 따라 처리 미들웨어로 분배하는 것(프론트 컨트롤러의 역할) HTTP Method 별로 라우팅 가능 1234// GET 요청 - Hello Express로 응답app.get('/', function (req, res) &#123;&#125;);// POST 요청 - 응답app.post('/', function (req, res) &#123;&#125;); URL 경로 별로 라우팅 가능(REST PULL 같은…) 1234// user 경로에 GET 요청 - 응답app.get('/user', function (req, res) &#123;&#125;);// items 경로에 GET 요청 - 응답app.get('/items', function (req, res) &#123;&#125;); Express 요청 분석요청 분석 req.query : 쿼리 문자열 req.path : 요청 URL 중 경로 req.params : URL의 파라미터 req.cookie : 요청 메시지 내 쿠키(쿠키 파서 필요) req.body : 요청 메시지 바디 분석(바디 파서 필요) 응답 res.json() : JSON 응답 메시지 전송 res.redirect() : 리다이렉션 응답 전송 res.render() : 템플릿으로 렌더링 res.send() : JSON, HTML, Buffer 전송, 메시지 헤더에 Content-Type 자동 설정 res.sendStatus() : 상태 코드와 상태 메시지 전송 res.status() : 상태 코드 설정. 응답 메소드 종료 안함 res.download() : 파일 다운로드 미들웨어 함수 형태의 작은 모듈 요청과 응답 처리 함수 형태 미들웨어 설정 하기1234app.use(sayHello); function sayHello(req, res) &#123; res.send('Hello Express!!'); &#125; HTTP 메서드별 미들웨어 설정1234app.get('/movies' , showMovieList);app.post(‘/movies’, addMovieInfo);app.put(‘/movies/:id’, updateMovieInfo);// /:id라고 쓰면 id로 들어오는 것의 값을 뽑아 쓸 수 있다 next();12345678910app.use(function(req, res, next) &#123; var now = new Date(); console.log(now.toDateString() + ' - url : ' + req.url); // 다음 미들웨어 실행 next();&#125;);app.use(function(req, res) &#123; res.send('Hello Express!!');&#125;); 하나의 요청에 다수의 미들웨어를 파라미터로 지정12345678//하나의 요청에 다수 미들웨어// 두 미들웨어를 스택 형태로 설정app.use(logger, sayHello);// next()를 호출해야 sayHallo(req, res) 실행function logger(req, res, next) &#123; next();&#125;function sayHello(req, res) &#123; &#125; 그 외 내장 미들웨어 써드 파티 미들웨어 정적 파일 요청 처리 미들웨어 12app.use(express.static(‘images’));// 정적 파일 경로 미리 만들어주고 요청이 들어오면 자동으로 images 폴더 안에서 찾게끔 SERVER-ADDRESS/cute1.jpg -&gt; ./images/cute1.jpg SERVER-ADDRESS/images/cute1.jpg -&gt; ./images/image/cute1.jpg 가상 경로 설정 12345app.use('/static', express.static(‘files’));// 해당 url로 들어오면 files란 실제 폴더에서 찾는다// app.use(express.static(‘images’)); 와 다른 점은// url을 지정해준다는 점이 다름 만약 실패하면 다음의 미들웨어 진행 12app.use(express.static('public')); app.use(express.static('files')); 메서드 경로 별 라우팅 함수123456789101112app.get('/', function (req, res) &#123; res.send('GET request, /');&#125;);app.delete('/', function(req, res) &#123; res.send('DELETE method');&#125;);app.put('/item/1', function(req, res) &#123; res.send('PUT method, /item/1');&#125;);app.all('/all', function(req, res) &#123; res.send('모든 HTTP 메소드, /all');&#125;); 메서드 별로도 라우팅이 가능하다. 위의 예제는 메서드 + 경로까지 합쳐서 라우팅 함수를 정의한 것 동적 파라미터의 문법1app.get(‘/user/:item’, [Callback]); :블라블라가 핵심 사용할 때는 이렇게 쓴다. 다수의 동적 파라미터 사용이 가능하다. 사용 예제는 아래와 같다. 123456789app.get('/user/:id', function (req, res) &#123; var userId = req.params.id; ...&#125;);app.get('/movies/:movieId/:actor', function (req, res) &#123; var movieId = req.params.movieId; var actor = req.params.actor; ...&#125;); 경로에 정규 표현식도 사용 가능 ? : 문자 존재하거나 생략 + : 1번 이상 반복 * : 임의의 문자 1234567891011// /abcd, /acdapp.get('/ab?cd', function(req, res) &#123;&#125;)// /abcd, /abbcd, /abbbcdapp.get('/ab+cd', function(req, res) &#123;&#125;)// abcd, abxcd, abRABDOMcd, ab123cdapp.get('/ab*cd', function(req, res) &#123;&#125;)// /abe, /abcdeapp.get('/ab(cd)?e', function(req, res) &#123;&#125;) 에러 처리 미들웨어에러 처리 방법 미들웨어 내부에서 처리하거나 에러 처리 미들웨어에게 위임 1234// 에러 파라미터는 아래와 같다.app.use(function(err, req, res, next) &#123; res.status(500).send(‘에러 발생!');&#125;); 123456// 에러 처리 미들웨어로 에러 전달app.use(function(req, res, next) &#123; var error = new Error(‘에러 메세지’) error.code = 100; return next(error);&#125;); 1234567891011121314// 환경 별 에러 처리 코드if (app.get('env') === 'development') &#123; // 환경 쪽에서 에러가 나면 app.use(function(err, req, res, next) &#123; res.end(err.stack); &#125;); // 미들웨어 실행&#125;else &#123; app.use(function(err, req, res, next) &#123; res.status(err.code || 500); res.end('잠시 후 다시 시도해주세요'); &#125;);&#125; express의 route 함수1234567891011121314app.route(‘/book')// 경로가 /book으로 들어오긴 했는데// 상단에 기재를 해두고// 메서드 별로 분리// 이렇게 하면 미들웨어를 분리할 수 있다는 장점이 있다 .get(function(req, res) &#123; res.send('Get a random book'); &#125;) .post(function(req, res) &#123; res.send('Add a book'); &#125;) .put(function(req, res) &#123; res.send('Update the book'); &#125;); 라우팅 로직 별로 분리 가능 1234567// router.jsvar express = require(‘expres’);var router = express.Router();router.get('/hello', sayHello);router.get('/howAreYou/:who', sayThankYou);module.exports = router; 123// 이렇게 사용도 되고,app.use(require('./router')); 123//greeting/hello 경로의 요청이 들어오면 router 모듈 사용// 이렇게 사용도 된다!app.use('/greeting', require('./router’)); 로그 처리1234console.info(‘Info Message’);console.log(‘Log Message’)console.warn(‘Warn Message’)console.error(‘Error Message’) 로그 미들웨어 (morgan) npm install morgan로 시작 요청과 응답을 자동으로 로그 남김 12var morgan = require('morgan');app.use(morgan('dev')); 바디 파서 POST 메서드 요청 : 요청 메시지 바디 분석 가능 npm install body-parser로 설치 필요 Body 메시지 인코딩 타입 json 12bodyParser.json(option)app.use(bodyParser.json()); Raw Text URL-Encoded 1app.use(bodyParser.urlencoded(&#123; extended: false &#125;)) 바디파서는 멀티 파트 메세지 파싱 불가능(formidable , multer 같은 써드 파티 미들웨어 사용) 사용 예제 12345678910111213// 바디파서를 사용하지 않은 기존 예제function addMovie(request, response) &#123; var buffer = ''; request.on('data', function(chunk) &#123; buffer += chunk; &#125;); request.on('end', function() &#123; // 바디 파싱 var query = querystring.parse(buffer); var name = query.name; var director = query.director; &#125;);&#125; 위의 코드를 아래로 123456789101112131415var express = require('express');var bodyParser = require('body-parser');var app = express();app.listen(3000);// 세팅해주고app.use(bodyParser.urlencoded(&#123;extended:false&#125;));// extended 는 중첩된 객체표현을 허용할지 말지를 정하는 것// 객체 안에 객체를 파싱할 수 있게 하려면 trueapp.use(bodyParser.json());// 바디파서 세팅function addMovie(req, res) &#123; var name = req.body.name; var director = req.body.director;&#125; 이렇게 쓴 예제도 있다 1234567app.post('/', function (req, res) &#123; var title = req.body.title; var message = req.body.message; res.send('title : ' + title + ' message : ' + message); &#125;); Express Template템플릿 엔진 ejs HTML 태그 그대로 사용 코드 실행 : &lt;% %&gt; 결과 출력 : &lt;%= %&gt; 1234567891011121314&lt;% var value = ‘hello’ %&gt;&lt;% var i = 0 var j = i + 1 var data = [&#123;title:&apos;야구&apos;, image:’baseball.png’&#125;,…];%&gt;&lt;% if ( value ) &#123; %&gt;&lt;div&gt; &lt;%= value %&gt; &lt;img src=“&lt;%= data.image %&gt;”&gt;&lt;/div&gt;&lt;% &#125; %&gt;&lt;% var tag = &apos;h1&apos; %&gt;&lt;&lt;%= tag %&gt;&gt; TAG 만들기 &lt;/&lt;%= tag %&gt;/&gt; jade Express 템플릿 설정 123456app.set('views', [템플릿 폴더]);app.set('view engine', [템플릿 엔진]);// 예시app.set('views', __dirname + '/views');app.set('view engine', 'ejs'); 템플릿에 적용 : 렌더링 123456789101112131415res.render(view [, locals] [, callback])// locals : 템플릿의 지역 변수로 설정될 데이터// callback : 렌더링 콜백// 리졸버와 비슷함// 예시// index 템플릿 파일을 렌더링한 결과로 응답// 페이지만 준다res.render('index');// index 템플릿 파일에 name 이름으로 데이터를 제공res.render('index', &#123; name: 'IU' &#125; );// user 템플릿에 name 이름으로 데이터를 제공한다. 렌더링 한 결과를 다루는 콜백 함수 정의res.render('user', &#123; name: 'IU' &#125;, function(err, html) &#123; // ...&#125;); 예시 123456// jsapp.set('views', __dirname + '/views');app.set('view engine', 'ejs');var data = [&#123;title:'야구', image:’baseball.png’&#125;,…];res.render('sports', &#123;title:'구기 종목',sports:data&#125;);// sports는 배열이다 123456789&lt;!-- sports.ejs --&gt;&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;&lt;ul&gt;&lt;% sports.forEach(function(item) &#123; %&gt; &lt;!-- sports는 객체 배열,item에는 &#123;title:&apos;야구&apos;, image:’baseball.png’&#125;가 들어온다 --&gt; &lt;li&gt; &lt;img src=&quot;images/&lt;%= item.image %&gt;&quot; height=&quot;50px&quot;&gt; &lt;%= item.title %&gt; &lt;/li&gt;&lt;% &#125;) %&gt;&lt;/ul&gt;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"node JS","slug":"newdeal_node","date":"2019-01-07T03:43:18.000Z","updated":"2019-01-09T13:27:16.013Z","comments":true,"path":"2019/01/07/newdeal_node/","link":"","permalink":"http://eunajjing.github.io/2019/01/07/newdeal_node/","excerpt":"","text":"node 기초 1234567891011121314151617181920var util = require('util');function Parent() &#123;&#125;Parent.prototype.sayHello = function() &#123; // parent를 부모로 하는 것들은 // sayhello 함수를 쓸 수 있게 붙인다 // prototype 원시타입 // function 키워드가 class도 생성 가능 console.log('Hello World, from Parent Class!');&#125;var obj = new Parent();obj.sayHello();function Child() &#123;&#125;// 상속util.inherits(Child, Parent);var obj2 = new Child();obj2.sayHello(); 기본 모듈https://nodejs.org/dist/latest-v10.x/docs/api/process.html 문서 에서 확인 프로세스 환경 : os, process 파일과 경로 , URL : fs, path, URL, querystring, stream 네트워크 모듈 : http, net, dns 전역객체(global) (Java 에서 Console 클래스 사용하는 것처럼 ….)별도의 모듈 로딩 없이 사용가능global.console.log() &gt;&gt; console.log() &gt;&gt; global 생략가능 전역객체 process console Buffer require __filename, __dirname module exports Timeout 함수 등 실습 12345// process.jsconsole.log(process.env);console.log(process.arch);console.log(process.platform); 1234567// timeout.jsfunction sayHello() &#123; console.log('Hello World');&#125;setTimeout(function() &#123; sayHello();&#125;, 2*1000); 1234//interval.jsfunction sayGoodbye(who) &#123; console.log('Good bye', who); &#125; 1234567891011//console.jsvar intVal = 3;var obj = &#123; name : 'NodeJS', how : 'Interesting'&#125;;console.log('hello world');console.log('intVal : ' + intVal);console.log('obj : ' + obj);console.log('obj : ', obj);setInterval(sayGoodbye, 1 * 1000, 'Friend'); 1234567891011// console_custom.jsvar fs = require('fs');var output = fs.createWriteStream('stdout.log');var errorOutput = fs.createWriteStream('error.log');var Console = require('console').Console;var logger = new Console(output, errorOutput);logger.info('info message');logger.log('log message');logger.warn('warning');logger.error('error message'); 123456789// consoleTime.jsconsole.time('TIMER');var sum = 0;for(var i = 1 ; i &lt; 100000; i++ ) &#123; sum += i;&#125;console.log('sum : ', sum);console.timeEnd('TIMER'); 1234567// util.jsvar util = require('util');var str1 = util.format('%d + %d + %d', 1, 2, (1+2));console.log(str1);var str2 = util.format('%s %s', 'Hello', ' NodeJS');console.log(str2); Node.js 애플리케이션의 이벤트들 클라이언트의 접속 요청 소켓에 데이터 도착 파일 오픈/읽기 완료 이벤트 처리 비동기 처리 리스너 함수 1234process.on('exit', function() &#123;console.log('occur exit event');&#125;); process.once('exit', function() &#123;console.log('occur exit event');&#125;);process.emit('exit'); //이벤트 발생 경로 : path 1var pathUtil = require('path'); 경로정보 전역객체__filename__dirname 같은 폴더 내 이미지 경로 1var path = __dirname + '/image.jpg'; 12345678910// path.jsvar pathUtil = require('path');var path = 'C:\\NewDeal\\Script\\read.txt';console.log('dirname : ', pathUtil.dirname(path));console.log('basename : ', pathUtil.basename(path));console.log('extname : ', pathUtil.extname(path));console.log(__dirname);console.log(__filename); 파일 시스템 다루기 파일 시스템 모듈 : fs 1var fs = require(‘fs’); 주요 기능 파일 생성/읽기/쓰기/삭제 파일 접근성/속성 디렉토리 생성/읽기/삭제 파일 스트림주의 : 모든 플랫폼에 100% 호환되지 않음(윈도우, 리눅스 파일 경로 다르듯) fs 모듈 사용시 비동기식 : callback 사용 논-블럭 방식 123456789fs.readFile('textfile.txt', 'utf8',function(error, data) &#123;&#125;); fs.readFile('none_exist.txt', 'utf-8', function(err, data) &#123; if ( err ) &#123; console.error('Readfile error ', err); &#125; else &#123; // 정상 처리 &#125; &#125;); 동기식 : readFileSync 블럭방식 : 성능상 주의 123456var data = fs.readFileSync('textfile.txt', 'utf8'); try &#123; var data = fs.readFileSync('none_exist.txt', 'utf-8');&#125;catch ( exception ) &#123; console.error('Readfile Error : ', exception); &#125; 123456789var fs = require('fs');fs.writeFile('textData.txt', 'Hello World', function(err) &#123; if ( err ) &#123; console.error('Error : ', err); return; &#125; console.log('Write');&#125;); 12345678910111213141516171819202122232425262728293031323334353637// FileRead.jsvar fs = require('fs');var file = 'read.txt';fs.access(file, fs.F_OK, function(err) &#123; if ( err ) &#123; console.log('파일 없음'); process.exit(1); &#125; else &#123; console.log('파일 존재'); fs.stat(file, function(err, stats) &#123; if ( err ) &#123; console.error('File Stats Error', err); return; &#125; console.log('Create : ', stats['birthtime']); console.log('size : ', stats['size']); console.log('isFile : ', stats.isFile()); console.log('isDirectory : ', stats.isDirectory()); console.log('isBlockDevice : ', stats.isBlockDevice()); if ( stats.isFile() ) &#123; fs.readFile(file, function(err, data) &#123; if ( err ) &#123; console.error('File Read Error', err); return; &#125; // encoding을 작성하지 않으면 Buffer로 var str = data.toString('utf-8'); console.log('File Contents : ', str); &#125;); &#125; &#125;); &#125; &#125;); 스트림 : 데이터 전송 흐름 콘솔 입력/출력 파일 읽기/쓰기 서버/클라이언트 -데이터 전송 스트림종류 읽기 스트림 : Readable Stream 모드 : flowing, paused flowing mode 데이터를 자동으로 읽는 모드 전달되는 데이터를 다루지 않으면 데이터 유실 paused mode 데이터가 도착하면 대기 read() 함수로 데이터 읽기 상태 readable : 읽기 가능한 상태 data : 읽을 수 있는 데이터 도착 end : 더 이상 읽을 데이터가 없는 상태 close : 스트림이 닫힌 상태 error : 에러 123456789101112131415161718192021222324252627var is = fs.createReadStream(file);is.on('readable', function() &#123; console.log('== READABLE EVENT');&#125;);is.on('data', function(chunk) &#123; console.log('== DATA EVENT'); console.log(chunk.toString());&#125;);// end 이벤트is.on('end', function() &#123; console.log('== END EVENT');&#125;);var is = fs.createReadStream(file);// 'data' 이벤트가 없으면 paused modeis.on('readable', function() &#123; console.log('== READABLE EVENT'); // 10바이트씩 읽기 while( chunk = is.read(10) ) &#123; console.log('chunk : ', chunk.toString()); &#125;&#125;) 쓰기 스트림 : Writeable Stream 데이터 출력 http 클라이언트의 요청 http서버의 응답 쓰기 스트림 tcp 소켓 이벤트 drain : 출력 스트림에 남은 데이터를 모두 보낸 이벤트 error : 에러 finish : 모든 데이터를 쓴 이벤트 pipe : 읽기 스트림과 연결(pipe)된 이벤트 unpipe : 연결(pipe) 해제 이벤트 123456789var fs = require('fs');var os = fs.createWriteStream('output.txt');os.on('finish', function() &#123; console.log('== FINISH EVENT');&#125;);os.write('1234\\n');os.write('5678\\n');os.end(); 읽기/쓰기 변환 URL var url = require(‘url&#39;); url.parse(urlStr[, parseQueryString][, slashesDenoteHost]) urlStr : URL 문자열 parseQueryString : 쿼리 문자열 파싱, 기본값 false 1234567var url = require('url');var urlStr = 'http://api.flickr.com/services/feeds/photos_public.gne?tags=raccoon&amp;tagmode=any&amp;format=json&amp;jsoncallback=?';var parsed = url.parse(urlStr, true);console.log(parsed);console.log('protocol : ', parsed.protocol);console.log('host : ', parsed.host);console.log('query : ', parsed.query); 모듈 만들기 모듈 만들기 소스 코들 분리 모듈 단위로 모듈 작성 방법 module.exports 모듈 사용하기 모듈 로딩 : requirerequire(&#39;mymodule.js&#39;); 모듈 로딩 에러require(&#39;mymodule.js&#39;); 이 경우 에러가 난다.(./mymodule.js) 사용자가 생성 한 모듈처리 해야함 모듈 만들기 123456789// mymodule.jsmodule.exports.goodMorning = function() &#123; // 모듈 함수 기능 작성&#125;exports.goodNight = function(arg, callback) &#123; // module 생략 가능&#125; 사용하기 12var greeting = require('mymodule.js');greeting.goodMorning(); exports 하지 않은 함수는 사용 불가^^ 예제) 123456789101112&gt; // student.js&gt; &gt; var student = &#123;&gt; hour : 0,&gt; study : function() &#123;&gt; this.hour++;&gt; console.log(this.hour + '시간째 공부 중');&gt; &#125;&gt; &#125;;&gt; &gt; module.exports = student;&gt; 사용할 때는 123&gt; var you = require('student.js');&gt; you.study();&gt; http서버 구동1234var http = require('http'); var server = http.createServer(function(req, res) &#123; res.end(‘Hello World’); &#125;).listen(3000); http 요청( request)var server = http.createServer(function(req, res){}) req.url : 요청 url, 경로와 쿼리 문자열 req.method : 요청 메소드 req.headers : 요청 메시지의 헤더 req(streamable) : 요청 메시지 바디 요청 쿼리 문자열 분석12 헤더 메시지 분석123456789101112var headers = req.headers;headers.hostheaders.content-typeheaders.user-agentvar server = http.createServer(function(req, res) &#123; console.log(‘HTTP Method : ' + req.method); console.log(‘HTTP URL : ' + req.url); console.log('== HEADERS =='); console.log(req.headers); res.end('Hello Node.js');&#125;); 응답 응답 메시지 상태 코드와 상태 메시지 응답 메시지 헤더 응답 메시지 바디 메시지 상태 response.statusCode response.statusMessage 메시지 헤더 response.writeHead(statusCode, statusMessage, headers)(statusMessage, headers 생략 가능) response.removeHeader(name) response.getHeader(name) response.setHeader(name, value) 메시지 바디 response.end() data, encoding, callback을 파라미터로 가질 수 있으며 생략도 가능 response.write() chunk, encoding, callback을 파라미터로 가질 수 있으며 생략도 가능 123456// 200 OKresponse.statusCode = 200;response.statusMessage = ‘OK’;// 404 Errorresponse.statusCode = 404;response.statusMessage = 'Not found'; 응답 메시지res.writeHead(200, { &#39;Content-Length&#39;: body.length, &#39;Content-Type&#39;: &#39;text/plain&#39; }); 헤더 작성 12res.setHeader(\"Content-Type\", \"text/html\");res.setHeader(\"Content-Length“, body.length); 예제 파일들 123456789var http = require('http');var server = http.createServer(function(req, res) &#123; console.log('Method : ', req.method); console.log('url : ', req.url); console.log('headers : ', req.headers['user-agent']); res.write('Hello World'); res.end();&#125;).listen(3000); 123456789var http = require('http');var server = http.createServer(function(req, res) &#123; res.statusCode = 200; res.statusMessage = 'OKOK'; res.setHeader('content-type','text/plain'); //설정에 따라 Client 화면 다르게 보인다 res.write('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); res.end();&#125;).listen(3000); 123456789101112131415var http = require('http');var fs = require('fs');var server = http.createServer(function(req, res) &#123; fs.access('cat.jpg', function(err) &#123;\\ //이름 없는 이름 cat1.jpg 테이스 한후에 if ( err ) &#123; res.statusCode = 404; res.end(); return; &#125; fs.readFile('cat.jpg', function(err, data) &#123; res.end(data); &#125;); &#125;);&#125;).listen(3333); 12345678910111213141516171819202122232425262728293031323334var http = require('http');var url = require('url');var server = http.createServer(function(req, res) &#123; // URL 분석 : 쿼리 문자열 var parsed = url.parse(req.url, true); // 이 때 parsed 안에는 프로토콜, 호스트 등의 정보가 담긴 json 객체 var query = parsed.query; // 맵 구조로 돌아온다. // http://127.0.0.1:3000/cal?start=1&amp;end=10 // 이런 url을 치면 실행됨 // 이 때 query 안에는 start 키와 값, end 키와 값이 담긴 json 객체 // start와 end를 사용해 파라미터 값을 받을 수 있다 var start = parseInt(query.start); // 파라미터 이름이 start인 값 var end = parseInt(query.end); // 파라미터 이름이 end인 값 if ( !start || !end ) &#123; // 파라미터가 없으면 res.statusCode = 404; res.end('Wrong Parameter'); &#125; else &#123; // 합계 구하기 var result = 0; for(var i = start ; i &lt; end ; i++) &#123; result += i; &#125; res.statusCode = 200; res.end('Result : ' + result); &#125;&#125;).listen(3000); 정적 파일 서비스123456789101112131415var server = http.createServer(function(req, res) &#123; if ( req.url == '/favicon.ico' ) &#123;&#125; else if ( req.url == '/image.png' ) &#123; res.writeHeader(200, &#123;‘Content-Type':'image/png'&#125;); fs.read… &#125; else if ( req.url == '/music.mp3' ) &#123; res.writeHead(200, &#123;'Content-Type':'audio/mp3'&#125;); fs.createReadStream… &#125; else if ( req.url == '/movie.mp4' ) &#123; res.writeHead(200, &#123;'Content-Type':'video/mp4'&#125;); fs.createReadStream… &#125;&#125;); 요청 URL의 경로를 실제 파일 경로 매핑 myServier.com/resource/image.png -&gt; ./resources/image.png myServier.com/resource/audio.mp3 -&gt; ./resources/audio.mp3 요청 URL에서 경로 생성 123var pathUtil = require('path');var path = __dirname + pathUtil.sep + 'resources' + req.url;// + 로 해야한다! GET , POST 다루기 중복 POST 요청 방지 POST 요청 처리 후 redirect 응답 PRG(Post-Redirect-Get) 패턴 리프레쉬 – Get 요청 중복(OK) 응답 메시지 작성 코드 Redirection : 클라이언트 주소 옮기기 상태코드 : 302 헤더 필드 : Location PRG 패턴 적용 코드 123456req.on('end', function() &#123;// POST 요청 메세지 바디 분석/처리 res.statusCode = 302; res.setHeader(‘Location’, URL); res.end();&#125;); 폼 인코딩 방식(enctype) application/x-www-form-urlencoded (default) multipart/form-data (파일 전송) text/plain 멀티파트 방식 123&lt;form method=\"post\" action=\"upload\" enctype=\"multipart/form-data\"&gt;&lt;/form&gt; post 요청 요청 데이터 얻기 123456789var body = '';request.on('data', function(chunk) &#123; console.log('got %d bytes of data', chunk.length); body += chunk;&#125;);request.on('end', function() &#123; console.log('there will be no more data.'); console.log('end : ' + body);&#125;); 데이터 처리 12345request.on('end', function() &#123; var parsed = querystring.parse(body); console.log(‘name1 : ' + parsed.name1); console.log(‘name2 : ' + parsed.name2); &#125;); 실습 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var http = require('http');var querystring = require('querystring');// 파라미터를 뽑아낼 수 있는 모듈var movieList = [&#123;title : '비트', director : '뉴딜'&#125;];var server = http.createServer(function(req, res) &#123; if(req.method.toLowerCase() == 'post') &#123; // post 방식으로 전송되었다면 addNewMovie(req, res); &#125; else &#123; // get 방식으로 전송되었다면 showList(req, res); &#125;&#125;);server.listen(3000);// 3000번 포트 사용function showList(req, res) &#123; res.writeHeader(200, &#123; 'Content-Type': 'text/html; charset=UTF-8' &#125;); // 포트 번호, 클라이언트에게 응답할 뷰단 설정 res.write('&lt;html&gt;'); res.write('&lt;meta charset=\"UTF-8\"&gt;'); res.write('&lt;body&gt;'); res.write('&lt;h3&gt;Favorite Movie&lt;/h3&gt;'); res.write('&lt;div&gt;&lt;ul&gt;'); movieList.forEach(function (item) &#123; // each문과 비슷한 역할 res.write('&lt;li&gt;' + item.title + '(' + item.director + ')&lt;/li&gt;'); &#125;, this); res.write('&lt;/ul&gt;&lt;/div&gt;'); res.write( '&lt;form method=\"post\" action=\".\"&gt;&lt;h4&gt;새 영화 입력&lt;/h4&gt;' + '&lt;div&gt;&lt;input type=\"text\" name=\"title\" placeholder=\"영화제목\"&gt;&lt;/div&gt;' + '&lt;div&gt;&lt;input type=\"text\" name=\"director\" placeholder=\"감독\"&gt;&lt;/div&gt;' + '&lt;input type=\"submit\" value=\"upload\"&gt;' + '&lt;/form&gt;' ); res.write('&lt;/body&gt;'); res.write('&lt;/html&gt;'); res.end();&#125;function addNewMovie(req, res) &#123; var body = ''; req.on('data', function(chunk) &#123; // 데이터 들어오면 발생하는 이벤트 부착 body += chunk; &#125;); // PRG 방식, 데이터 들어올 때마다 누적 req.on('end', function() &#123; // 데이터 다 들어오면 발생하는 이벤트 부착 var data = querystring.parse(body); // 데이터는 json 객체 var titledata = data.title; var directordata = data.director; // 배열에 넣기 // 자바스크립트의 배열은 스택구조임 // 때문에 스택의 메서드를 사용할 수 있음 movieList.push(&#123;title:titledata, director:directordata&#125;); // 이렇게 해도 된다 movieList.push(data); // json 객체 push res.end('success'); &#125;);&#125; 12345// 하단에 처리를 이렇게 해도 된다.res.statusCode = 302;res.setHeader('Location', '.');// 화면 재요청, get 방식으로 요청했을 때의 함수를 탄다res.end(); node를 이용한 파일 업로드formidable을 이용한 멀티파일 분석 모듈 이용1npm install formidable IncomingForm의 이벤트 field &gt; 이름/값 도착 이벤트 file &gt; 파일 도착 이벤트 aborted &gt; 요청 중지(클라이언트) end &gt; 종료 IncomingForm의 프로퍼티 form.uploadDir form.keepExtension 확장자 보존 form.multiples 다중 파일 업로드 123form.parse(req, function(err, fields, files) &#123;&#125; // fields : 이름 - 값(fields.이름) 데이터 // files : 업로드 파일 정보 업로드 파일 정보 : Formidable.File file.size 업로드 된 파일의 크기(바이트) file.path 파일 경로 file.name 파일 이름 file.type 파일 타입 file.lastModifiedDate 최종 변경일 file.hash 해쉬값 파일 업로드 서비스 구현 파일 업로드(formidable) - 임시 폴더 파일 업로드 후 -파일을 임시 폴더 -&gt; 리소스 저장소로 이동 -리소스 저장소에서 이름이 충돌되지 않도록 이름 변경 -날짜, 일련번호, 사용자 계정, …","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-18 수업 내용 정리","slug":"2018-12-18","date":"2018-12-18T08:43:18.000Z","updated":"2018-12-26T09:08:16.557Z","comments":true,"path":"2018/12/18/2018-12-18/","link":"","permalink":"http://eunajjing.github.io/2018/12/18/2018-12-18/","excerpt":"","text":"프로시저의 호출순수 원시 코드에서의 프로시저 호출12345678910111213141516CallableStatement cstmt = null;// oracle procedure 사용시 준비String sql=\"&#123;call usp_emplist(?,?)&#125;\";cstmt = conn.prepareCall(sql);cstmt.setInt(1, 1000);cstmt.registerOutParameter(2, OracleTypes.CURSOR);// 두번째 파라미터로 커서 타입을 명기해준다// 두번째 파라미터에 rs의 주소값을 넣을 것boolean result = cstmt.execute();rs = (ResultSet)cstmt.getObject(2);// 주소 정보 얻기while(rs.next())&#123; System.out.println(rs.getInt(1) + \"/\" + rs.getString(2) + \"/\" + rs.getInt(3));&#125; psmt는 쿼리문을 미리 컴파일해놓기 때문에 실행할 때 파라미터만 보낸다. 때문에 보안성이 높은 것","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-17 수업 내용 정리","slug":"2018-12-17","date":"2018-12-17T08:43:18.000Z","updated":"2018-12-26T09:08:16.556Z","comments":true,"path":"2018/12/17/2018-12-17/","link":"","permalink":"http://eunajjing.github.io/2018/12/17/2018-12-17/","excerpt":"","text":"자바의 직렬화 자바 기본(primitive) 타입과 java.io.Serializable 인터페이스를 상속받은 객체는 직렬화 할 수 있는 기본 조건을 가진다. 직렬화란?자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 이야기 ObjectInputStream, ObjectOutputStream객체 스트림 : 객체 안에 저장되어 있는 내용을 직접 입출력할 수 있도록 해준다 hashMap.keySet()hashMap에 저장된 모든 키 반환 FileInputStream, FileOutputStream 바이트 단위의 입출력을 받는 클래스출발 지점과 도착 지점을 연결하는 통로 생성file로 입력 스트림 생성 File.exists()해당 이름의 파일이나 디렉토리가 있는지 여부를 검사 File.mkdir()폴더 생성 동기화 작업이 진행되는 동안 락이 걸리는 것 123public synchronized void openDoor(String name) &#123; &#125; vector는 동기화가 되어 있고, arrayList는 동기화가 되어있지 않다. arrayList가 vector보다 성능이 좋은 이유는, 동기화가 되어있지 않기 때문이다. 쓰레드 : 순서를 정의할 수 없음 프로세스 : 동작하고 있는 프로그램보통 한 개의 프로세스는 한 가지의 일을 한다. 쓰레드를 이용하면 한 프로세스 내에서 두 가지 또는 그 이상의 일을 동시에 할 수 있게 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//동기화//한강둔치 화장실(공유자원) : 여러명 10명 (각각의 Thread 10개)//한강둔치 비빕밥 축제//Multi Thread 환경에 [공유자원]//해결 방법 : lock//함수 단위 LocK (동기화 보장)class Wroom&#123; public synchronized void openDoor(String name) &#123; //public void openDoor(String name) &#123; System.out.println(name + \"님 화장실 입장 ^^\"); for(int i = 0; i &lt; 50 ;i++) &#123; System.out.println(name + \"사용 : \"+ i); if(i == 1000) &#123; System.out.println(name + \"님 끙 !!\"); &#125; &#125; System.out.println(name + \"시원하시죠 ....\"); &#125;&#125;class Users extends Thread&#123; private Wroom wr; private String who; public Users(String name , Wroom wr) &#123; this.who = name; this.wr = wr; &#125; @Override public void run() &#123; wr.openDoor(this.who); &#125;&#125;public class Ex09_sync_Thread &#123; public static void main(String[] args) &#123; //한강둔치 Wroom w = new Wroom(); //사람들 Users kim = new Users(\"김씨\", w); Users Lee = new Users(\"이씨\", w); Users Park = new Users(\"박씨\", w); kim.start(); Lee.start(); Park.start(); &#125;&#125; PL/SQL오토커밋이 되지 않는다. end구문에 반드시 세미콜론! 123BEGIN DBMS_OUTPUT.PUT_LINE(&apos;HELLO WORLD&apos;);END; 변수 선언123456789DECLARE --선언 vno number(4); vname varchar2(20);BEGIN vno := 100; -- 할당 &gt; String s; s = &quot;홍길동&quot; vname := &apos;kglim&apos;; DBMS_OUTPUT.PUT_LINE(vno); --화면 출력 DBMS_OUTPUT.PUT_LINE(vname || &apos;입니다&apos;);END; 12345678910111213141516DECLARE vno number(4); vname varchar2(20);BEGIN select empno ,ename into vno , vname -- pl-sql 사용하는 구분 (into) . 실행결과 변수에 담기 -- 오라클엔 존재하지 않는다. -- VNO에 EMPNO를 -- VNAME에 ENAME을 담는다 from emp where empno=&amp;empno; -- &amp; 자바 scanner 역할 (입력값 받기) DBMS_OUTPUT.PUT_LINE(&apos;변수값 : &apos; || vno || &apos;/&apos; || vname);END; 실행하면 INPUT 창이 뜬다. 제어문123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113--pl-sql 제어문DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vdeptno emp.deptno%TYPE; vname varchar2(20) := null;BEGIN select empno , ename , deptno into vempno , vename , vdeptno from emp where empno=7788; --제어문 if(조건문)&#123;실행문&#125; IF(vdeptno = 10) THEN vname := &apos;ACC&apos;; -- if(vdeptno==10) &#123; vname = &quot;ACC&quot;&#125; else if()&#123;&#125; ELSIF(vdeptno=20) THEN vname := &apos;IT&apos;; ELSIF(vdeptno=30) THEN vname := &apos;SALES&apos;; END IF; DBMS_OUTPUT.PUT_LINE(&apos;당신의 직종은 : &apos; || vname);END;--IF() THEN 실행문--ELSIF() THEN 실행문--ELSE 실행문--사번이 7788번인 사원의 사번 , 이름 , 급여를 변수에 담고--변수에 담긴 급여가 2000 이상이면 &apos;당신의 급여는 BIG&apos; 출력하고--그렇지 않으면(ELSE) &apos;당신의 급여는 SMALL&apos; 이라고 출력하세요DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vsal emp.sal%TYPE;BEGIN select empno , ename , sal into vempno , vename , vsal from emp where empno=7788; --제어문 if(조건문)&#123;실행문&#125; IF(vsal &gt; 2000) THEN DBMS_OUTPUT.PUT_LINE(&apos;당신의 급여는 BIG &apos; || vsal); ELSE DBMS_OUTPUT.PUT_LINE(&apos;당신의 급여는 SMALL &apos; || vsal); END IF; END; ------------------------------------------------------------------------------- --CASE DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vdeptno emp.deptno%TYPE; v_name varchar2(20);BEGIN select empno, ename , deptno into vempno, vename , vdeptno from emp where empno=7788; -- v_name := CASE vdeptno-- WHEN 10 THEN &apos;AA&apos;-- WHEN 20 THEN &apos;BB&apos;-- WHEN 30 THEN &apos;CC&apos;-- WHEN 40 THEN &apos;DD&apos;-- END; v_name := CASE WHEN vdeptno=10 THEN &apos;AA&apos; WHEN vdeptno in(20,30) THEN &apos;BB&apos; WHEN vdeptno=40 THEN &apos;CC&apos; ELSE &apos;NOT&apos; END; DBMS_OUTPUT.PUT_LINE(&apos;당신의 부서명:&apos; || v_name); END;----------------------------------------------------------------------------------pl-sql (반복문)--Basic loop/*LOOP 문자; EXIT WHEN (조건식)END LOOP*/DECLARE n number :=0;BEGIN LOOP DBMS_OUTPUT.PUT_LINE(&apos;n value : &apos; || n); n := n + 1; EXIT WHEN n &gt; 5; END LOOP;END;/*WHILE(n &lt; 6)LOOP 실행문;END LOOP*/DECLARE num number := 0;BEGIN WHILE(num &lt; 6) LOOP DBMS_OUTPUT.PUT_LINE(&apos;num 값 : &apos; || num); num := num +1; END LOOP;END;--for--java for(int i = 0 ; i &lt; 10 ; i++) &#123;&#125;BEGIN FOR i IN 0..10 LOOP DBMS_OUTPUT.PUT_LINE(i); END LOOP;END; 123456789101112--11g 이전 (continue (x))--11g (continue 추가)DECLARE total number := 0;BEGIN FOR i IN 1..100 LOOP DBMS_OUTPUT.PUT_LINE(&apos;변수 : &apos; || i); CONTINUE WHEN i &gt; 5; --skip total := total + i; -- 1 , 2 , 3 , 4, 5 END LOOP; DBMS_OUTPUT.PUT_LINE(&apos;합계 : &apos; || total);END; 예외처리12345678910111213141516 --예외처리 EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(v_name || &apos;는 자료가 없습니다&apos;); WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE(v_name || &apos;는 동명 이인입니다&apos;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&apos;기타 에러가 발생했습니다&apos;);END;/*질의는 하나의 행만 RETURN 해야 합니다. PL/SQL 블록 내의 SELECT 문장은 다음 규칙을적용하는 Embedded SQL 의 ANSI 범주에 속합니다. 질의의 결과는 하나의 행만을 RETURN 해야 하고 하나의 행 이상 또는 행이 없는 것은 에러를 생성합니다. PL/SQL 은NO_DATA_FOUND 와 TOO_MANY_ROWS 를 예외로 블록의 예외 섹션에서 추적할 수 있는 표준 예외를 조성하여 처리 합니다.*/ 1234-- 변수 제어하기(타입)-- 1.1 타입 : v_empno number(10)-- 1.2 타입 : v_empno emp.empno%TYPE (emp 테이블에 있는 empno 컬럼의 타입 사용)-- 1.3 타입 : v_row emp%ROWTYPE (v_row 변수는 emp 테이블 모든 컬럼 타입 정보, 배열) 시퀀스12345678910create sequence empno_seqincrement by 1-- 시퀀스 증감 숫자start with 8000maxvalue 9999nocycle-- 디폴트 값으로 최대나 최솟값에 도달하면 생성 중지-- cycle이면 다시 최솟값이나 최대값에서 시작nocache;-- 디폴트로 메모리에 시퀀스 값을 미리 할당해 놓지 않으며 디폴트 값은 20 SQL%ROWCOUNT는 마지막에 업데이트 된 행을 뜻한다. 커서123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vsal emp.sal%TYPE; CURSOR c1 IS select empno,ename,sal from emp where deptno=30;BEGIN OPEN c1; --커서가 가지고 있는 문장 실행 LOOP --Memory /* 7499 ALLEN 1600 7521 WARD 1250 7654 MARTIN 1250 7698 BLAKE 2850 7844 TURNER 1500 7900 JAMES 950 */ FETCH c1 INTO vempno , vename, vsal; EXIT WHEN c1%NOTFOUND; --더이상 row 가 없으면 탈출 DBMS_OUTPUT.PUT_LINE(vempno || &apos;-&apos; || vename || &apos;-&apos;|| vsal); END LOOP; CLOSE c1;END;---------------------------------------------------------위 표현을 좀 더 간단하게--java (for(emp e : emplist)&#123;&#125;DECLARE CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR emp_record IN emp_curr --row 단위로 emp_record변수 할당 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(emp_record.empno || &apos;-&apos; || emp_record.ename); END LOOP; CLOSE emp_curr;END;--------------------------------------------------------------------------------DECLARE vemp emp%ROWTYPE; --Type 정의 CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR vemp IN emp_curr --row 단위로 emp_record변수 할당 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(vemp.empno || &apos;-&apos; || vemp.ename); END LOOP; CLOSE emp_curr;END; 1234567891011121314151617181920212223DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vsal emp.sal%TYPE; CURSOR c1 IS select empno,ename,sal from emp where deptno=30;BEGIN OPEN c1; --커서가 가지고 있는 문장 실행 LOOP --Memory /* 7499 ALLEN 1600 7521 WARD 1250 7654 MARTIN 1250 7698 BLAKE 2850 7844 TURNER 1500 7900 JAMES 950 */ FETCH c1 INTO vempno , vename, vsal; EXIT WHEN c1%NOTFOUND; --더이상 row 가 없으면 탈출 DBMS_OUTPUT.PUT_LINE(vempno || &apos;-&apos; || vename || &apos;-&apos;|| vsal); END LOOP; CLOSE c1;END; 12345678910111213DECLARE CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR emp_record IN emp_curr --row 단위로 emp_record변수 할당 -- open과 fetch 생략 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(emp_record.empno || &apos;-&apos; || emp_record.ename); END LOOP; CLOSE emp_curr;END; 1234567891011DECLARE vemp emp%ROWTYPE; --Type 정의 CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR vemp IN emp_curr --row 단위로 emp_record변수 할당 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(vemp.empno || &apos;-&apos; || vemp.ename); END LOOP; CLOSE emp_curr;END; 커서의 타입12345678910111213create or replace procedure usp_emplist( p_sal IN number, p_cursor OUT SYS_REFCURSOR -- app 에서 값을 사용하기 위해서(Multi row))is BEGIN OPEN p_cursor FOR select empno ,ename , sal from emp where sal &gt; p_sal; END; 프로시저에서 한 건 이상의 결과 값은 무조건 커서를 써야 한다. 커서를 아웃풋으로 잡고, 커서의 자료형을 SYS_REFCURSOR로 한다. 트랜젝션 및 예외 처리12345678910111213141516171819202122DECLARE v_ename emp.ename%TYPE := &apos;&amp;p_ename&apos;; v_err_code NUMBER; v_err_msg VARCHAR2(255); BEGIN DELETE emp WHERE ename = v_ename; IF SQL%NOTFOUND THEN -- 만약 해당 데이터가 없으면 RAISE_APPLICATION_ERROR(-20001,&apos;my no data found&apos;); -- 에러 번호, 메시지 --사용자 정의 예외 만들기 END IF; EXCEPTION WHEN OTHERS THEN ROLLBACK; v_err_code := SQLCODE; -- SQLCODE : -20001 v_err_msg := SQLERRM; -- SQLERRM : my no data found DBMS_OUTPUT.PUT_LINE(&apos;에러 번호 : &apos; || TO_CHAR(v_err_code)); DBMS_OUTPUT.PUT_LINE(&apos;에러 내용 : &apos; || v_err_msg); END; 프로시저 생성 123456789create or replace procedure usp_emplistis BEGIN update emp set job = 'TTT' where deptno=30; commit -- 만약 commit을 하지 않으면 rollback 된다! END; 함수는 select 구문, 프로시저는 단독 사용 가능 실행 1execute usp_emplist; 서버와 db가 따로 구축되었을 때 update문을 실행하면 update 쿼리를 빼갈 수 있다. 반면 프로시저를 사용하면 콜하는 프로시저만 빼갈 수밖에 없다. 프로시저가 db 안에 있기 때문 프로시저의 장점은 네트워크 트래픽 감소, 보안 강화 파라미터 사용12345678910111213--parameter 사용가능--종류 : INPUT , OUTPUTcreate or replace procedure usp_update_emp(vempno emp.empno%TYPE)is BEGIN update emp set sal = 0 where empno = vempno; END;--실행방법exec usp_update_emp(7788);-- 단축 표현법 123456789101112131415create or replace procedure usp_getemplist(vempno emp.empno%TYPE)is --내부에서 사용하는 변수 vname emp.ename%TYPE; vsal emp.sal%TYPE; BEGIN select ename, sal into vname , vsal from emp where empno=vempno; DBMS_OUTPUT.put_line(&apos;이름은 : &apos; || vname); DBMS_OUTPUT.put_line(&apos;급여는 : &apos; || vsal); END; input과 output input paramter : 사용시 반드시 입력 (default) output parmater 사용시 입력값을 받지 않는다. 결과를 담고 있어 받을 변수가 필요함 123456789101112131415create or replace procedure app_get_emplist( vempno IN emp.empno%TYPE, -- 강제 vename OUT emp.ename%TYPE, vsal OUT emp.sal%TYPE -- 입력값 받지 않음)is BEGIN select ename, sal into vename , vsal from emp where empno=vempno; END; 실행 123456789DECLARE out_ename emp.ename%TYPE; out_sal emp.sal%TYPE;BEGIN app_get_emplist(7902,out_ename,out_sal); -- 보내는 변수는 프로시저의 out 파라미터 -- 리턴 값을 받아낼 것들 자료형 맞춰서 변수 보냄 DBMS_OUTPUT.put_line(&apos;출력값 : &apos; || out_ename || &apos;-&apos; || out_sal);END; 사용자 함수 프로시저와 다른 점 : return 타입 12345678910111213create or replace function f_max_sal(s_deptno emp.deptno%TYPE)return number-- public int f_max_sal(int deptno) &#123; int max_sal = 0; return 10&#125;is max_sal emp.sal%TYPE;BEGIN select max(sal) into max_sal from emp where deptno = s_deptno; return max_sal;END; 리턴에 대한 타입 정말 리턴되는 것 즉 리턴이 두 개 명기된다. 사용법 12select * from emp where sal = f_max_sal(10);select max(sal) , f_max_sal(30) from emp;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-14 수업 내용 정리","slug":"2018-12-14","date":"2018-12-14T08:43:18.000Z","updated":"2018-12-26T09:08:16.556Z","comments":true,"path":"2018/12/14/2018-12-14/","link":"","permalink":"http://eunajjing.github.io/2018/12/14/2018-12-14/","excerpt":"","text":"JavaScript 람다식 12345var function1=function(text)&#123; return text.repeat(12);&#125; var function2=(text=&gt;text.repeat(12)); 1var 함수명 = (매개변수) =&gt; &#123;실행할내용&#125;; 자바스크립트 과제문제 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;할일 목록 앱&lt;/title&gt; &lt;style&gt; #add-btn&#123; padding: 5px 10px; border: 0; background: #f80; color: white; border-radius: 5px; &#125; ul&#123; padding: 0; list-style-position: inside; &#125; li&#123; border-bottom: 1px solid #999; padding: 5px 0; &#125; .active&#123; background: gold; &#125; /* 목록 클릭 스타일 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id='title'&gt;할일 목록&lt;/h1&gt; &lt;button id=\"add-btn\"&gt;목록 추가&lt;/button&gt; &lt;ul id='list'&gt; &lt;li&gt;밥먹기 1&lt;/li&gt; &lt;li&gt;잠자기 2&lt;/li&gt; &lt;li&gt;밥먹기 3&lt;/li&gt; &lt;li&gt;잠자기 4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //자바 스크립트를 사용하세요 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 모범답안 123456789101112131415161718192021222324252627282930313233&lt;script&gt; // 변수 초기화 var title = document.getElementById('title'); var list = document.getElementById('list'); var li = list.getElementsByTagName('li'); var addBtn = document.getElementById('add-btn'); // 목록 추가 버튼 // 이벤트리스너 list.addEventListener('click', activeItem); function activeItem(event)&#123; // 클릭한 노드가 li이면 if(event.target.nodeName == 'LI')&#123; // event.target은 클릭한 객체를 의미 title.innerHTML = event.target.innerText; // 목록 스타일 초기화 for(var i = 0; i &lt; event.target.parentNode.children.length; i++)&#123; event.target.parentNode.children[i].removeAttribute('class'); &#125; // 클릭한 목록 스타일 지정 event.target.setAttribute('class', 'active'); // 클릭한 대상 &#125; // end if &#125; // end function // 목록 추가 addBtn.addEventListener('click', function()&#123; var txt = prompt('제목 입력'); list.innerHTML += '&lt;li&gt;' + txt + '&lt;/li&gt;'; &#125;); &lt;/script&gt; 최초에 내가 만든 답 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;할일 목록 앱&lt;/title&gt;&lt;style&gt;#add-btn &#123; padding: 5px 10px; border: 0; background: #f80; color: white; border-radius: 5px;&#125;ul &#123; padding: 0; list-style-position: inside;&#125;li &#123; border-bottom: 1px solid #999; padding: 5px 0;&#125;.active &#123; background: gold;&#125; /* 목록 클릭 스타일 */.addColor &#123; background: #f80; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id='title'&gt;할일 목록&lt;/h1&gt; &lt;button id=\"add-btn\"&gt;목록 추가&lt;/button&gt; &lt;ul id='list'&gt; &lt;li&gt;밥먹기 1&lt;/li&gt; &lt;li&gt;잠자기 2&lt;/li&gt; &lt;li&gt;밥먹기 3&lt;/li&gt; &lt;li&gt;잠자기 4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var title = document.getElementById(\"title\"); var lis = document.getElementsByTagName(\"li\"); function showAlert() &#123; var todo = prompt(\"추가할 할 일\"); if (todo != null || todo != \"\") &#123; todoNode = document.createElement('li'); texttodo = document.createTextNode(todo); todoNode.appendChild(texttodo); document.getElementById(\"list\").appendChild(todoNode); &#125; &#125; function removeColor() &#123; for (var i = 0; i &lt; lis.length ; i++) &#123; lis[i].classList.remove('addColor'); &#125; &#125; function change(e) &#123; title.innerHTML = e.target.innerText; removeColor(); e.target.classList.add('addColor'); &#125; var addbtn = document.getElementById(\"add-btn\"); addbtn.addEventListener(\"click\", showAlert); for (var i = 0; i &lt; lis.length ; i++) &#123; lis[i].addEventListener(\"click\", change); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 나는 스타일 관련한 클래스를 하나 생성하고, 제이쿼리에서 제어하듯 클래스를 추가시켜서 구현했다. 그런데 이 오스는… 스크립트 단에서 새로 insert 시킨 li의 경우 이벤트 효과가 들어가지 않아 다시 짜야 한다. 코드를 짜면서 새롭게 배운 자바스크립트 문법은 classList 링크 prompt 그리하여 다시 짠 소스. click 이벤트를 ul에 주었다. (달라진 소스만) 123456789101112131415161718192021222324252627282930313233&lt;script&gt;var title = document.getElementById(\"title\");var list = document.getElementById(\"list\");function showAlert() &#123; var todo = prompt(\"추가할 할 일\"); if (todo != null || todo != \"\") &#123; todoNode = document.createElement('li'); texttodo = document.createTextNode(todo); todoNode.appendChild(texttodo); document.getElementById(\"list\").appendChild(todoNode); &#125;&#125;function removeColor() &#123; var lis = document.getElementsByTagName(\"li\"); for (var i = 0; i &lt; lis.length ; i++) &#123; lis[i].classList.remove('addColor'); &#125; &#125;function change(e) &#123; title.innerHTML = e.target.innerText; removeColor(); e.target.classList.add('addColor');&#125;var addbtn = document.getElementById(\"add-btn\");addbtn.addEventListener(\"click\", showAlert);list.addEventListener(\"click\", change);&lt;/script&gt; 제이쿼리 함수 안에 셀렉터를 넣으면 객체화된다. 1$(tr).addClass(\"~\"); find()는 배열을 가질 수 있다 data() HTML 엘리먼트 내에 데이터를 저장하고 읽는 역할을 하는 함수 참고에 활용한 링크 사용법 데이터 저장 123$(\"span\").data(\"name\", \"Nextree\");// key와 value 형태로 저장된다$(\"span\").data(\"address\", \"가산\"); 데이터 가져오기 12Evar name = $(&amp;quot;span&amp;quot;).data(&amp;quot;name&amp;quot;);var address = $(&amp;quot;span&amp;quot;).data(&amp;quot;address&amp;quot;); 데이터 삭제 1$(selector).removeData(key); 전송방식1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$('#delBtn').click(function() &#123; if(confirm('정말로 탈퇴하시겠습니까?')) &#123; $.ajax(&#123; url:'$&#123;root&#125;/member/users/$&#123;user.userid&#125;', type:'DELETE', contentType:'application/json;charset=utf-8', dataType:'json', success:function(response) &#123; console.log(response.result); $(location).attr('href', '$&#123;root&#125;/member/logout.cafe'); &#125;, error:function(xhr,status,msg)&#123; console.log(\"상태값 : \" + status + \" Http에러메시지 : \"+msg); &#125; &#125;); &#125; &#125;);//회원탈퇴 @RequestMapping(value=\"/users/&#123;userid&#125;\", method=RequestMethod.DELETE) @ResponseBody public Map&lt;String, String&gt; deleteMember(@PathVariable String userid) &#123; memberService.deleteMember(userid); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"result\", \"ok\"); return map; &#125; $.ajax(&#123; url: \"$&#123;root&#125;/member/users\", type: 'PUT', dataType: 'json', data: data, contentType: 'application/json;charset=UTF-8', mimeType: 'application/json', success: function(response) &#123; $('#registerModal').modal('hide'); $(location).attr('href', '$&#123;root&#125;/member/view.cafe'); &#125;, error:function(xhr, status, message) &#123; alert(\"status : \" + status + \" error : \" + message); &#125; &#125;); //회원정보수정@RequestMapping(value=\"/users\", method=RequestMethod.PUT, headers = &#123; \"Content-type=application/json\" &#125;)@ResponseBodypublic Map&lt;String, String&gt; modifyMember(@RequestBody MemberDetailDto memberDetailDto) &#123; memberService.modifyMember(memberDetailDto); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"result\", \"ok\"); return map; &#125; delete url로 데이터를 전송하고, 받는 컨트롤러 단에서 메서드 타입에 delete를 명시해준다. put create에 사용되는 방식 원하는 정보를 요청하는 게 아니라 직접 바꿀 수 있다 나한테 왜이래 그 외 @PathVariable : 외부로 value가 노출되지 않음delete 때 썼던 것 같다. @restController : 데이터 자체를 반환해주는 것(문자열, json, xml 반환) serialize() : 다 가지고 올 때 사용 1234var param = $(this).serialize();// 폼에 있는 데이터 다 가지고 오기// 이 경우 name이 key로 가버림// 나중에 이 param 객체를 data에 넣어서 ajax로 쏜다! sql nvl 함수 123SELECT ENAME, NVL(TO_CHAR(COMM),'no commission')--바꾸고자 하는 자료형이 맞아야 한다.FROM EMP 그룹함수 외에 select 절 칼럼은 모두 group by 절에 넣어야 한다. uml 의존과 연관이 잘 이해되지 않는다면 의존 : 지역 변수 연관 : 전역 변수","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-11 수업 내용 정리","slug":"2018-12-11","date":"2018-12-11T08:43:18.000Z","updated":"2018-12-26T09:08:16.555Z","comments":true,"path":"2018/12/11/2018-12-11/","link":"","permalink":"http://eunajjing.github.io/2018/12/11/2018-12-11/","excerpt":"","text":"static 블록 설명 추가 생성자와 같은 역할을 하며 static 자원만 초기화할 때 사용 메모리 기반으로 게시판 만들기링크 지인이 입사 지원 문제로 출제된 걸 봤다고 해서, 시간이 나면(..)-시간 영원히 나지 않을 것 같지만- 소스를 분석해볼 참이다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-07 수업 내용 정리","slug":"2018-12-07","date":"2018-12-07T00:07:18.000Z","updated":"2018-12-07T09:11:04.219Z","comments":true,"path":"2018/12/07/2018-12-07/","link":"","permalink":"http://eunajjing.github.io/2018/12/07/2018-12-07/","excerpt":"","text":"UML 클래스와 클래스 사이의 관계 상속상속 받은 B는 상속한 A를 확장한다. 의존 관계특정 메서드에서만 일시적으로 사용되는 관계 연관 관계, 직접 연관나는 친구와 연관되어 있다. 집합 연관컴퓨터는 마우스를 포함한다. 합성 연관컴퓨터는 메인보드를 포함한다. (집합 연관보다 더 강하게 종속) 컴퓨터가 버려지면 메인보드도 같이 버려진다. Mybatis의 ResultMap 다루기 - 포함 관계에 있는 객체를 vo에서 함께 이용하는 방법12345// vo에 포함 관계에 있는 객체 자료형의 필드를 만든다private 객체 필드명// 마찬가지로 getter, setter 메서드를 만들어준다 123456789&lt;!--xml resultMap을 만들 때, 만약에 있다면 실행하라는 뜻--&gt;&lt;association property=\"vo에 만들어둔 프로퍼티명\" javaType=\"클래스 경로\"&gt; &lt;id column=\"쿼리문의 칼럼명\" property=\"vo에 만들어둔 프로퍼티 vo의 프로퍼티명\"/&gt; &lt;!-- 항상 pk를 포함해야 한다, 만약 pk를 쓰지 않는다고 하더라도! pk는 resultMap에서 쓰듯 id로 써야 한다. 또한 pk 지정은 association 안 뿐만 아니라 resultMap 안에서 지정할 때도 써야 한다 --&gt; &lt;result colum=\"쿼리문의 칼럼명\" property=\"vo에 만들어둔 프로퍼티 vo의 프로퍼티명\"/&gt;&lt;/association&gt; 12&lt;!-- jsp --&gt;$&#123;board.vo자료형의 프로퍼티명.칼럼명&#125; mybatis에 구현체 자동 생성하기AppConfig.java (xml에서 설정할 것들을 대체해 설정했던 class) @MapperScan 어노테이션을 설정해두기 1234567891011121314@PropertySource(\"classpath:/com/....properties\")// mybatis의 dao 인터페이스 구현체를 자동 생성하는 도우미를 추가@MapperScan(\"dao 인터페이스가 들어있는 패키지 경로\")// 자동 생성된 dao 구현체는 sql를 찾을 때 인터페이스의 전체 이름으로 찾는다// 즉 dao 인터페이스가 들어있는 패키지 경로/dao명// 따라서 sql 매퍼 파일의 네임스페이스 이름은 인터페이스의 전체 이름과 같아야 한다.// 인터페이스의 메서드 파라미터, 리턴 타입은 sql 매퍼의 파라미터 타입과 리턴 타입이 같아야 한다.// 인터페이스의 메서드 이름과 매퍼 id는 같아야 한다.public class AppConfig &#123; ..&#125; dispatcherServlet 프론트 컨트롤러 요청을 받으면 jsp 인크루드, 포워딩을 맡거나 페이지 컨트롤러로 요청을 보낸다. 응답이 돌아오면 응답을 전달함 페이지 컨트롤러 : 특정 페이지에 대해서만 제어하는 것 디스패처와 jsp는 톰캣이 관리한다 그러나 페이지 컨트롤러와 dao는 ioc Container 관리 dispatcherServlet 직접 만들기dispatcherServlet webServlet(&quot;/app/*&quot;) 어노테이션 살려두고 클라이언트가 요청한 명령 추출 request.getServletPath() 메서드를 호출하면 /app이 오고, request.getPathInfo()메서드를 호출하면 /app다음의/**이 오므로 getPathInfo()를 이용한다. ioc Container를 얻어 iocContainer.getBean(request.getPathInfo()) 실행 즉 ico Container에서 요청을 처리할 객체를 getPathInfo()를 이용해 찾으면 해당 페이지를 담당하는 컨트롤러 객체가 넘어온다. 이 때 호출의 일관성을 위해 페이지 컨트롤러들의 인터페이스를 정의하고, 개별적인 페이지 컨트롤러가 이를 상속 받도록 조치한다. iocContainer.getBean(request.getPathInfo())에서 돌아오는 리턴 값도 페이지 컨트롤러들의 인터페이스로 한다. 인터페이스에 공통으로 정의할 메서드, 예제에서는 execute()메서드였는데 이 메서드는 파라미터로 httpServletRequest와 httpServletResponse를 가지게끔 한다. String execute(httpServeltRequest request, HttpServletResponse response) ​ page Controller @Component(&quot;경로&quot;) 어노테이션을 기입해준다. 생성자에서 사용할 객체를 주입 받는 식으로 전역 변수를 선언한다. 보통 이 전역 변수는 dao가 많다. (생성자에서 파라미터로 받는 객체는 마찬가지로 스프링 ioc container에 있으므로 따로 지정하지 않아도 자동으로 들어간다) dao의 메서드를 호출해 db 도달 처리를 하고, db에서 받은 것들을 set한 후, utf-8로 맞추는 등의 설정을 한다. 도달해야하는 jsp 경로를 리턴한다. 만약 리턴하지 않으면 요청했던 url로 넘어간다. return &quot;redirect:경로&quot;or return &quot;경로&quot; 다시 dispatcherServlet 페이지 컨트롤러의 메서드, 예제의 execute()메서드를 호출한다. 리턴받은 url을 include하던가 forward한다. 페이지 컨트롤러가 redirect로 보냈을 가능성을 대비해 dispatcher 단에서는 startWith()를 이용해서 어떤 url인지 확인하고, redirect로 왔다면 replace() 메서드를 이용해 redirect 제거 후 response.sendRedirect(&quot;경로&quot;)로 보낸다. 만약 redirect가 아니라면 include하던가 forward한다. Spring WebMVC 프레임워크 도입 spring-webmvc 의존 설정 springframework 의존 설정을 지워도 된다. 어차피 spring-webmvc의 의존 라이브러리이기 때문에 spring-webmvc를 가져올 때 같이 가져오기 때문 웹 어플리케이션이 시작될 때 SpringContextContainerInitializer를 부르고, 이것이 WebApplicationInitializer 구현체를 부른다. WebApplicationInitializer 구현체는 웹 어플리케이션이 시작될 때 호출되어 시작된다. 1234567891011121314151617181920212223242526public void onStartup(ServletContext servletContext) throws ServletException &#123; // 만약 web.xml에서 java 파일로 설정한 것들이 기재되어 있다면 java 파일은 실행되지 않는다. // 만약 스프링 설정 파일을 java 파일로도 한다면, // @Configuration이란 어노테이션을 붙여줘야 IOC Container가 인지한다. // 또한 어노테이션을 읽기 위해서는 xml에서 태그를 붙여줘야 한다. // 프론트 컨트롤러가 사용할 Spring IOC Container 준비 AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext(); ac.register(AppConfig.class); ac.refresh(); // 프론트 컨트롤러를 서블릿 컨테이너에 등록한다. // 프론트 컨트롤러를 생성할 때 이 객체가 사용할 Spring IOC Container를 알려준다 DispatcherServlet servlet = new DispatcherServlet(); // 서블릿 컨테이너에 위에서 만든 프론트 컨트롤러 서블릿을 등록한다. ServletRegistration.Dynamic registration = servlet.addServlet(\"app\", servlet); // 등록한 서블릿에 정보를 설정한다. // 웹 어플리케이션이 시작될 때 프론트 컨트롤러를 생성하라고 지정한다 // 프론트 컨트롤러의 url을 지정한다 registration.setLoadOnStartup(1); registration.addMapping(\"/app/*\");&#125; 상속해 반드시 구현해야하는 이 메서드가 실행된다. 기존의 dispatcherServlet을 제거하고 Spring IOC Container에서 제공하는 dispatcherServlet을 사용할 것 기존의 contextloaderlistener들도 제거 어차피 Spring IOC Container에서 다루기 때문 페이지 컨트롤러들의 인터페이스를 삭제한다. 디스패처가 페이지 컨트롤러를 실행할 때는 다른 규칙에 따라 실행하기 때문. 기존에 사용자가 만든 규칙은 필요치 않다. 페이지 컨트롤러의 어노테이션 @Component(&quot;경로&quot;)를 @Controller로 바꾼다. 페이지 컨트롤러의 메서드에 @RequestMapping(&quot;경로&quot;) 어노테이션을 붙여준다. 컴포턴트 옆의 경로를 붙여준다. 메서드 이름 또한 사용자가 정의 가능 CharacterEncodingFilter 사용 WEB-INF/web.xml 123456789101112131415161718192021222324252627282930313233&lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/app-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;filter&gt; &lt;!-- 기재하게되면 더이상 java 단에서 encoding을 지정하지 않아도 된다 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; app-servlet.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"com.eomcs.lms\"/&gt; &lt;!-- Spring WebMVC 관련 애노테이션을 처리해주는 도우미 객체를 추가한다. --&gt; &lt;mvc:annotation-driven enable-matrix-variables=\"true\"/&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 원래 어노테이션을 이용한 필터도 사용 가능한데, 구현해야하는 메서드가 많아서 .xml로 처리 dispatcherServlet만 초기화하는 추상 클래스 AbstractDispatcherServletInitializer를 상속 받아 추상 메서드 `getServletFilter()를 재정의 12345@Overrideprotected Filter[] getServletFilters() &#123; return new Filter[] &#123;new CharacherEncodingFilter(\"utf-8\");&#125;&#125;// 왜인지 에러나고 잘 안되어서 수업 중 실행 여부 확인 못함 JSP 파일 감추기 클라이언트로부터 jsp 파일을 감춘다 외부에서 jsp를 직접 접근하지 못하게 WEB-INF/jsp폴더로 옮긴다. appConfig.java에서 Spring WebMVC에 기본으로 설정되어 있는 ViewResolver를 InternalResourceViewResolver로 교체 1234567891011121314@Beanpublic ViewResolver viewResolver() &#123; // viewResolver 인터페이스의 구현체 객체 생성 메서드 InternalResourceViewResolver vs = new InternalResourceViewResolver(); vs.setPrefix(\"/WEB-INF/jsp/\"); // 리턴되는 url에 앞에 자동으로 이것을 붙인다. vs.setSuffix(\".jsp\"); // 뒤에 이것을 붙여라 vs.setViewClass(JstlView.class); // viewClass는 jstlview이다. return vs;&#125; 페이지 컨트롤러의 return 값을 바꾼다. 스프링 자동화 request, responese를 굳이 파라미터로 가져오지 않고, 원하는 값은 파라미터로 가져와 처리한다. httpSession도 가져올 수 있다. request.set으로 객체를 담지 않고, Model에 담는다. 다시 공부해야 할 것 같아…","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-06 수업 내용 정리","slug":"2018-12-06","date":"2018-12-06T00:45:18.000Z","updated":"2018-12-07T05:28:45.687Z","comments":true,"path":"2018/12/06/2018-12-06/","link":"","permalink":"http://eunajjing.github.io/2018/12/06/2018-12-06/","excerpt":"","text":"MVC 모델MVC 모델1 JSP가 요청을 받는 Controller의 역할을 하면서 동시에 View의 역할도 하는 것 MVC 모델2 Servlet이 Controller의 역할 JSP가 View의 역할 Service도 Model의 역할을 한다, DAO만 Model이 아님 업무 로직 트랜젝션 관리 component 부품, 역할적인 의미가 강조될 때 사용되는 용어 object, instance, bean… JSP 실행 방식 JSP를 실행하고 싶다는 요청이 들어오면 JSP 엔진이 JSP를 JAVA 소스로 만든다 이것은 httpServlet을 상속 받은 서블릿 소스가 된다 이것은 .class파일이 되어 실행되는 것 JSP는 서블릿 클래스를 만드는 재료로 사용되는 것 때문에 JSP는 template이라고 불리기도 한다 즉 JSP는 직접 실행되는 것이 아님 직접 print.out할 필요가 없어서 사용하는 것 JSP 안의 &lt;% %&gt; Domain-Specific language = DSL 12&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; 위에 선언하는 이유 그런데 JAVA만 사용이 가능(향후 다른 언어도 가능하게 하려고 만들었다) 스코프 서버가 시작되며 웹 어플리케이션 실행 하나의 서버에는 여러 개의 웹 어플리케이션이 실행될 수 있다 정확히 말하면 웹 어플리케이션이 시작하면 ServletContext 보관함이 생성 이것은 웹 앱을 종료할 때까지 보관함은 유지된다. 이 보관함에는 IOC Container가 대표적으로 있다. 클라이언트가 최초로 서버에 접속하는 순간에 HttpSession 객체가 생성되며 Session을 무효화할 때 보관함이 사라진다. 유저 단에서 요청이 들어오면 ServletRequest 보관함이 생기고, 응답할 때까지 보관함은 유지된다. JSP는 자신만의 PageContext 스코프를 가진다 JSP가 실행되는 동안에만 유지되는 보관소이다. 때문에 응답이 완료되지 않더라도, 다른 JSP로 실행이 옮겨가는 순간 사라진다. sendRedirect로 이동시킬 때는 상대 경로로 지정해도 된다. 브라우저의 입장에서 경로를 인식하기 때문 서버에서 include, forward시키는 경우에는 루트부터 시켜줘야 한다 Expression Language(EL 태그) 표현언어 ${} Expression : 결과를 리턴하는 것 때문에 태그 안에는 결과를 리턴하는 값이 와야 함 Statment의 일부 (if, else의 {} 등) OGNL 오브젝트 그래프 네비게이션 언어 EL 태그 안에서 쓸 수 있다 객체 안의 객체를 가리킬 때 쓰는 표기법 html meta tag 중에 실행 후 reloading을 지원하는 태그가 있다 123&gt; &lt;meta http-equiv=\"Refresh\" content=\"1;url=list\"&gt;&gt; // 1초 후에 어디로 리로딩하겠다&gt; component button에 타입이 지정이 안되면 기본 submit 버튼 Filter 필터 역할을 할 클래스는 Filter 인터페이스를 상속 받아야 함 dofilter메서드를 구현 init() detory() 12345인터페이스 &#123; default 리턴타입 메서드() &#123; 정의 &#125;&#125; 원래 인터페이스는 메서드를 구현할 수 없으나, 인터페이스에 기본적으로 적용이 되는 메서드을 추가 시키기 위해 사용 init와 detory가 대표적인 default 메서드 12345678필터 인터페이스를 상속 받은 필터 클래스 &#123; @Override doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#123; chain.doFilter(request, response); // 이 필터 다음에 또 다른 필터가 있다면 그 필터 실행 // 없다면 원래 목적지인 servlet 실행 &#125;&#125; 필터에 sertCharacterEncoding같은 공통으로 들어가는 메서드를 추가하면 편하다 1@webFilter(\"*\") 어노테이션 기입이 필요하다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-05 수업 내용 정리","slug":"2018-12-05","date":"2018-12-05T00:06:18.000Z","updated":"2018-12-07T05:32:11.038Z","comments":true,"path":"2018/12/05/2018-12-05/","link":"","permalink":"http://eunajjing.github.io/2018/12/05/2018-12-05/","excerpt":"","text":"Bean 컨테이너 SW의 용어Engine 일을 실행하는 역할 Parser 해석하는 역할 엔진보다 협소한 의미, 실행까지 하면 엔진이라고 한다 Container 객체의 생성과 소멸을 관리 VM 생성과 실행과 소멸을 담당하는 역할 컨테이너 + 엔진의 느낌 Bean 인스턴스, 오브젝트, 객체 의존 객체 주입이 필요 생성자에 파라미터로 던져주던 것들 IOC Container(DI Container) 의존 객체를 주입한 빈 컨테이너(IOC != DI)(IOC &gt; DI) 제어의 역행이 일어난다 메인 흐름과 별개의 이벤트 핸들러(리스너) 메서드가 실행된다 생성하지 않은 객체가 외부에서 만들어져 주입 된다 IOC의 3대 예 중 2개 이벤트 리스너 DI = 의존 객체 주입(생성이 아님) DI를 쓰면 좋은 점 의존 객체 대체가 쉽다(예를 들어 지불 수단이라는 인터페이스 급의 객체를 DI해서 넣어두면, 지불 수단 인터페이스를 상속 받은 돈, 카드 등의 재화도 주입이 가능) 단위 테스트가 쉽다 (예를 들어 원래 과일을 가는 믹서기를 만든다고 했을 때, 믹서기를 만드는 도중 테스트를 한다고 가정하자. 과일까지 모두 조달해서 믹서기를 작동하는 구조 OR 믹서만 작동이 가능한 구조 중에 단위 테스트가 쉬운 건 후자. 테스트할 때 과일 외에도 다양한 식품을 넣어볼 수 있다.) 쓸모 없는 데이터의 생성을 최소화할 수 있다(자원 낭비가 덜 함) Spring IOC Container spring 공부 다시 해야할 듯… dependncies에 Spring-context 의존 설정을 해준다.(maven에서 검색함) Spring Ioc 설정 파일 추가 xml로 설정하거나 class로 설정하는 방법 두 개 AppConfig.java(Class) 작성 만약 내가 만든 클래스가 아니라서, 즉 IOC Container가 자동으로 생성할 수 없는 경우 메서드를 정의하여 직접 객체를 생성해야 한다. mybatis 관련 객체의 경우가 대표적으로, sqlSessionFactory가 가 그렇다. SqlSessionFactory 객체를 생성하는 메서드 추가 12345678910111213141516package com.eomcs.lms;// ioc Container에게 패키지 이름을 알려준다// 이름을 알려주면 그 패키지를 뒤져서 @conponent가 붙은 클래스에 대해// 인스턴스를 자동으로 생성@ComponentScan(\"com.eomcs.lms\")public class AppConfig &#123; @Bean // Spring IOC Container에게 이 메서드를 호출하여 리턴 값을 보관하라고 표시하는 어노테이션 public SqlSessionFactory createSqlSessionFactory() throws Exception&#123; String resource = \"com/eomcs/lms/conf/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); // 리턴 값을 저장할 때 사용할 이름을 따로 지정하지 않으면 메서드 이름으로 저장되기에 // 이런 메서드의 이름은 동사가 아닌 객체의 이름인 명사 형태로 짓는다 &#125;&#125; 이름 지정하는 방법@Bean(&quot;이름&quot;)은 이러하지만 잘 사용하지 않는다. dao 클래스는 내가 만든 클래스므로, 해당 클래스 위에 객체 자동생성하도록 설정 이 때 당연히 인터페이스는 객체 생성이 불가하므로, 상속 받은 클래스에 어노테이션 @Component 이용 Spring Boot xml 설정이 아닌 java class로 설정한다 Spring IOC Container 준비 실행 클래스에 Spring IOC Container 객체 준비 실행 클래스에서 해당 소스 기술 1ApplicationContext iocContainer = new AnnotationConfigApplicationContext(AppConfig.class); 그리고 이 소스를 1Command commandHandler = commandMap.get(command); 이렇게 변경 123Command commandHandler = (Command) iocContainer.getBean(command); // 빈을 찾으면 정상 실행, 빈을 못 찾으면 예외가 발생 // 때문에 if else가 아니라 try catch 처리 차후에 iocContainer도 close() 필요 Class 정보를 보고자 할 때12345678910111213141516171819202122232425262728293031&gt; Class&lt;?&gt; clazz = Class.forName(\"com.eomcs.lms.AppConfig\");&gt; // AppConfig 클래스가 메모리에 로딩되어 있지 않다면 로딩 후 클래스 정보 리턴&gt; // 어떤 클래스라도 상관 없이 받기 위해 제네릭 &lt;?&gt;&gt; // class가 이미 사용되는 예약어라 clazz로 객체 이름 설정이 일반적&gt; // AppConfig.class와 같다.&gt; &gt; // Reflection 클래스 : JVM에 로딩되어 있는 있는 클래스와 메소드 정보를 읽어 올 수 있다&gt; &gt; Method[] methods = clazz.getMethods();&gt; // 클래스의 모든 메서드들이 들어온다&gt; &gt; Constructor[] constructors = clazz.getConstructors();&gt; // 생성자의 정보&gt; Class&lt;?&gt; returnType = methods[0].getReturnType();&gt; // 메서드의 리턴 타입&gt; Parameter[] params = methods[0].getParameters();&gt; // 메서드에 들어가는 파라미터&gt; &gt; ApplicationContext iocContainer = new AnnotationConfigApplicationContext(AppConfig.class);&gt; // 확장자(.class)가 아닌 클래스 변수명임을 기억할 것&gt; System.out.println(iocContainer.getBeanDefinitionCount());&gt; // 몇 개의 객체 생성을 했는지&gt; String[] names = iocContainer.getBeanDefinitionNames();&gt; // 생성된 객체들의 이름을 리턴&gt; &gt; for (String name : names) &#123;&gt; System.out.printf(\"%s ===&gt; %s\\n\", name, iocContainer.getBean(name).getClass().getName());&gt; // 객체 이름 ===&gt; 경로 출력됨&gt; // 객체의 이름을 지정하지 않았다면 클래스명 맨 앞 대문자를 소문자로 변경해 사용&gt; &#125;&gt; Spring IOC 컨테이너와 mybatis 연동 buid.gradle에 mybatis-spring 의존 설정 추가 sqlSessionFactory 객체 생성 mybatis-spring에서 제공하는 도우미 클래스를 사용해 만드는 것으로 메서드 변경 apache common-dbcp 라이브러리 추가datasource 구현체(db 커넥션풀 객체) buid.gradle에 commons-dbcp2 의존 설정 추가 기존 소스가 이런 상태에서 123456@Beanpublic SqlSessionFactory sqlSessionFactory() throws Exception &#123; String resource = \"com/eomcs/lms/conf/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream);&#125; 이렇게 변경하고, 12345678910@Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); // datasource 주입 factoryBean.setDataSource(dataSource); return factoryBean.getObject(); &#125; 123456789101112131415161718192021222324252627282930313233343536클래스 위에 `@PropertySource` 어노테이션을 더 추가해주고, 가져오는 프로퍼티 파일이 들어갈 수 있도록 `@value` 어노테이션도 클래스 변수 위에 기술해준다.```// spring ioc Container에게 프로퍼티 파일을 로딩할 것을 명령@PropertySource(\"classpath:/com/eomcs/lms/conf/jdbc.properties\")// 프로퍼티가 있는 위치를 가리키되, 기술하는 방식을 지켜야 한다.public class AppConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") String jdbcDriver; @Value(\"$&#123;jdbc.url&#125;\") String jdbcUrl; @Value(\"$&#123;jdbc.username&#125;\") String jdbcUserName; @Value(\"$&#123;jdbc.password&#125;\") String jdbcPassword;```객체 생성 메서드를 만들어준다. (basic datasource 방식)``` @Bean public DataSource dataSource() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(jdbcDriver); dataSource.setUrl(jdbcUrl); dataSource.setUsername(jdbcUserName); dataSource.setPassword(jdbcPassword); return dataSource; &#125;```이제 db 커넥션을 java 파일에서 하므로, `mybatis-config.xml`에서 중복 기술 사항을 삭제한다.- db 커넥션 풀- db 연결 정보를 담은 프로퍼티 파일 로딩 트랜젝션 관리자 spring 트랜젝션 관련 라이브러리 의존 설정(Spring JDBC) 추가 AppConfig에 PlatformTransactionManager를 리턴하는 메서드 구현 이 때 이 객체의 이름은 반드시 transactionManager로 설정 다른 이름으로 설정하면 트랜젝션과 관련한 다른 객체를 생성할 때 그 객체가 트랜젝션 관리자를 자동으로 찾지 못한다. 생성자 메서드 소스는 다음과 같다. 123public PlatformTransactionManager platformTransactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; 이제 db 트랜젝션 관리 또한 java 파일에서 하므로, mybatis-config.xml에서 중복 기술 사항을 삭제한다. 도메인 클래스에 별명 구현 SqlSessionFactory를 반환하는 메서드에 다음의 설정을 세팅한다. 1factoryBean.setTypeAliasesPackage(\"com.eomcs.lms.domain\"); 마찬가지로 별명 지정 또한 java 파일에서 했으므로, mybatis-config.xml에서 중복 기술 사항을 삭제한다. SQL을 보관한 XML 파일 경로 또한 java 파일에서 가능 12345678910111213141516@Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource, ApplicationContext iocContainer) throws Exception &#123; SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setMapperLocations(iocContainer.getResources(\"classpath:/com/eomcs/lms/mapper/*Mapper.xml\")); // sql mapper 로딩 // sql 파일이 있는 위치를 파라미터로 보내야 하는 상황 // sql 파일의 위치 정보를 resource 객체에 담아 넘겨야 함 // resource 객체는 Spring IOC Container를 통해 만들 수 있다. // Spring IOC Container 객체를 얻는 방법 : 메서드의 파라미터로 받는다. // 이 경우 ioc container 생성은 실행 클래스에서 하기에 // 실행 클래스에서 해당 객체가 넘어온다. return factoryBean.getObject(); &#125; mybatis-config.xml가 더 이상 필요 없다 웹 어플리케이션 이론 웹 브라우저는 http 프로토콜에 맞춰서 웹 서버에 요청한다. 웹 서버는 우리가 만든 프로그램을 실행해서 결과를 받아서 http 프로토콜 규칙에 맞춰 응답해야 한다. 그런데 웹서버의 역할은 프로그램을 실행하는 게 아니다. 웹서버는 정적 웹 리소스 html, css, java script, png, jpeg 등을 읽어서 웹 브라우저에게 리턴하는 게 원래 역할이다. 웹서버가 프로그램을 실행해야하는 상황이니까 프로그램을 실행할 중간 객체를 필요로 하게 된다. 실행해야 하는 리소스(DB와 같은 것)은 동적 리소스(Dynamic Web Resource) ioc container는 웹서버의 요청이 들어오면 메서드를 호출해 프로그램을 실행시켜 리턴 값을 전달한다. 웹 서버는 웹 브라우저로 http 프로토콜 규칙에 맞춰 리턴 값을 응답한다. 웹 브라우저는 응답 받은 것에 맞춰 화면을 출력한다. 웹 어플리케이션이란 웹 기반으로 프로그램 실행되는 자바 프로그램 웹 어플리케이션이 하나의 객체로 이루어진 게 아닌 만큼, 기능을 잘게 쪼개서 하나의 클래스가 하나의 기능을 수행하게끔 만들어야 한다. 웹 어플리케이션은 서버 프로그램인데 간단한 작업만을 수행한다. 때문에 서버 어플리케이션의 작은 조각이라는 의미로 접미사 let을 붙인다. 서블릿(Servlet) 웹 어플리케이션을 구성하는 요소들 작은 서버 프로그램 서블릿 컨테이너(WAS) 웹 서버 상에서 실행되는 자바 컨테이너 서블릿 컨테이너의 대표적인 예는 톰캣 서블릿 컨테이너는 이미 다운 받아 사용하는 것이고 개발자는 서블릿을 만드는 것 웹 서버, 웹 브라우저는 종속이 아니지만(http 프로토콜 규칙 때문) 서블릿은 서블릿 컨테이너에 종속된다. 예를 들어 버전이 맞지 않는다면 실행되지 않는다. 서블릿 컨테이너와 서블릿이 통신할 수 있도록 규칙이 있고 이들은 인터페이스로 구성되어 있다. 서블릿 필터 리스너 규칙이 들어 있는 인터페이스들이 자동으로 들어있는 것은 JAVA EE(웹 기술와 분산 기술-EJB-, 웹 서비스 기술, 자원 관리 기술) 대표적인 것 : 자바 EE 구현체 웹로직 웹스피어(IBM 서버) JBoss Glasspish Geronemo 톰캣 : EE 모두 구현이 아닌 웹 기술만 뽑아서 만든 것 Jeus 웹 어플리케이션을 구성하는 요소 서블릿 필터 리스너 servlet의 메서드인터페이스로 구현되어 있는 기본 5개의 메서드 init() service() detory() getServletInfo() getServletConfig() 서블릿 구현 1234567891011121314151617// 어노테이션을 이용해 톰캣 서버에 서블릿이 있음을 알리고// 루트 디렉토리부터 쓴 url을 매핑해준다.// 톰캣 서버에 서블릿을 추가한 후 서블릿을 변경하면 일정 시간이 지난 후 리로딩 가능// 추가하는 경우에만 서버 재시작 필요@WebServlet(\"/board/list\")public class BoardListServlet implements Servlet&#123;(4개의 메서드 생략) @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; res.setContentType(\"text/palin;charset=utf-8\"); PrintWriter out = res.getWriter(); // 클라이언트 쪽에 출력할 때 필요한 객체준비 out.println(\"게시물 목록\"); &#125; 1public class BoardListServlet extends GenericServlet &#123;&#125; 이렇게 추상클래스 GenericServlet을 상속 받아도 된다. GenericServlet에는 service메서드를 제외한 메서드가 구현이 되어 있기에 service만 구현하면 된다. 또한 HttpServletRequest와 HttpServletResponse를 파라미터로 사용하기 위해 추상클래스 HttpServlet(GenericServlet을 상속 받음)을 상속 받아도 된다. 12345public class BoardListServlet extends HttpServlet&#123; @Override public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; .. &#125;&#125; HttpServletRequest와 HttpServletResponse를 파라미터로 사용할 수 있는 service는 doget 과 dopost 호출이 가능하다. httpServlet은 service 실행 시 부모인 GenericServlet에 정의된 service메서드를 부르고, 이 메서드는 다시 HttpServletRequest와 HttpServletResponse를 파라미터로 쓰는 service메서드를 내부적으로 부르며 실행된다. 서블릿 컨테이너는 바로 doget과 dopost를 직접 부르지 못한다. filter의 메서드 init() service() detory() listener의 메서드123456789101112131415161718192021222324252627282930313233343536373839@WebListenerpublic class ContextLoaderListener implements ServletContextListener&#123; // 웹 어플리케이션이 시작되거나 종료될 때 호출되는 메서드를 정의한 것 AnnotationConfigApplicationContext iocContainer; // 다른 메서드에서도 접근이 가능하도록 전역변수로 올린다. @Override public void contextDestroyed(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(\"웹 어플리케이션이 종료될 때 자동 호출\"); // Spring IOC Container 자원을 해제 iocContainer.close(); &#125; @Override public void contextInitialized(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(\"웹 어플리케이션이 시작될 때 자동으로 호출\"); // AppConfig 클래스가 메모리에 로딩되어 있지 않다면, // Spring IoC 컨테이너 준비하기 iocContainer = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(iocContainer.getBeanDefinitionCount()); String[] names = iocContainer.getBeanDefinitionNames(); for (String name : names) &#123; System.out.printf(\"%s ===&gt; %s\\n\", name, iocContainer.getBean(name).getClass().getName()); &#125; // Spring IOC Container를 servlet이 사용할 수 있도록 // servletContext라는 보관소에 저장 ServletContext sc = sce.getServletContext(); // 파라미터로 들어온 ServletContextEvent를 이용해 IOC Container를 받을 준비 sc.setAttribute(\"iocContainer\", iocContainer); &#125;&#125; WAS가 요청을 받으면 service 메서드가 실행되며 doget이나 dopost 실행됨 servlet 호출됨 이 순간부터 IOC Container가 관리하는 게 아니라 관리자가 WAS로 넘어감 그런데 dao부터는 IOC Container가 관리 때문에 servlet에 IOC Container의 주소를 알려줘야 함 1sc.setAttribute(\"iocContainer\", iocContainer); 이 작업이 이루어지는 이유 그리고 HttpServlet를 상속 받은 BoardListServlet 소스 코드는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 어노테이션을 이용해 톰캣 서버에 서블릿이 있음을 알리고// 루트 디렉토리부터 쓴 url을 매핑해준다.@WebServlet(\"/board/list\")public class BoardListServlet extends HttpServlet&#123; ApplicationContext iocContainer; BoardDao boardDao; @Override public void init() throws ServletException&#123; // 서블릿 인터페이스에 정의된 init(ServletConfig)가 먼저 호출되고, init(ServletConfig)가 init()를 호출하는 것 // 톰캣이 바로 호출하는 게 아님 // boardDao 객체를 꺼내기 위해 먼저 IOC Container를 꺼낸다. ServletContext sc = this.getServletContext(); // ServletContext는 웹 어플리케이션 당 한 개 뿐이다. // ContextLoaderListener에서 꺼낸 것과 같은 객체가 온다. iocContainer = (ApplicationContext) sc.getAttribute(\"iocContainer\"); // 오브젝트 자료형이 리턴되어 applicationcontext 인터페이스로 받는다 try &#123; boardDao = iocContainer.getBean(BoardDao.class); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; res.setContentType(\"text/palin;charset=utf-8\"); PrintWriter out = res.getWriter(); // 클라이언트 쪽에 출력할 때 필요한 객체준비 out.println(\"게시물 목록\"); try &#123; List&lt;Board&gt; list = boardDao.findAll(); for (Board board : list) &#123; out.printf(\"%3d, %-20s, %s, %d\\n\", board.getNo(), board.getContents(), board.getCreatedDate(), board.getViewCount()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; servlet에서 dao 도달 dao에서 mariaDB 도달 설정서블릿 어플리케이션 개발에 사용할 라이브러리 추가 build.gradle에서 빌드 명령 사용이 가능할 수 있도록 설정 eclipse 대신 eclipse-wtp 플러그인 추가 웹 어플리케이션 배치 파일(.war)을 만들 war 플러그인 추가 단독으로 실행이 불가하므로 application 플러그인도 제거 mainClassName = &#39;App&#39; 도 제거 12345plugins &#123; id 'java' id 'eclipse-wtp' id 'war'&#125; servlet-api 의존 설정 1providedCompile group: 'javax.servlet', name: 'javax.servlet-api', version: '4.0.1' providedCompile : 개발하는 동안에만 사용하겠다 compile : 개발하는 동안에도 사용하고, 배포 시에도 함께 쓰겠다. src/main/webapp : 웹 자원을 둘 디렉토리 생성","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"안드로이드 스튜디오를 이용해 안드로이드 앱 만들기","slug":"android1","date":"2018-12-05T00:06:18.000Z","updated":"2018-12-06T15:32:18.270Z","comments":true,"path":"2018/12/05/android1/","link":"","permalink":"http://eunajjing.github.io/2018/12/05/android1/","excerpt":"","text":"설치 Java JDK 설치 및 환경변수 설정 안드로이드 스튜디오 설치 Hello, World! MainActivity 프로그램을 제일 먼저 실행시키는 부분 R.class 안드로이드는 모든 것에 다 복잡한 숫자의 id가 붙어있다. id를 사용자가 직접 타이핑해서 사용하는 건 힘들기 때문에 R 클래스 안 아이디 사용에 관한 static 변수/메서드를 구현해 놓아 사용자가 보다 쉬운 방식으로 요소를 이용할 수 있도록 했다. 자동 import 단축키 alt + Enter 상속 메서드들 보기 단축키 ctrl + o 리스트 뷰 꾸미기 참고하고 있는 강의기존에 처음 html로 페이지를 만들 적에 이 분이 만든 강의를 처음 들었었는데, 당시에 많은 도움을 받았던 기억이 나 이번에도 이 분 강의를 듣는 중! 에러 트러블슈팅 처음에는 강의와 똑같이 했는데도 실행이 안됐다. 강의가 만들어진지 좀 됐기 때문에, 나는 당연히 조금 최신 버전의 os와 에뮬레이터를 선택해 실행했는데… 이게 바로 에러의 서막이었다… 처음에는 맥과 JDK가 충돌나서 그런가 했다. 왜냐하면 지금 안드로이드 스튜디오를 맥 OS로 다운로드 받을 때, JDK 일부 버전에서 에러가 날 수도 있다는 경고가 뜨기 때문이다. 관련하여 맥 OS에서 안드로이드 스튜디오로 앱 만드시는 분께 여쭤봤는데 본인은 잘만 돌아간다며 걱정 말라고…. avd에 관한 에러였는데, 찾아보니까 Emulated Performance 부분의 Graphics을 auto가 아니라 Software - GLES 2.0으로 바꾸면 된다고 했다. 나도 바꾸려고 했지만 바꿀 수 없게 블록 잼…. 언제나 그렇듯 구글링하며 흐느끼다가 마음의 고향 스택옾에 갔고 해결책을 얻었다. 고마워여 스택옾…! 제일 위에 채택 받은 답변을 보면, 구글 플레이스토어를 지원하는 기기의 경우에 바꿀 수 없게 막혀있다고 했다. 즉 다른 기기를 선택하면 된다고… 그래서 해결…","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"안드로이드","slug":"개발공부/안드로이드","permalink":"http://eunajjing.github.io/categories/개발공부/안드로이드/"}],"tags":[]},{"title":"2018-12-04 수업 내용 정리","slug":"2018-12-04","date":"2018-12-04T00:21:18.000Z","updated":"2018-12-07T05:33:06.841Z","comments":true,"path":"2018/12/04/2018-12-04/","link":"","permalink":"http://eunajjing.github.io/2018/12/04/2018-12-04/","excerpt":"","text":"리턴 값은 프로그램의 유연성을 위해 인터페이스 자료형으로 한다. try-with-resources 자바 버전 7에 추가된 기능으로 try에 자원 객체를 전달하면 finally 블록으로 close 처리를 하지 않아도, try 코드 블록이 끝나면 자동으로 자원을 종료해주는 기능 closeable 인터페이스를 상속한 객체만이 try 소괄호 안으로 들어올 수 있다 만약 해당 인터페이스를 상속 받지 못했다면 try 구문에 올 수 없다 try 문의 존재 이유가 finally이기 때문에 try-with-resources로 구현했다면 굳이 catch 문을 구현하지 않는다. 이 경우 메서드에서 예외처리가 같이 명시되어 있어야 한다. PreparedStatement로 쿼리문을 날릴 때, ‘? 처리가 try 소괄호 안에서 처리가 불가능하다 이 경우에는 set을 try 구문 안(중괄호 속)에서 입력 1234567891011121314151617181920212223public Board findByNo(int no) throws Exception &#123; DriverManager.registerDriver(new Driver()); try ( Connection con = DriverManager.getConnection(\"jdbc:mariadb://localhost:3306/studydb\", \"study\", \"1111\"); PreparedStatement stmt = con.prepareStatement( \"select bno, cont, cdt, view, mno, lno\" + \" from board where bno=?\");) &#123; stmt.setInt(1, no); try (ResultSet rs = stmt.executeQuery()) &#123; if (rs.next()) &#123; Board board = new Board(); board.setNo(rs.getInt(\"bno\")); board.setContents(rs.getString(\"cont\")); board.setCreatedDate(rs.getDate(\"cdt\")); board.setViewCount(rs.getInt(\"view\")); board.setWriterNo(rs.getInt(\"mno\")); board.setLessonNo(rs.getInt(\"lno\")); return board; &#125; else &#123; return null; &#125; &#125; &#125;&#125; 만약 try 소괄호 안, 마지막 구문은 세미콜론 생략이 가능하다 만약 try 문을 구현한 메서드에서 예외를 던지게 설정되어 있다면 (throws Exception) catch 블록을 따로 구현할 필요가 없다. MyBatis 적용 gradle에 의존 설정을 해준 뒤 gradle eclipse 실행해 설정 파일 갱신 src/main/resources/자바경로/comf에 mybatis-config.xml를 둔다. resources가 없으면 생성 mybatis-config.xml에 자바 소스 폴더로 등록 후 gradle eclipse 재실행 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; jdbc.properties 파일 작성해서 해당 프로퍼티가 안으로 들어갈 수 있도록 설정 1234jdbc.driver=org.mariadb.jdbc.Driverjdbc.url=jdbc:mariadb://localhost:3306/studydbjdbc.username=studyjdbc.password=1111 12345678910111213141516171819202122232425&lt;-- xml은 이렇게 수정된다 --&gt;&lt;configuration&gt;&lt;-- properties의 경로 설정해준다--&gt;&lt;properties resource=\"com/eomcs/lms/conf/jdbc.properties\"&gt;&lt;/properties&gt;&lt;-- db 연결 정보를 설정, default는 아래와 같다 즉 db 연결 정보를 여러 개 설정할 수 있다 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;-- 트랜젝션 관리는 jdbc를 쓰겠다 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;-- db 커넥션 풀 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;-- value와 프로퍼티 파일의 이름이 같아야 한다 --&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;-- sql을 보관할 xml 파일 경로 설정 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/eomcs/lms/mapper/BoardMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; src/main/resources/자바경로/mapper/BoardMapper.xml에 파일 작성(sql문들) 실행 클래스에서 mybatis의 SqlSessionFactory 객체 준비 12345678String resource = \"com/eomcs/lmes/conf/mybatis-config.xml\";&lt;!-- 팩토리 패턴 --&gt;InputStream inputStream = Resources.getResourceAsStream(resource);&lt;!-- 빌더 패턴 --&gt;SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); BoardDao boardDao = new MariaDBBoardDao(sqlSessionFactory); inputStream : 설계도의 역할 SqlSessionFactoryBuilder는 전문적으로 SqlSessionFactory를 만듦 객체 생성 과정이 복잡할 때는 대부분 *Builder 클래스를 활용해 생성 - 빌더 패턴 디자인 패턴 중 하나인 빌더 패턴, 팩토리 패턴 팩토리 패턴은 간단한 조립의 기능 수행, 빌더는 보다 큰 기능을 수행한다 dao가 사용할 수 있도록 생성자에 해당 객체 주입 dao 단에서 세션 생성 123456public List&lt;Board&gt; findAll() throws Exception &#123; try (SqlSession sqlSession = sqlSessionFactory.openSession()) &#123; return sqlSession.selectList(\"DoardDao.findAll\"); &#125;&#125; 실습 중 에러 기록 mapper의 namespace 대소문자 오타 인터페이스 상속 받은 메서드 오타 메서드 실행 시 필요한 파라미터 값 넘기지 않음 gradle eclipse 실행 후 새로고침 에러 mybatis의 경우 오토커밋이 안되기 때문에 커밋 설정을 따로 해줘야 한다.트랜젝션 관리 때문에 오토커밋을 자동으로 실행하는 옵션을 설정할 수 없다. 1234567public int insert(Board board) throws Exception &#123; try (SqlSession sqlSession = sqlSessionFactory.openSession()) &#123; int count = sqlSession.insert(\"BoardDao.insert\", board); sqlSession.commit(); return count; &#125; &#125; 별명 지정 가능 12345&lt;properties resource=\"com/eomcs/lms/conf/jdbc.properties\"&gt;&lt;/properties&gt;&lt;!-- 프로퍼티 아래로 들어와야 한다 --&gt;&lt;typeAliases&gt; &lt;package name=\"com.eomcs.lms.domain\"/&gt;&lt;/typeAliases&gt; db 내 컬럼과 domain의 이름이 다를 때매퍼의 상위에 아래 코드를 기술해 지정해주고, 123456&lt;resultMap type=\"board\" id=\"boardMap\"&gt; &lt;!-- board 칼럼을 프로퍼티 이름과 연결 --&gt; &lt;id column=\"bno\" property=\"no\"/&gt; &lt;!-- pk는 result가 아니라 id로 해줘야 한다 --&gt; &lt;result column=\"cont\" property=\"contents\"/&gt;&lt;/resultMap&gt; sql 태그에서 파라미터맵이나, resultMap으로 위를 가리켜 실행 123&lt;select id=\"findAll\" resultMap=\"boardMap\"&gt; select bno, cont, cdt, view from board&lt;/select&gt;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-03 수업 내용 정리","slug":"2018-12-03","date":"2018-12-03T00:08:18.000Z","updated":"2018-12-07T05:33:39.735Z","comments":true,"path":"2018/12/03/2018-12-03/","link":"","permalink":"http://eunajjing.github.io/2018/12/03/2018-12-03/","excerpt":"","text":"지난주 static 블록과 instance 블록 이해가 안되어서 추가로 찾아보았다 참고한 사이트들 목록 참고한 사이트1 참고한 사이트2 참고한 사이트3 스태틱 블록 클래스가 로딩된 후 클래스 변수를 초기화 시키는 코드를 주로 둔다 인스턴스 블록 인스턴스가 생성된 후 실행 인스턴스 변수를 초기화 시키는 코드를 주로 둔다 어떤 생성자가 호출되든 공통적으로 실행되어야 하는 코드가 있다면 작성한다 일단 클래스를 읽어야 하므로, 클래스 로딩 - 스태틱 블록 실행 - 객체 생성(ex. int i) 완료 - 인스턴스 블록 실행 클래스가 로딩되다 클래스 로더는 자바 바이트 코드를 읽어들여 클래스 객체를 생성하는 역할을 담당 로더가 읽은 바이트 코드가 올바르다면, 메서드 에리어 영역으로 파일이 로딩된다 JVM에 로딩된 클래스만이 객체로 사용이 가능하다 3.7부터 건너 뛰었는데, 따로 공부를 해야할 것 같다. braw 업데이트해야한다 DBMSMYSQLmysql 서버에 접속하기로컬 MySQL 서버에 접속 mysql -u root -pEnter password: 암호입력 원격 MySQL 서버에 접속 mysql -h 서버주소 -u root -pEnter password: 암호입력 mysql root 암호 변경 alter user ‘root‘@’localhost’ identified by ‘1111’; MySQL 사용자 추가 CREATE USER ‘사용자아이디‘@’서버주소’ IDENTIFIED BY ‘암호’; 로컬에서만 접속할 수 있는 사용자를 만들기: CREATE USER ‘study‘@’localhost’ IDENTIFIED BY ‘1111’; =&gt; 이 경우 stidu 사용자는 오직 로컬(서버를 실행하는 컴퓨터)에서만 접속 가능한다.=&gt; 다른 컴퓨터에서 실행하는 MySQL 서버에 접속할 수 없다는 것을 의미한다. 원격에서만 접속할 수 있는 사용자를 만들기: CREATE USER ‘study‘@’%’ IDENTIFIED BY ‘1111’; =&gt; 이 경우 study 사용자는 원력에서만 접속 가능하다. (% = 원격) MySQL 사용자 목록 조회 select user from 데이터베이스명.테이블명; select user from mysql.user; MySQL 데이터베이스 생성 CREATE DATABASE 데이터베이스명DEFAULT CHARACTER SET utf8DEFAULT COLLATE utf8_general_ci; CREATE DATABASE studydbDEFAULT CHARACTER SET utf8DEFAULT COLLATE utf8_general_ci; MySQL 사용자에게 데이터베이스 사용 권한 부여 GRANT ALL ON 데이터베이스명. TO ‘사용자아이디‘@’서버주소’;GRANT ALL ON studydb. TO ‘study‘@’localhost’;GRANT ALL ON studydb.* TO ‘study‘@’%’; 데이터베이스 목록 조회 show databases; 사용자 교체 quit (프로그램 종료 후)mysql -u study -p (다시 실행) 기본으로 사용할 데이터베이스 지정하기 use 데이터베이스명use studydb; 데이터베이스의 전체 테이블 목록 조회 show tables; 흐름 웹 브라우저의 요청 서블릿 필터가 거른다 디스패처 서블릿 호출 인터셉터 발동 가능 페이지 컨트롤러 호출 jsp 호출 서비스 호출 dao 동작 db 도달 스프링의 3대 필터 서블릿 필터 인터셉터 aop 자유로운 영혼, 메서드 호출 전후에 꼽는 필터 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용하도록 지원 DB 포함 관계 : 회원과 학생 엔티티의 관계 상호 배타 관계 : 학생과 교사 엔티티의 관계 인덱스 칼럼의 지정: insert, update, delete 시 실행 속도는 느려지나 select 속도가 빨라짐 도메인 : 실무에 가면 엔티티가 많아지므로, 비슷한 종류의 칼럼들을 묶어 관리하기 위해 사용 gradle 사용법 maven에서 jar 파일을 gradle로 복사한 뒤 build.gradle에 dependencies에 붙여넣고 cmd에서 gradle ecilpse","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-11-30 수업 내용 정리","slug":"2018-11-30","date":"2018-11-30T00:08:18.000Z","updated":"2019-04-28T11:27:49.312Z","comments":true,"path":"2018/11/30/2018-11-30/","link":"","permalink":"http://eunajjing.github.io/2018/11/30/2018-11-30/","excerpt":"","text":"과제 이건 좀 어려워서 복습 과제 할 예정(25)! 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.eomcs.lms.handler;import java.util.Arrays;import com.eomcs.lms.domain.Lesson;public class LessonList &#123; static final int LENGTH = 10; private Lesson[] list; private int size = 0; public Lesson[] toArray() &#123; return Arrays.copyOf(list, size); &#125; void add(Lesson lesson) &#123; if (size &gt;= list.length) &#123; int oldLength = list.length; // int newCapacity = oldLength + (int)(oldLength + 0.5); // 만약 배열의 크기만큼 데이터가 찼다면 // 새 배열을 만들어서 복제를 해야함 // 그래서 새 배열을 기존 배열의 1.5배로 늘려준다 // cpu는 부동 소수점 연산이 복잡함 // 그래서 이렇게 쓴다 int newCapacity = oldLength + oldLength &gt;&gt; 1; // 소수점을 좌측으로 이동해 우측의 소수점을 버린다 // 비트 이동 연산자 사용 list = Arrays.copyOf(list, newCapacity); &#125; list[size++] = lesson; &#125; public LessonList() &#123; list = new Lesson[LENGTH]; &#125; public LessonList(int initialCapacity) &#123; if (initialCapacity &gt; LENGTH) &#123; list = new Lesson[initialCapacity]; &#125; else &#123; list = new Lesson[LENGTH]; &#125; &#125;&#125; 1234567891011121314151617181920212223242526package com.eomcs.lms.handler;import java.sql.Date;import java.util.Scanner;import com.eomcs.lms.domain.Lesson;public class LessonHandler &#123; Scanner keyboard; LessonList list; public LessonHandler(Scanner keyboard) &#123; this.keyboard = keyboard; list = new LessonList(); &#125; public void listLesson() &#123; Lesson[] lessons = list.toArray(); for (Lesson lesson : lessons) &#123; System.out.printf(&quot;%3d, %-15s, %10s ~ %10s, %4d\\n&quot;, lesson.getNo(), lesson.getTitle(), lesson.getStartDate(), lesson.getEndDate(), lesson.getTotalHours()); &#125; &#125; 다형적 변수 사용 과제 12345678910111213141516package com.eomcs.lms.handler;import java.util.Arrays;public class ArrayList &#123; final int DEFAULT_CAPACITY = 10; int size = 0; // 배열은 어떻게 처리하지? // 다형적 변수 사용! Object[] list; // 그러나 모든 자료형을 받을 수 있기 때문에-오토박싱(자동으로 객체로 포장)로 싸서- // 이를 막고자 핸들러 측에서 제네릭 사용 public ArrayList() &#123; list = new Object[DEFAULT_CAPACITY]; &#125; 123456789101112131415161718192021222324252627282930package com.eomcs.lms.handler;import java.sql.Date;import java.util.Scanner;import com.eomcs.lms.domain.Board;public class BoardHandler &#123; Scanner keyboard; ArrayList&lt;Board&gt; list; public BoardHandler(Scanner keyboard) &#123; this.keyboard = keyboard; this.list = new ArrayList(20); &#125; public void listBoard() &#123; Object[] boards = list.toArray(); // 여기서 강제 형변환을 할 수 없음 for (Object obj : boards) &#123; Board board = (Board) obj; // 여기서는 가능함 // 실제로 object 배열이기 때문에 board 배열로 바꾸는 건 안되는 것이고, // 배열에 들어있는 data는 원래 자료형이 board이기 때문에 // 형 변환이 여기서는 가능한 것 System.out.printf(\"%3d, %-20s, %s, %d\\n\", board.getNo(), board.getContents(), board.getCreatedDate(), board.getViewCount()); &#125; &#125; 오토박싱과 오토언박싱123456&gt; int i = 10;&gt; Integer obj = new Integer(100);&gt; &gt; obj = 200; // 이렇게도 되는데, 사실 오토박싱으로 new Integer(200); 된 것&gt; int j = obj; // 이렇게도 되는데, 사실 오토언박싱으로 obj.intValue(); 된 것&gt; System.arraycopy의 이용 배열을 복사할 때는 arraycopy(소스가 되는 배열, 소스 배열의 몇 번째 인덱스부터, 저장할 배열, 저장을 시작할 배열 인덱스, 배열 복사할 개수) 12배열.arraycopy(src, srcPos, dest, destPos, length);// dest 배열 destPost 번부터 length 개를 복사해 src 배열 srcPost 번째부터 저장 만약 저장할 배열이 복사 받을 배열보다 크기가 작다면 카피를 하되, 자료형을 가져온다. 123if(a.,length &lt; size) &#123; (WhatType[]) Arrays.copyOf(list, size, a.getClass());&#125; 못 따라감 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.eomcs.util;import java.util.Arrays;public class ArrayList&lt;T&gt; &#123; // T : 어떤 타입 final int DEFAULT_CAPACITY = 10; Object[] elementData; // 여기는 T로 쓸 수 없고, 최초이므로 Object로 배열 만들기 int size = 0; public ArrayList() &#123; elementData = new Object[DEFAULT_CAPACITY]; &#125; public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; DEFAULT_CAPACITY) elementData = new Object[initialCapacity]; else elementData = new Object[DEFAULT_CAPACITY]; &#125; @SuppressWarnings(\"unchecked\") // 에러 체크하지 않는다 public T[] toArray(T[] a) &#123; if (a.length &lt; size) &#123; // 만약 size가 a보다 크다면, 즉 배열의 방이 다 찼다면 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); &#125; System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) // 보통 빈 배열일 경우 자동으로 null 값이지만 // 배열을 재사용했을 경우를 대비해 데이터 뒤를 null로 만들어준 것 // 배열의 끝을 모르기 때문에 null 처리 a[size] = null; return a; &#125; public void add(T obj) &#123; if (size &gt;= elementData.length) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); elementData = Arrays.copyOf(elementData, newCapacity); &#125; elementData[size++] = obj; &#125; public int size() &#123; return this.size; &#125;&#125; 12345678910111213141516171819202122232425262728package com.eomcs.lms.handler;import java.sql.Date;import java.util.Scanner;import com.eomcs.lms.domain.Member;import com.eomcs.util.ArrayList;public class MemberHandler &#123; Scanner keyboard; ArrayList&lt;Member&gt; list; public MemberHandler(Scanner keyboard) &#123; this.keyboard = keyboard; this.list = new ArrayList&lt;&gt;(20); // 위에서 정의를 했기 때문에 제네릭을 비운 것 &#125; public void listMember() &#123; Member[] members = list.toArray[list.size()]; // 이거는 이렇게 할 수도 있음 // Member[] members = list.toArray(new members[] &#123;&#125;); // 빈 배열을 보내도, 어차피 ArrayList에서 조건문을 걸었기 때문에 가능한 것 for (Member member : members) &#123; System.out.printf(\"%3d, %-4s, %-20s, %-15s, %s\\n\", member.getNo(), member.getName(), member.getEmail(), member.getTel(), member.getRegisteredDate()); &#125; &#125; Arrays.copyOf와 .clone()의 차이 Arrays.copyOf : 배열의 크기만큼 복제 .clone() : 배열 안에 들어 있는 인스턴스만큼 복제 뛰어넘음, 인터페이스가 필요한 이유 인터페이스의 메서드는 모두 공개 상태여야 한다. (Default로 접근 제한을 걸었다) LinkedList와 ArrayList LinkedList List 인터페이스를 구현한 AbstractList를 상속하지 않고 AbstractSequentialList를 상속 자료의 주소 값으로 서로 연결되어 있는 구조 inkedList는 몇 개의 참조자만 바꿈으로써 새로운 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간안에 수행 가능 자료의 최대 개수에 영향을 받지 않음(무한 개수의 자료를 삽입 가능) 순차접근만이 가능(무작위 접근 불가) 자료들을 저장 공간에 불연속적인 단위로 저장 메모리 이곳저곳에 산재해 저장되어 있는 노드들을 접근하는데 ArrayList보다는 긴 지연 시간이 소모 참조자를 위해 추가적인 메모리를 할당해야 함 ArrayList List 인터페이스를 구현한 AbstractList를 상속 데이터들이 순서대로 쭉 늘어선 배열의 형식 O(N)만큼의 연산 속도가 걸리기 때문에 자료의 최대 개수에 영향을 받음 ArrayList는 크기가 한정되어 있음 무작위 접근 가능 자료들을 하나의 연속적인 묶음으로 묶어 자료를 저장 스택과 큐 스택 LIFO(Last In Frist Out) push, pop 큐 FIFO(Frist In Frist OUT) offer, poll interface Cloneable clone을 쓰기 위해 상속 받는 것 사실 clone은 object의 메서드이고, Cloneable에서 override 해야할, 실제로 구현할 메서드는 없으나, clone이 사용 된다는 표기 역할을 함 중첩 클래스의 이용(안드로이드가 대개 이런 문법을 이용한다) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.eomcs.util;public class Stack&lt;E&gt; extends LinkedList&lt;E&gt; implements Cloneable &#123; // Cloneable는 clone을 쓰기 위함 // clone은 object의 메서드이나 구현을 하기 위해서는 Cloneable을 상속 받아야 함 // Cloneable에서 실제로 구현할 메서드는 없으나, clone이 된다는 표기 역할을 함 private int maxSize; public Stack() &#123; maxSize = 100; &#125; public Stack(int maxSize) &#123; this.maxSize = maxSize; &#125; @Override public Stack&lt;E&gt; clone() &#123; Stack&lt;E&gt; temp = new Stack&lt;&gt;(); for (int i = 0; i &lt; size(); i++) &#123; temp.add(get(i)); &#125; return (Stack&lt;E&gt;) temp; &#125; // 객체를 생성해서 반복문 돌려서 넣어준 것 public void push(E value) &#123; if (size() == maxSize) remove(0); add(value); &#125; public E pop() &#123; return remove(size() - 1); &#125; public Iterator&lt;E&gt; iterator() &#123; return new IteratorImpl&lt;&gt;(); // 중첩 클래스가 실행되기 전에 인스턴스 블록이 실행될 것이기 때문에 // 게다가 이너 클래스는 외부 클래스에 접근이 가능하기 때문에 // 굳이 객체 클론해서 보내지 않아도 됨 &#125; // 중첩 클래스의 사용 // 어차피 stack에서만 쓸 것이기 때문에 이렇게 구현 class IteratorImpl&lt;T&gt; implements Iterator&lt;T&gt; &#123; Stack&lt;?&gt; stack; int count; int size; &#123; // 인스턴스 블록 // 앞에 아무 것도 없는 것이 특징 // 인스턴스 생성자 호출 전에 먼저 실행되는 블록 // 클래스 안에서 &#123;&#125; 하면 인스턴스 블록 // static 블록은 클래스가 로딩될 때 실행됨 // 이곳의 this는 이너 클래스의 객체 주소를 가리킨다. // 만약 외부 클래스의 객체 주소를 말하고자 한다면 // 클래스명.this로 시작해야 한다. this.stack = Stack.this.clone(); // 이너 클래스는 외부 클래스의 멤버 변수들과 메서드에게 접근 가능 &#125; @Override public boolean hasNext() &#123; return count &lt; Stack.this.size(); &#125; @Override public T next() &#123; count++; return (T) this.stack.pop(); // 중첩 클래스 안이라서 강제 형변환 시킴 &#125; &#125;&#125; 이너 익명 클래스의 활용 1234567public Iterator&lt;E&gt; iterator() &#123; return new IteratorImpl&lt;&gt;() &#123; // 이너 익명 클래스로도 만들 수 있다. // 슈퍼 클래스의 기본 생성자가 호출되며 // 위에서 구현한 메서드 정의가 그대로 들어온다. &#125; &#125; 커맨드 디자인 패턴 메서드 하나만을 구현한 클래스들로 프로그램을 구현한 것 새로운 기능을 추가할 때도 좋고, 유지보수가 보다 원활하다는 장점이 있다. 메서드가 실제 구현된 클래스들은 특정 메서드가 정의된 인터페이스를 상속함 이 메서드는 이름만 같을 뿐 클래스마다 각각 기능이 다르게 구현 실행 클래스에서는 모든 클래스들의 객체를 생성한 뒤, hashMap()에 객체를 담는다. 이 때 키를 기존에 command에 입력하던 문자열로 준다. 그리고 조건문을 돌릴 때 eqauls를 사용하지 않고, 프롬프트에서 받은 문자열을 키로 이용해 interface 자료형으로 value를 받는다. 이 value가 null인지 확인 후, 인터페이스에서 상속된 메서드를 호출하며 기능을 실행한다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-11-29 수업 내용 정리","slug":"2018-11-29","date":"2018-11-29T00:09:18.000Z","updated":"2018-12-07T05:36:32.212Z","comments":true,"path":"2018/11/29/2018-11-29/","link":"","permalink":"http://eunajjing.github.io/2018/11/29/2018-11-29/","excerpt":"","text":"자바 영역 메서드 에리어(Methed Aera) 명령어가 저장 12345678910x &#123; int i = 100; int[] arr; arr = new int[10]; arr[i] = 300; &#125;main &#123; x(); x();&#125; 그런데 만약 문자열이라면? 1234String s = new String(\"Hello World!\");// 이것은 힙으로 간다.String st = \"Hello!\";// 이것은 상수 풀로 간다. 예전에는 String이 char의 배열이었는데, 자바 버전이 올라가며 utf-8로 저장하기 위해 byte의 배열로 변경됨 또한 메서드 호출이 종료되면, 메서드 안의 인스턴스 변수가 소멸된다. 스택(Stack) 메서드 하나 당 하나의 프레임이 형성되고 관련 데이터들의 주소(첫 시작점)가 저장됨 메서드 호출이 종료되면 소멸됨 1234main 프레임 생성x의 프레임 생성 후 소멸x의 프레임 생성 후 소멸프로그램이 종료되면 main 프레임 소멸 힙(Heap) 객체의 데이터가 저장됨 유일하게 garbage가 있는 곳 garbage collector는 특정 객체가 주소를 잃었고 현재 메모리가 부족하다고 생각되면 cpu가 한가할 때 실행됨 (이게 가능한 이유는 참조-레퍼런스- 카운트를 기억하기 때문) 1x 내 데이터들의 메모리가 저장되었다가 garbage collector가 삭제 자바는 객체 배열을 만들 수 없다 그래서 String 배열을 만든다고 했을 때 힙에는 12[ ] [ ] [ ]....// 각각의 칸에 상수 풀 주소가 저장된다 만약 String을 정식 객체 생성을 해서 만들었다고 했을 때 1s의 Hello World가 저장되어 있다 상수 풀(constant pool) 문자열이 저장되었다면 상수 풀(constant pool)에 저장된다! 힙이 아님 이미 같은 문자열이 있다면 새로 메모리를 만들지 않는다 즉 참조 주소가 다르다! 보통 String을 1String st = \"~\"; 로 만들기 때문에(단축 객체 생성) 참조 주소가 같은 것 그래서 equals를 써야 함 헷갈리니까 이전에 했던 예제123456789101112131415&gt; main &#123;&gt; String s1 = new String(\"hello\");&gt; String s2 = new String(\"hello\");&gt; String s3 = \"hello\";&gt; String s4 = \"hello\";&gt; String s5 = s1;&gt; &gt; if(s1 == s2) System.out.println(\"s1과 s2 주소값이 같음\");&gt; if(s2 == s3) System.out.println(\"s2과 s3 주소값이 같음\");&gt; if(s3 == s4) System.out.println(\"s3과 s4 주소값이 같음\");&gt; if(s5 == s1) System.out.println(\"s5과 s1 주소값이 같음\");&gt; if(s1.equals(s2)) System.out.println(\"s1과 s2 객체 내용이 같음\");&gt; if(s1.equals(s3)) System.out.println(\"s1과 s2 객체 내용이 같음\");&gt; &#125;&gt; 콘솔은 s3과 s4 주소값이 같음 s5과 s1 주소값이 같음 s1과 s2 객체 내용이 같음 s1과 s2 객체 내용이 같음 복습 끝내고 수업 시작클래스와 데이터 타입 클래스의 용도 데이터 타입 만들기 오늘의 첫 과제는 여기 처음에 혼자 코딩했을 때 이렇게 했는데, 에러가 났다. 1234567891011121314151617public class App &#123; public static void main(String[] args) &#123; Scanner keyboard = new Scanner(System.in); final int LENGTH = 10; Lesson[] lesson = new Lesson[LENGTH]; // 클래스는 잘 정의했음 int i = 0; while (i &lt; LENGTH) &#123; System.out.print(\"번호? \"); lesson[i].no = Integer.parseInt(keyboard.nextLine()); (중략) &#125; &#125;&#125; 이렇게 하면 nullpointerException이 뜬다. 현재 객체 생성이 되지 않았음! 때문에 while 문 안에서 객체를 생성해주면서 해당 방에 넣어줘야 함 답은 이것 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.sql.Date;import java.util.Scanner;public class App &#123; public static void main(String[] args) &#123; Scanner keyboard = new Scanner(System.in); final int LENGTH = 10; Lesson[] lessons = new Lesson[LENGTH]; int i = 0; while (i &lt; LENGTH) &#123; // 클래스로 정의한 새 데이터 타입의 메모리(인스턴스) 만들기 Lesson lesson = new Lesson(); // 사용자가 입력한 값을 메모리에 담는다. System.out.print(\"번호? \"); lesson.no = Integer.parseInt(keyboard.nextLine()); System.out.print(\"수업명? \"); lesson.title = keyboard.nextLine(); System.out.print(\"설명? \"); lesson.contents = keyboard.nextLine(); System.out.print(\"시작일? \"); lesson.startDate = Date.valueOf(keyboard.nextLine()); System.out.print(\"종료일? \"); lesson.endDate = Date.valueOf(keyboard.nextLine()); System.out.print(\"총수업시간? \"); lesson.totalHours = Integer.parseInt(keyboard.nextLine()); System.out.print(\"일수업시간? \"); lesson.dayHours = Integer.parseInt(keyboard.nextLine()); // i 번째 배열에 수업 정보를 담고 있는 Lesson 객체(의 주소)를 보관한다. lessons[i] = lesson; i++; System.out.print(\"\\n계속 입력하시겠습니까?(Y/n) \"); String answer = keyboard.nextLine().toLowerCase(); if (!answer.equals(\"y\") &amp;&amp; answer.length() &gt; 0) &#123; break; &#125; System.out.println(); &#125; keyboard.close(); System.out.println(); // 빈 줄 출력 for (int j = 0; j &lt; i; j++) &#123; System.out.printf(\"%3d, %-15s, %10s ~ %10s, %4d\\n\", lessons[j].no, lessons[j].title, lessons[j].startDate, lessons[j].endDate, lessons[j].totalHours); &#125; &#125;&#125; 그 외 분기문, 조건문 통합 과제 메서드의 존재 이유를 알아보는 과제(..)쉽게 말해 유지 보수가 쉽도록 만듦 12345678910111213141516171819202122232425262728public class App &#123; static Lesson[] lessons; final static int LENGTH = 10; static int lessonIdx = 0; static Scanner keyboard; // static 메서드에서 접근이 안되기 때문에 모두 클래스 변수로 만든 것 static void addLession() &#123; (중략) &#125; public static void main(String[] args) &#123; keyboard = new Scanner(System.in); lessons = new Lesson[LENGTH]; boards = new Board[LENGTH]; while (true) &#123; System.out.print(\"명령&gt; \"); String command = keyboard.nextLine().toLowerCase(); // 사실 이 2줄의 코드도 메서드로 뺄 수 있다! if (command.equals(\"/lesson/add\")) &#123; addLession(); &#125; (중략) &#125; &#125;&#125; 클래스를 활용하여 메서드 분류 Low Coupling 낮은 결합도 한 클래스는 최대한 적은 클래스를 의존해야 한다. High Cohesion 높은 응집도 한 클래스는 하나의 역할만을 담당한다. 패키지를 사용해 클래스 분류 도메인 : dto, vo, 사용자 정의 데이터 타입 접근 제한자 privatge : 같은 클래스 내에서 접근 가능 default : 같은 패키지 내에서 접근 가능 protected : 같은 패키지 내에서 접근이 가능하고 해당 클래스를 상속 받은 자식 클래스의 경우 접근 가능 public : 누구나 접근 가능 접근 제어자(modifier) 본래 성질을 변경시키는 것 ex : 접근 제한자, static, final 등 클래스 변수와 클래스 메서드의 한계, 인스턴스 변수와 인스턴스 메서드가 필요한 이유 클래스 변수와 인스턴스 변수의 할당 변수 선언은 클래스 로딩이 안된다 클래스 로딩은 단 한 번만 된다. 때문에 클래스 변수는 한 개가 만들어진다 : 클래스가 로딩될 때(클래스 멤버를 사용할 때) 최초 할당 12&gt; Class.forName();&gt; static 블럭 : 클래스가 최초 로딩될 때 실행됨, 즉 여러 번 클래스 멤버를 사용해도 한 번만 실행됨 1234&gt; static &#123;&gt; &gt; &#125;&gt; this : 인스턴스 메서드 내장 변수, 생략 가능 static 메서드에서 사용이 불가능함 this는 객체의 주소 getter, setter의 등장 인스턴스가 유효한 값을 갖도록 제어하기 위해, 변수에 직접 접근을 막으려 접근 제한자를 건다. 멤버 변수들 = 필드 멤버 변수의 이름 = 필드명 getter, setter = 프로퍼티 get, set을 떼고 소문자로 첫 문자를 변경한 것 = 프로퍼티명 필드명과 프로퍼티명은 다른 개념이다 getter만 구성된 경우 : read only property setter만 구성된 경우 : write only property 인스턴스 메서드 = message 라고 하기도 하며, 인스턴스를 다루는 연산자(operator)로 보기도 한다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-11-28 수업 내용 정리","slug":"2018-11-28","date":"2018-11-28T05:45:18.000Z","updated":"2018-12-07T05:37:04.466Z","comments":true,"path":"2018/11/28/2018-11-28/","link":"","permalink":"http://eunajjing.github.io/2018/11/28/2018-11-28/","excerpt":"","text":"2018-11-28 수업이클립스 프로젝트에 파란 느낌표가 있는 경우 동작하지 않는다. 설정 파일이 꼬여서 컴파일이 제대로 안될 가능성이 높다. 1gradle cleanEclipse 이클립스와 관련된 설정 파일이 모두 날라간다(폴더는 그대로 있는 경우도 있다) 자바 프로젝트 폴더 구성첫 날 했으므로 링크로 대체하지만 간단히 요약하자면 gradle init –type… 을 이용한다. build.gradle에서 이클립스 플러그인을 추가 이클립스 플러그인 설치 리터럴(literal), 변수(variables), 키보드 입력 사용 연습 과제1 해결 1234567891011121314151617181920212223242526272829303132333435public class App &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"번호?\"); int num = Integer.parseInt(scan.nextLine()); System.out.println(\"수업명?\"); String classTitle = scan.nextLine(); System.out.println(\"수업내용?\"); String classContent = scan.nextLine(); System.out.println(\"시작일?\"); Date classStartDate = Date.valueOf(scan.nextLine()); // sql date 클래스를 이용했다. // Date.valueOf()는 String으로 들어온 값을 date 객체로 만들어주는 것 System.out.println(\"종료일?\"); Date classEndDate = Date.valueOf(scan.nextLine()); // int month = classEndDate.getMonth(); // 이렇게도 된다. System.out.println(\"총수업시간?\"); int totalClassTime = Integer.parseInt(scan.nextLine()); System.out.println(\"일수업시간?\"); int dayClassTime = Integer.parseInt(scan.nextLine()); System.out.println(\"번호 : \"+num); // System.out.printf(\"번호: %s\\n\", args); // 이스케이프 명령어 : 문자열 안에 삽입되는 명령어 System.out.println(\"수업명 : \"+classTitle); System.out.println(\"수업내용 : \"+classContent); System.out.println(\"기간 : \"+classStartDate+\" ~ \"+classEndDate); System.out.println(\"총수업시간 : \"+totalClassTime+\" 시간\"); // System.out.printf(\"총수업시간 : %d\\n 시간\", args); System.out.println(\"일수업시간 : \"+dayClassTime+\" 시간\"); scan.close(); &#125;&#125; static 메서드와 인스턴스 메서드 인스턴스의 값을 다루면 static을 붙이면 안된다, 반드시 인스턴스 메서드로 만들어줘야 한다. 배열과 흐름제어문(분기, 반복)의 사용 과제1 해결 프로젝트 폴더를 기존 것을 복사해서 만들 때 settings.gradle에서 rootProject.name을 변경해준다 프로젝트 폴더로 이동해서 gradle eclipse를 재실행 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.sql.Date;import java.util.Scanner;public class App &#123; public static void main(String[] args) &#123; final int NUMBER = 20; int[] no = new int[NUMBER]; // 4byte 크기 메모리 100개를 heap(인스턴스들이 저장) // 배열은 모두 ref 변수(주소 변수) // 메서드 에리어 // stack (메인 쓰레드 것과... 쓰레드 각각 1개씩 만들어진다) String[] title = new String[NUMBER]; String[] contents = new String[NUMBER]; Date[] startDate = new Date[NUMBER]; Date[] endDate = new Date[NUMBER]; int[] totalHours = new int[NUMBER]; int[] dayHours = new int[NUMBER]; int len = 0; Scanner scan = new Scanner(System.in); for (int i = 0; i &lt; NUMBER ; i++) &#123; System.out.println(\"번호?\"); no[i] = Integer.parseInt(scan.nextLine()); System.out.println(\"수업명?\"); title[i] = scan.nextLine(); System.out.println(\"수업내용?\"); contents[i] = scan.nextLine(); System.out.println(\"시작일?\"); startDate[i] = Date.valueOf(scan.nextLine()); System.out.println(\"종료일?\"); endDate[i] = Date.valueOf(scan.nextLine()); System.out.println(\"총수업시간?\"); totalHours[i] = Integer.parseInt(scan.nextLine()); System.out.println(\"일수업시간?\"); dayHours[i] = Integer.parseInt(scan.nextLine()); len++; System.out.print(\"계속하시겠습니까?(Y/n)\"); String input = scan.nextLine(); if (input.equalsIgnoreCase(\"n\")) &#123; // 대소문자 가리지 않고 break; &#125; else &#123; continue; &#125; &#125; scan.close(); for (int j = 0; j &lt; len ; j++) &#123; System.out.println(no[j]+\",\"+title[j]+\",\"+contents[j]+\",\" +startDate[j]+\"~\"+endDate[j]+\",\"+totalHours[j]+\",\"+dayHours[j]); &#125; &#125;&#125;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"깃 연습","slug":"git","date":"2018-11-28T00:09:18.000Z","updated":"2018-12-07T05:39:07.515Z","comments":true,"path":"2018/11/28/git/","link":"","permalink":"http://eunajjing.github.io/2018/11/28/git/","excerpt":"","text":"Git 기본 사용법버전 관리 시스템(VCS; Version Control System)이란? 개요 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다. 파일 별로 이전 상태로 되돌리거나 프로젝트 통째로 이전 상태로 되돌릴 수 있다. 시간에 따라 수정 내용을 비교해 볼 수 있다. 누가 문제를 일으켰는지 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. 종류 로컬 버전 관리 시스템 간단한 데이터베이스를 이용하여 파일에서 변경되는 부분(patch set)을 관리한다. 예) RCS(Revision Control System), 이클립스 중앙집중식 버전 관리 파일의 마지막 스냅샷만 받는다(checkout). 스냅샷(snapshot)? 특정 시점의 파일 버전을 기록한 것. 만약 서버에 문제가 생기면 모든 변경 내력(history)을 잃는다. 예) CVS, Subversion, Perforce 등 CVS 개발자 A의 PC에 프로젝트를 하나 만든들어 체크인(서버에 올린다)한다. 다른 개발자 B가 이를 체크아웃(복사)하여 작업을 한다. 작업이 끝난 B는 이를 다시 서버에 올린다. 이 때 파일의 전체가 올라간다. 때문에 네트워크의 오버헤드가 발생한다. subversion CVS의 단점을 해결하기 위해 등장한 것으로, 변경된 것만 서버에 올린다. 변경 기록은 모두 서버에 있다.로컬에 없다, 로컬은 단순한 작업 디렉토리때문에 서버가 장애가 발생했을 경우 변경 기록이 모두 유실된다. 분산 버전 관리 시스템 저장소 전부를 복제한다. 변경 내력(history)까지 모두 복제한다. 예) Git, Mercurial, Bazaar, Darcs 등 Git리눅스 커널 관리를 위해 리누스 토발즈 및 리눅스 개발 커뮤니티에서 개발하였다. 2005년 4월에 개발을 시작하여 2005년 7월 11일에 첫 버전을 출시하였다. 목표 빠른 속도 단순한 구조 수천 개의 동시다발적인 브랜치가 가능한 비선형적인 구조 완벽한 분산 대형 프로젝트에서도 유용할 것 Git의 파일 상태Git은 다음 세가지 상태로 파일을 관리한다. Committed 로컬 데이터베이스에 안전하게 저장되었다는 뜻이다. Modified 파일이 변경되었지만 아직 로컬 데이터베이스에 저장되지 않았다는 뜻이다. Staged 로컬 데이터베이스에 저장할 파일임을 표시했다는 뜻이다. 다음에 커밋을 수행할 때 Staged로 표시된 파일의 변경 내용이 저장될 것이다. Git 프로젝트의 단계Git 프로젝트는 다음 세 가지 단계로 관리된다. .git Directory 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳. 즉 변경 내력과 그 내용이 저장된다. 원격 저장소를 clone 할 때 생성됨. Working Directory 특정 버전을 체크아웃(checkout)하면, .git 디렉토리에 있는 압축된 데이터베이스에서 파일을 가져와서 작업 디렉토리를 만든다. Staging Area .git 디렉토리에 존재하는 단순한 파일이다. commit 할 파일의 정보(스냅샷이라 부른다)를 담고 있다. git commit을 실행하면 이 스냅샷에 기록된 파일을 저장소에 보관하는 것이다. 커밋을 한 후에는 Staging Area는 새 스냅샷을 준비한다. Staging Area는 인덱스라는 이름으로도 부르지만, Staging Area 가 표준 이름으로 사용되는 추세이다. Git 파일의 상태 변화다음은 Git 명령에 따른 파일의 상태 변화를 보여준다. 123456789 Working Directory | Staging Area | .git Directory(Repository)[Untracked] [Unmodified] [Modified]|[ Staged ]|[ Committed ] -----------------------------------|--------------|--------------------------- +-------------------------------------&gt;&gt; : git add +-----------&gt;&gt; : git add +-------------&gt;&gt; : git commit &lt;&lt;-----------------------+ +----------&gt;&gt; : 파일 편집 &lt;&lt;------------+ : 파일 삭제 Untracked - 작업 디렉토리에 새로 파일을 추가한 경우. 아직 스냅샷이나 Staging Area에 등록되지 않은 파일. 즉 git의 버전 관리 대상이 아닌 상태. Unmodified - 마지막 커밋(commit) 이후에 아무것도 수정하지 않은 상태. Modified - 파일의 내용을 변경한 상태. Staged - 다음 커밋에서 저장하도록 Staging Area에 등록되고 표시된 상태. Git 명령다음은 콘솔에서 git 명령을 사용하는 방법이다. git config git의 사용 환경을 설정한다. /etc/gitconfig 설정 파일 시스템의 모든 사용자와 모든 저장소에 적용되는 설정. git config --system 옵션으로 이 파일을 읽고 쓴다. Windows OS의 경로 - C:/ProgramData/Git/config ~/.gitconfig, ~/.config/git/config 설정 파일 특정 사용자만 적용되는 설정. git config --global 옵션으로 이 파일을 읽고 쓴다. Windows OS의 경로 - C:/Users/사용자홈/.gitconfig .git/config 특정 저장소에만 적용되는 설정. git config 옵션을 지정하지 않으면 이 파일을 읽고 쓸 수 있다. 123예1) 사용자 이름 설정하기$ git config --global user.name &quot;Jinyoung Eom&quot;$ git config --global user.email &quot;jinyoung.eom@gmail.com&quot; 12예2) 기본 텍스트 편집기 설정하기$ git config --global core.editor emacs 12예3) 설정 확인하기$ git config --list 12예4) 특정 값 확인하기$ git config user.name git help [명령], git [명령] –help 명령어에 대한 도움말을 볼 수 있다. 123예1) config 명령에 대한 도움말 보기$ git help config$ git config --help git init 존재하는 폴더를 깃 저장소로 만든다. .git 폴더를 생성한다. 깃 저장소 관련 파일을 두는 폴더이다. 12예) ~/git/myProject 폴더를 깃 저장소로 설정하기~/git/myProject$ git init .gitignore Git으로 관리하지 않을 파일을 지정한다. 예를 들면 로그 파일(.log)이나 빌드 도구가 자동으로 생성한 파일 또는 디렉토리 등. 패턴을 사용하여 Git이 무시할 파일을 지정한다. 빈 줄이나 #으로 시작하는 줄은 주석으로 간주한다. 표준 Glob 패턴을 사용한다. /로 시작하면 하위 디렉토리에 적용되지 않는다. 디렉토리는 끝에 /을 붙인다. !로 시작하는 파일은 무시하지 않는다. 1234567891011121314151617181920212223242526예1) 주석을 표시하는 방법#이것은 주석입니다. 또는 빈 줄.예2) bin/ 디렉토리를 통째로 무시하기bin/예3) 현재 디렉토리의 *.log 파일만 무시하기. src/*.log처럼 기타 하위 디렉토리에 있는 *.log 파일은 포함하기/*.log예4) src/*.class 파일은 무시하고, src/main/*.class 파일은 포함하기src/*.class예5) src 디렉토리 및 그 하위 디렉토리에 있는 *.class 파일 무시하기src/**/*.class예6) 현재 디렉토리 및 그 하위 디렉토리에 있는 모든 *.log 파일 무시하기*.log예7) 확장자가 &apos;.o&apos; 또는 &apos;.a&apos;인 파일 무시하기*.[oa]예8) *~파일명이 ~로 끝나는 파일예9) 만약 *.log 파일을 무시한다면, cotext.log 파일은 무시하지 않고 포함하기!context.log git clone [url][폴더] url로 지정한 서버의 저장소를 로컬로 복제한다. 폴더 이름을 지정하지 않으면 저장소 이름으로 폴더를 만들어 복제한다. 폴더 이름을 지정하면 그 이름으로 폴더를 만들어 복제한다. 12예1) github.com의 저장소를 로컬에 복제하기$ git clone https://github.com/eomjinyoung/myProject 12예2) github.com의 저장소를 myProject2라는 이름으로 폴더를 만들어 로컬에 복제하기$ git clone https://github.com/eomjinyoung/myProject myProject2 git add [파일] 작업 디렉토리에 새로 추가한 파일인 경우 Staging Area에 새로 추가된 파일임을 기록한다. 변경한 파일인 경우 Staging Area에 변경된 파일임을 기록한다. 이렇게 Stating Area에 기록된 파일은 한 스냅샷으로 묶이며 커밋할 때 이 스냅샷의 파일들이 저장소에 보관된다. Staging Area에 기록된 파일은 Staged 상태가 된다. 12예1) 현재 폴더에서 확장자가 c인 파일을 Staging Area에 기록하기$ git add *.c 12예2) 현재 폴더에서 LICENSE 이름을 가진 파일을 Staging Area에 기록하기$ git add LICENSE 12예3) 현재 폴더나 하위 폴더의 파일 중에 변경되거나 추가된 파일을 Staging Area에 기록하기$ git add . git commit -m ‘이번 스냅샷을 저장하는 이유’ Staging Area에 기록된 파일들(스냅샷)을 로컬 저장소에 보관한다. 파일을 새로 추가하거나 변경하였다면 반드시 git add를 실행하여 Staging Area에 기록해야 한다. 기록되어 있지 않은 파일이나 변경 사항은 저장소에 보관되지 않는다. 커밋 할 때 마다 스냅샷에 대해 새 체크섬(checksum) 값이 부여되고 이 값이 스냅샷을 구분하는 식별자로 사용된다. 12예1) Staging Area에 있는 파일을 저장소에 보관하기$ git commit -m &apos;첫 번째 버전&apos; 123456예2) git add + git commit = git commit -a -m &apos;설명&apos; 저장소에 넣기 전에 매번 Staging Area에 기록하는 것은 매우 귀찮은 일이다. 이를 한 번에 할 수 있다. 단 Tracked 파일(Staging Area에 있거나 저장소에 있는 파일)만 대상으로 한다. 새로 추가한 파일 중에 아직 staged 상태가 아닌 파일은 제외한다.$ git commit -a -m &apos;바로 저장소로 보관하기&apos; git status 작업 파일의 상태를 조회한다. 1234567891011121314151617181920212223예1) 현재 작업 디렉토리의 파일 상태 보기$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: src/main/webapp/test02.html modified: src/main/webapp/test03.html new file: src/main/webapp/test05.htmlChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: src/main/webapp/index.html modified: src/main/webapp/test01.htmlUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) src/main/webapp/test05.html 12345678예2) 현재 작업 디렉토리의 파일 상태를 짤막하게 보기$ git status --short M src/main/webapp/test01.htmlM src/main/webapp/test02.htmlMM src/main/webapp/test03.html?? src/main/webapp/test04.htmlA src/main/webapp/test05.htmlAM src/main/webapp/test06.html [출력 결과 보는 법] [Staged 상태][Unstaged 상태] [파일 경로] _M src/main/webapp/index.html 작업 디렉토리에 있는 파일을 변경한 경우. M_ src/main/webapp/test01.html 작업 디렉토리에 있는 파일을 변경한 후,‘git add’ 명령으로 Stated 상태로 만든 경우. MM src/main/webapp/test02.html Staged 상태의 파일을 다시 변경한 경우. ?? src/main/webapp/test03.html 작업 디렉토리에 새로 파일을 추가한 경우. A_ src/main/webapp/test04.html 새로 추가한 파일을 ‘git add’ 명령으로 Stating Area에 등록한 경우. AM src/main/webapp/test05.html 새로 추가한 파일을 Staged 상태로 만든 후, 다시 변경한 경우. git diff [옵션] 파일의 변경 내용을 비교한다. 123456789101112131415161718192021예1) 작업 디렉토리에서 변경한 파일과 Staging Area에 등록된 파일과 비교하여 변경경 전/후를 출력하기 $ git diffdiff --git a/src/main/webapp/test01.html b/src/main/webapp/test01.htmlindex 80ba906..3322e11 100644--- a/src/main/webapp/test01.html+++ b/src/main/webapp/test01.html@@ -8,6 +8,6 @@ &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;main.css&quot; /&gt; &lt;/head&gt; &lt;body&gt;-&lt;h1&gt;Hello!&lt;/h1&gt; +&lt;h1&gt;Hello!x&lt;/h1&gt; &lt;/body&gt;-&lt;/html&gt;\\ No newline at end of file+&lt;/html&gt;diff --git a/src/main/webapp/test03.html b/src/main/webapp/test03.htmlindex 37f2fb7..57c25bf 100644... 123예2) 특정 파일에 대해 변경 전/후를 비교하기$ git diff src/main/webapp/test01.html... 123456789101112131415161718예3) Staging Area에 있는 파일과 저장소에 있는 파일을 비교하기 이 경우 새로 추가한 파일도 보여준다. --staged 와 --cached 는 같은 옵션이다.$ git diff --staged 또는 git diff --cacheddiff --git a/src/main/webapp/test02.html b/src/main/webapp/test02.htmlindex 53e43f2..2f411f8 100644...diff --git a/src/main/webapp/test03.html b/src/main/webapp/test03.htmlindex 53e43f2..2f411f8 100644...diff --git a/src/main/webapp/test05.html b/src/main/webapp/test05.htmlnew file mode 100644 &lt;=== 새 파일이 Staging Area에 있는 경우에 이 문구가 붙는다. index 0000000..3081b8d...diff --git a/src/main/webapp/test06.html b/src/main/webapp/test06.htmlnew file mode 100644 &lt;=== 새 파일이 Staging Area에 있는 경우에 이 문구가 붙는다.index 0000000..3081b8d... git checkout [파일] 작업 디렉토리의 파일을 변경한 후 변경 전으로 되돌릴 때 사용한다. Staging Area에 마지막으로 기록된 버전으로 되돌린다. git add를 수행한 적이 없다면 Staging Area에는 마지막으로 커밋한 파일을 가리킨다. 따라서 마지막으로 커밋된 파일로 되돌릴 것이다. 최후에는 저장소에 있는 것을 가져온다. 12예) src/main/webapp/index.html 파일을 편집 전으로 되돌리기$ git checkout src/main/webapp/index.html git rm [파일] Staging Area의 기록에서 지정된 파일을 뺀다. 작업 디렉토리에 해당 파일이 있다면 그 파일도 자동 삭제된다. 이전 스냅샷에는 해당 파일이 계속 남아 있다. 잘 사용하지 않는다… 123456예1) 작업 디렉토리에 있는 파일을 삭제한 후 Git에서도 제거하기$ rm test01.html &lt;=== 작업 디렉토리에서 파일을 삭제한다.$ git rm test01.html &lt;=== Staging Area에 삭제 파일 정보를 등록한다. &apos;rm&apos; 대신 &apos;add&apos;를 사용하여 삭제된 파일을 표시해도 된다. 예) git add test01.html$ git commit &lt;=== 저장소에서 Staging Area의 정보에 따라 1234예2) 변경한 파일이나 Staging Area에 이미 기록된 파일을 강제로 제거하기$ git rm -f test01.html &lt;=== 변경된 내용을 버리고 현재 스냅샷에서 빼버린다. &lt;=== 변경한 파일이 Staging Area에 기록되었더라도 변경된 내용을 버리고 스냅샷에서 빼버린다. git mv [기존파일명][새파일명] 파일 이름을 변경한다. 1234예1) test01.html 파일의 이름을 test02.html로 변경하기$ mv test01.html test02.html$ git rm test01.html$ git add test02.html 123예2) test01.html 파일의 이름을 test02.html로 변경하기 II 위 작업을 좀 더 쉽게 다음과 같이 단축으로 처리할 수 있다. $ git mv test01.html test02.html git log Git 저장소의 변경 내력을 조회한다. 1234567891011121314예1) 저장소의 변경 내력을 최신 커밋 순으로 출력하기$ git log...commit 80e779cf97f2b8857b1fd4e3796a612470255852 &lt;=== 커밋 체크섬Author: eomjinyoung &lt;jinyoung.eom@gmail.com&gt; &lt;=== 커밋한 사람의 이름과 이메일Date: Tue Aug 21 10:04:49 2018 +0900 &lt;=== 커밋한 날짜 ok &lt;=== 커밋할 때 입력한 내용commit d89524011f2c873fedca8643fa2cb95e02cb6656Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Tue Aug 21 09:35:48 2018 +0900 Initial commit 123456789101112131415161718192021예2) 저장소의 변경 내력을 최신 커밋 순서로 출력하는데 최근 두 개의 결과만 출력하기(-2 옵션) 각 커밋의 변경 내용을 보여주기(-p 옵션)$ git log -p -2commit cc898de0b9ea138f554aeb59910b348cb34850f4 (HEAD -&gt; master)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 19:55:21 2018 +0900 p 태그 추가diff --git a/src/main/webapp/ex03.html b/src/main/webapp/ex03.htmlindex 0afb588..c0e04ec 100644--- a/src/main/webapp/ex03.html+++ b/src/main/webapp/ex03.html@@ -5,5 +5,6 @@ &lt;/head&gt; &lt;body&gt; &lt;h1&gt;테스트&lt;/h1&gt;+&lt;p&gt;내용 추가&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;... 123456789101112예3) 저장소에 대한 각 커밋의 통계 정보를 조회한다.$ git log ---stat...commit c555b1b128453d18ac2a5d3493b79021dce3f470Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 19:54:50 2018 +0900 HTML 내용 변경 src/main/webapp/ex03.html | 6 ++++-- &lt;=== 어떤 파일의 추가되거나 삭제된 줄 수 1 file changed, 4 insertions(+), 2 deletions(-) &lt;=== 요약 정보... 12345678910111213141516171819예4) 추가되거나 삭제된 내용 중에 &apos;&lt;p&gt;&apos; 문구를 포함한 정보 조회$ git log -p -S &apos;&lt;p&gt;&apos;commit cc898de0b9ea138f554aeb59910b348cb34850f4 (HEAD -&gt; master)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 19:55:21 2018 +0900 p 태그 추가diff --git a/src/main/webapp/ex03.html b/src/main/webapp/ex03.htmlindex 0afb588..c0e04ec 100644--- a/src/main/webapp/ex03.html+++ b/src/main/webapp/ex03.html@@ -5,5 +5,6 @@ &lt;/head&gt; &lt;body&gt; &lt;h1&gt;테스트&lt;/h1&gt;+&lt;p&gt;내용 추가&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; git commit –amend 마지막 커밋을 다시 현재의 Staging Area의 내용으로 덮어쓴다. 그래서 커밋 완료 후 빠뜨린 파일이 있거나 제거하지 못한 파일이 있을 경우 사용한다. 마지막 커밋 후에 변경 사항이 없다면 단지 커밋 메시지만 변경한다. 이전 커밋을 덮어쓰는 것이지만 커밋의 체크섬은 새로 발급된다. 12345예1) ex03.html을 변경한 후 커밋한다. 그 후에 다시 ex04.html을 변경한 후 이전 커밋과 합친다. $ git add ex03.html$ git commit -m &apos;ex03 변경&apos;$ git add ex04.html$ git commit --amend -m &apos;ex03 및 ex04 변경&apos; git reset HEAD [파일] 커밋 버전을 취소하는 것 git add를 실행하면 Staging Area에 해당 파일이 기록되어 커밋할 스냅샷으로 묶인다. 스냅샷으로 묶인 파일들은 커밋할 때 저장소에 그 변경 내용이 보관된다. Staging Area의 현재 스냅샷에서 빼고 싶은 파일이 있다면 이 명령을 사용한다. 이 명령을 수행하면 변경된 상태이지만 아직 Staging Area의 현재 스냅샷에 포함되지 않은 파일이 된다. 123456예1) &apos;ex03.html&apos;과 &apos;ex04.html&apos; 파일을 변경한 후 Staging Area에 넣기$ git add ex03.html ex04.htmlStaging Area에 넣은 두 개 파일 중에서 ex03.html은 제외하기 $ git reset HEAD ex03.html git revert 직전 버전의 것만 제거할 때 1git revert head 그런데 직전 버전이 아닌 과거의 버전으로 돌리고자 할 때12&gt; git revert 커밋아이디&gt; 를 cmd에 치면 12345&gt; error: could not revert 커밋아이디... &apos;커밋메시지&apos;&gt; hint: after resolving the conflicts, mark the corrected paths&gt; hint: with &apos;git add &lt;paths&gt;&apos; or &apos;git rm &lt;paths&gt;&apos;&gt; hint: and commit the result with &apos;git commit&apos;&gt; 에러 발생하고, 파일을 열게 되면 12345678&gt; &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&gt; 11111&gt; 33333&gt; 22222&gt; =======&gt; 11111&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of c088056... &apos;22222&apos;&gt; head부터 내가 쓴 것, ======는 돌리려고 했던 것의 부모 git remote 현재 프로젝트에 등록된 원격 저장소를 확인하거나 추가한다. git clone [url]으로 원격 저장소를 복제하면 원격 저장소가 origin 이라는 이름으로 자동 등록된다. 서버를 가리키는 포인터 123예1) 원격 저장소의 이름을 알아내기$ git remoteorigin 1234예2) 원격 저장소의 이름 뿐만아니라 URL도 알아내기$ git remote -vorigin https://github.com/eomjinyoung/test.git (fetch)origin https://github.com/eomjinyoung/test.git (push) 1234567예3) 원격 저장소 추가하기$ git remote add [단축이름] [URL]$ git remote add cs https://github.com/eomcs/test.gitorigin https://github.com/eomjinyoung/test.git (fetch)origin https://github.com/eomjinyoung/test.git (push)cs https://github.com/eomcs/test.git (fetch)cs https://github.com/eomcs/test.git (push) 12345678910111213예4) 원격 저장소의 정보를 조회하기$ git remote show [원격 저장소 이름]$ git remote show origin* remote origin Fetch URL: https://github.com/eomjinyoung/test.git Push URL: https://github.com/eomjinyoung/test.git HEAD branch: master Remote branch: &lt;=== 로컬 저장소와 연결된 원격 저장소의 브랜치 master tracked Local branch configured for &apos;git pull&apos;: &lt;=== git pull 했을 때 merge 할 master merges with remote master 원격 저장소의 브랜치와 로컬 저장소의 브랜치 Local ref configured for &apos;git push&apos;: &lt;=== git push 했을 때 push 할 master pushes to master (up to date) 로컬 저장소의 브랜치와 원격 저장소의 브랜치 123456예5) 원격 저장소의 단축 이름을 변경하기$ git remote rename [현재 단축이름] [새 단축이름]$ git remote rename cs eomcs$ git remoteorigineomcs 12345678예6) 원격 저장소를 삭제하기 - 원격 저장소의 서버 정보가 변경되었을 때 - 별도의 복제가 필요하지 않을 때 - 기여자가 활동하지 않을 때 $ git remote rm [원격 저장소의 단축이름]$ git remote eomcs$ git remoteorigin git fetch [원격저장소이름] 로컬에는 없고 원격 저장소에만 있는 데이터를 모두 가져온다. 단 가져온 데이터를 로컬 파일에 자동으로 합치지는(merge) 않는다. 개발자가 직접 merge 해야 한다. 12예1) 원격 저장소에 마지막으로 push 한 다음에 변경된 모든 것을 가져오기$ git fetch origin git pull git pull = git fetch origin + Merge 즉 원격 저장소의 데이터를 가져온 후에 로컬 파일과 합친다. 원격 저장소를 clone 하게 되면 로컬 저장소에 master 브랜치가 생긴다. 로컬 저장소의 master 브랜치는 자동으로 원력 저장소의 master 브랜치를 추적한다. 따라서 원격 저장소에서 가져온 데이터를 로컬 저장소의 master 브랜치와 합쳐진다. 12예1) 원격 저장소의 파일을 가져와 로컬 저장소의 파일과 병합하기 $ git pull git push [원격 저장소 이름][로컬 브랜치 이름] 로컬 저장소 브랜치를 원격 저장소로 업로드(push) 한다. 전제 조건 원격 저장소에 쓰기 권한이 있어야 한다. 아직 다른 사람이 push 한 적이 없다. 다른 사람이 push 한 적이 있다면, 먼저 원격 저장소의 데이터를 가져와서 merge 한 다음에 push 해야 한다. 12예1) 로컬 저장소의 master 브랜치를 원격 저장소에 업로드 하기$ git push origin master git tag 존재하는 태그를 조회한다. 12345예1) 저장소에 존재하는 태그를 조회한다.$ git tagv0.1v0.2... 1234예2) 저장소에 있는 태그 중에서 v10.0 버전의 태그들만 검색하기$ git tag -l &apos;v10.0*&apos;v10.0.0.1v10.0.0.2 123456예3) 현재 저장소에 저장된 파일에 대해 태그 붙이기 - 마지막 커밋에 대해 태그를 붙인다. - 태그를 만든 사람의 이름과 이메일, 날짜, 메시지도 저장한다. - 이렇게 붙인 태그를 &apos;Annotated 태그&apos;라 부른다.$ git tag -a [태그명] -m &apos;태그 메시지&apos;$ git tag -a v0.1 -m &apos;my version 0.1&apos; 12345예4) 현재 저장소에 저장된 파일, 즉 마지막 커밋에 대해 태그 붙이기 - 태그에 대한 추가 정보를 입력하지 않는다. - 이렇게 붙인 태그를 Lightweight 태그&apos;라 부른다.$ git tag [태그명]$ git tag v0.2 1234567891011121314151617예5) 이전 커밋에 대해 태그 붙이기$ git tag -a [태그명] [커밋 체크섬]$ git log --pretty=oneline75ff5353c41f3a33de4a7da91887d0ecbc2cbca6 (HEAD -&gt; master, tag: v0.2) test..ok2e08e7f0c4a5d068dcc20148e7e7b007958bd3b05 (tag: v0.1, origin/master, origin/HEAD) test..ok7c239ac5c89bcca468cfd0f412bef104e25b071a okokbb4aad9f4c000851f950feefdca4874cfa830734 ex03 편집, ex04 편집5607c88f763a12557adb69442b054990a1487d4f ex03 편집d166310b5c4502fc820bbab960094911466745e4 ex03 편집, ex04 편집bfa6df7c89c245e750c7c59f3c6fb06dfa801a74 다시 커밋c555b1b128453d18ac2a5d3493b79021dce3f470 HTML 내용 변경...$ git tag -a v0.0.1 c555b1b1 -m &apos;my version 0.0.1&apos; &lt;=== 중복되지 않는다면, 체크섬의 앞쪽 일부 값만 지정해도 된다.$ git tagv0.0.1 &lt;=== 추가된 태그v0.1v0.2 12345678예6) 로컬 저장소에 있는 태그를 서버에 공유하기$ git push [원격저장소 단축이름] [태그 이름]$ git push origin v0.1Counting objects: 1, done.Writing objects: 100% (1/1), 166 bytes | 166.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0)To https://github.com/eomjinyoung/test.git * [new tag] v0.1 -&gt; v0.1 1234567891011예7) 원격 저장소에 없는 모든 로컬 저장소의 태그를 서버에 공유하기$ git push origin --tagsCounting objects: 7, done.Delta compression using up to 8 threads.Compressing objects: 100% (7/7), done.Writing objects: 100% (7/7), 658 bytes | 658.00 KiB/s, done.Total 7 (delta 3), reused 0 (delta 0)remote: Resolving deltas: 100% (3/3), completed with 3 local objects.To https://github.com/eomjinyoung/test.git * [new tag] v0.0.1 -&gt; v0.0.1 * [new tag] v0.2 -&gt; v0.2 git show [태그명] 태그 정보와 커밋 정보를 모두 확인한다. 1234567891011121314예1) 태그 v0.1의 정보와 커밋 정보를 확인하기$ git show v0.1tag v0.1Tagger: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt; &lt;=== 태그 붙인 사람 정보Date: Mon Aug 27 00:03:56 2018 +0900 &lt;=== 태그 붙인 날짜 my version 0.1 &lt;=== 태그 붙일 때 작성한 메시지commit e08e7f0c4a5d068dcc20148e7e7b007958bd3b05 (HEAD -&gt; master, tag: v0.1, origin/master, origin/HEAD)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 23:29:24 2018 +0900 test..ok... 12345678910예2) Lightweight 태그의 정보를 확인하기 - 태그를 저장할 때 메시지를 지정하지 않았으면 태그 정보가 출력되지 않는다.$ git show v0.2-lw &lt;=== 태그를 붙인 사람의 정보가 없다.commit 75ff5353c41f3a33de4a7da91887d0ecbc2cbca6 (HEAD -&gt; master, tag: v0.2)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Mon Aug 27 00:13:30 2018 +0900 test..ok2... git checkout -b [새브랜치명][태그명] 작업 디렉토리의 내용물을 특정 태그의 커밋 버전으로 바꾼다. 태그가 가리키는 커밋의 파일들을 가져오려면 브랜치를 생성해야 한다. 특정 태그가 붙은 커밋 버전으로 브랜치를 만들고 작업 디렉토리는 그 브랜치의 파일들로 바꾼다. 123예1) v0.1 태그가 붙은 커밋 파일들로 version2 라는 이름의 브랜치를 만들고 작업 디렉토리에 가져오기$ git checkout -b version2 v0.1Switched to a new branch &apos;version2&apos; &lt;=== 작업 디렉토리의 파일들이 변경된다. git config –global alias.별명 [원래명령어] 자주 사용하는 명령어에 대해 별명을 부여한다. 12345예1) status 명령과 status --short 대해 별명을 지정하기$ git config --global alias.st status$ git config --global alias.st2 &apos;status --short&apos;$ git st &lt;=== &apos;git status&apos; 와 같다.$ git st2 &lt;=== &apos;git status --short&apos; 와 같다. 12345예2) Git 별명을 이용하여 &apos;nano&apos; 편집기를 실행하기$ git config --global alias.별명 &apos;!실행파일명&apos;$ git config --global alias.nn &apos;!nano&apos;$ git nn [nano 편집기가 실행될 것이다.] $ git branch -vv b1 c2be10d [origin/b1] v1.3 b2 664dbb5 v3.1master 09fb339 [origin/master: ahead 2] v3.0 &lt;=== 로컬 브랜치가 커밋을 2개 앞서 있다는 의미other ed485e2 [origin/other] v1.2other2 ed485e2 [origin/other] v1.2 Git 브랜치 사용법커밋 정보Git에서 commit을 수행하면 다음의 절차에 따라 커밋 정보를 저장한다. git add 실행 Blob 생성 Git 저장소에 저장되는 파일이다. 각 파일은 SHA-1 해시 알고르즘으로 계산된 40바이트 크기의 고유의 체크섬(checksum) 값을 가진다. Staging Area에 Blob의 체크섬을 기록한다. git commit 실행 트리 객체 생성 디렉토리와 파일의 구조 정보가 들어 있다. 파일 정보는 Blob의 체크섬이다. 각 트리를 구분하기 위한 SHA-1 해시로 생성한 체크섬을 가진다. 커밋 객체 생성 작성자, 커미터, 커밋 메시지 등 메타 정보가 들어 있다. 트리 객체를 가리키는 정보가 들어 있다. 각 커밋을 식별하기 위한 SHA-1 해시로 생성한 체크섬을 가진다. 이전 커밋을 가리키기 위해 이전 커밋의 체크섬이 들어 있다. 이 모든 것들은 .git에 들어있다! 객체들 간의 관계 [커밋 객체]—-&gt; [트리 객체]—-&gt; [Blob 객체들] 브랜치 Git의 브랜치는 커밋 사이를 이동할 때 사용하는 포인터 같은 것이다. 커밋의 체크섬을 이용하여 여러 커밋들 중에서 한 커밋을 가리킨다. 즉 새 브랜치를 만드는 것은 단순히 41바이트(40바이트 체크섬 + 1바이트 줄 바꿈 문자)의 파일을 하나 만드는 것에 불과하다. 따라서 브랜치를 여러 개 만들어도 전혀 상관없다. Git은 브랜치를 만들어 작업하고 나중에 merge 하는 것을 권장한다. 하루에 수십 번씩 해도 괜찮다고 제안하고 있다. master 브랜치 git init를 통해 Git 저장소를 만들 때 ‘master’라는 이름으로 기본 브랜치를 생성한다. master 브랜치로 작업하는 동안에는 항상 가장 마지막 커밋을 가리킨다. HEAD 현재 작업 중인 로컬 브랜치(워킹 디렉토리)를 가리키는 특수한 포인터이다. 와일드 표시(*)가 붙는다. 토픽 브랜치 어떤 한가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치이다. 트래킹 브랜치 = upstream 브랜치 원격 브랜치를 체크아웃 하여 만든 로컬 브랜치이다. 트래킹 브랜치에서 git pull 을 실행하면 이 로컬 브랜치와 연결된 원격 브랜치에서 데이터를 받아 로컬 브랜치로 자동 merge 한다. 브랜치 명령git branch 브랜치를 관리한다. 12345678910예1) b1 이라는 이름으로 브랜치를 새로 만들기 git branch [새 브랜치 이름] - 새로 만든 브랜치도 지금 작업하고 있는 커밋을 가리킨다. - HEAD 포인터는 브랜치 생성과 상관없이 기존의 브랜치를 계속 가리킨다.$ git branch b1$ git log --oneline &lt;=== 커밋 정보를 한 줄 씩 출력한다.f559e21 (HEAD -&gt; master, b1) v0.35896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 123456예2) 브랜치 목록을 조회하기 git branch - 아무런 옵션 없이 실행하면 브랜치의 목록을 출력한다.$ git branch b1* master &lt;=== 현재 작업하는 브랜치에 * 가 붙는다. 12예3) 브랜치들 중에서 merge 한 브랜치를 조회하기$ git branch --merged 12예4) 브랜치들 중에서 merge 하지 않은 브랜치를 조회하기$ git branch --no-merged 1234567예5) 브랜치 삭제하기$ git branch -d b1 &lt;=== merge 되지 않은 브랜치는 삭제되지 않는다.error: The branch &apos;b1&apos; is not fully merged. If you are sure you want to delete it, run &apos;git branch -D b1&apos;.$ git branch -D b1 &lt;=== -D 옵션으로 merge 되지 않은 브랜치를 강제 삭제하라.Deleted branch b1 (was 519ee27). git checkout [브랜치 이름] HEAD 포인터가 다른 브랜치를 가리키게 한다. HEAD 포인터가 가리키는 브랜치가 바뀌면, 작업 디렉토리도 그 브랜치의 커밋 정보에 따라 바뀐다. 1234567예1) HEAD 포인터를 b1 브랜치로 옮긴다.$ git checkout b1$ git log --oneline &lt;=== 로그 정보를 확인해 보라.f559e21 (HEAD -&gt; b1, master) v0.3 &lt;=== HEAD는 b1을 가리키고 있다. 5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678910예2) test04.txt를 만들어 b1 브랜치에 추가하기 test04.txt 파일을 만들었다고 가정하자!$ git add test04.txt$ git commit -m &apos;v0.4&apos;$ git log --oneline9cf510e (HEAD -&gt; b1) v0.4 &lt;=== b1은 새로 커밋한 스냅샷을 가리킨다. HEAD는 현재 작업 브랜치인 b1을 가리킨다.f559e21 (master) v0.3 &lt;=== master가 가리키는 스냅샷은 변경되지 않는다. 5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 1234567891011예3) test05.txt를 만들어 b1 브랜치에 추가하기 test05.txt 파일을 만들었다고 가정하자!$ git add test05.txt$ git commit -m &apos;v0.5&apos;$ git log --oneline34fda9c (HEAD -&gt; b1) v0.5 &lt;=== b1은 새로 커밋한 스냅샷을 가리킨다. HEAD는 현재 작업 브랜치인 b1을 가리킨다.9cf510e v0.4 f559e21 (master) v0.3 &lt;=== master가 가리키는 스냅샷은 변경되지 않는다. 5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678예4) 작업할 브랜치를 b1에서 다시 master로 교체하기 브랜치를 교체한 후 작업 디렉토리를 확인해 보면, 다시 master가 가리키는 스냅샷으로 돌아 온 것을 확인할 수 있다.$ git checkout master$ git log --onelinef559e21 (HEAD -&gt; master) v0.3 &lt;=== 전체 스냅샷 중에서 master 브랜치와 연결된 스냅샷만 화면에 출력된다.5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678910예5) test06.txt를 만들어 master 브랜치에 추가하고 커밋 내력 확인하기 test06.txt 파일을 만들었다고 가정하자!$ git add test06.txt$ git commit -m &apos;v0.6&apos;$ git log --oneline6f4725e (HEAD -&gt; master) v0.6f559e21 v0.35896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678910예6) 현재 HEAD가 가리키는 브랜치의 역사 뿐만 아니라 다른 브랜치의 역사까지 출력하기$ git log --oneline --graph --all* 6f4725e (HEAD -&gt; master) v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit 123456789101112예7) 체크아웃 할 때 자동으로 새 브랜치를 만들기 &apos;git branch&apos; + &apos;git checkout&apos; = git checkout -b [새 브랜치 이름] $ git checkout -b b2$ git log --oneline --all --graph* 6f4725e (HEAD -&gt; b2, master) v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit 12345678910111213예8) 새로 만든 b2 브랜치에 test07.txt 파일을 추가하고 커밋하기$ git add test07.txt$ git commit -m &apos;v0.7&apos;$ git log --oneline --all --graph* 33c8c8d (HEAD -&gt; b2) v0.7* 6f4725e (master) v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit git merge [브랜치 이름] 현재 브랜치의 커밋에 다른 브랜치의 커밋 내용을 합친다. 123456789101112131415예1) 합치려는 브랜치가 현 브랜치 보다 Upstream(이후 버전)일 경우, 별도의 merge 과정이 필요없고, 해당 브랜치의 최신 버전의 커밋으로 이동한다. 이런 merge 방식을 &apos;fast forward&apos;라 부른다.$ git checkout master$ git merge b2$ git log --oneline --all --graph* 33c8c8d (HEAD -&gt; master, b2) v0.7 &lt;=== master가 b2가 가리키는 커밋으로 이동한다.* 6f4725e v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit 12345678910111213예2) 더 이상 필요없는 b2 브랜치를 삭제하기$ git branch -d b2$ git log --oneline --all --graph* 33c8c8d (HEAD -&gt; master) v0.7* 6f4725e v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit[~/git/git-test]$ 123456789101112131415161718192021222324252627282930예3) master 브랜치에 b1 브랜치 커밋 내용을 합치기$ git checkout master &lt;=== 현재 브랜치가 master가 아니라면 이 명령을 수행한다.$ git merge b1$ git log --oneline --all --graph* 58489d3 (HEAD -&gt; master) v0.8 &lt;=== master 브랜치에 b1 브랜치를 합친 새 커밋이 생성된다.|\\ | * 34fda9c (b1) v0.5| * 9cf510e v0.4* | 33c8c8d v0.7* | 6f4725e v0.6|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit더 이상 필요없는 b1 브랜치를 삭제하기$ git branch -d b1[~/git/git-test]$ git log --oneline --all --graph* 58489d3 (HEAD -&gt; master) v0.8|\\ | * 34fda9c v0.5| * 9cf510e v0.4* | 33c8c8d v0.7* | 6f4725e v0.6|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit git rebase [브랜치명] 지정한 브랜치에 현재 브랜치의 변경 내력을 순서대로 합친다. 작업 원리 두 브랜치가 갈라지기 전인 공통 커밋으로 이동한다. 공통 커밋 부터 현재 브랜치까지의 diff(변경 사항)를 차례로 만들어 임시 보관해 둔다. 현재 브랜치가 지정한 브랜치를 가리키게 한다. 임시 보관된 diff(변경 사항)을 차례로 적용한다. 특징 merge 보다 좀 더 깔끔한 history를 만든다. history가 선형이다. 모든 작업이 순서대로 진행된 것 처럼 보인다. 보통 원격 브랜치에 커밋을 깔금하게 적용하고 싶을 때 사용한다. rebase 브랜치의 변경 사항을 다른 브랜치에 순서대로 적용하면서 합친다. merge는 두 브랜치의 최종 결과만을 가지고 합친다. merge vs rebase 로컬 저장소에서 브랜치를 정리할 때 rebase를 사용한다. push로 공개한 커밋에 대해서는 rebase를 하지 말라! 되도록 merge를 사용하여 역사를 기록하고 후세에 남겨 교훈이 되게 하라. 12345678910111213141516171819202122232425262728293031323334353637383940414243예1) b1 브랜치를 master 브랜치에 합치기 현재 브랜치 내력을 조회한다.$ git log --oneline --graph --all* f9e2727 (HEAD -&gt; master) C1b1 브랜치를 만든다.$ git branch b1$ git log --oneline --graph --all* f9e2727 (HEAD -&gt; b1, master) C1파일을 변경한 후 커밋한다.$ git add .$ git commit -m &apos;C2&apos;$ git log --oneline --graph --all* 0ebbfb2 (HEAD -&gt; b1) C2* f9e2727 (master) C1master 브랜치로 옮긴 후 파일을 변경한 후 커밋한다.$ git checkout master$ git add .$ git commit -m &apos;C3&apos;$ git log --oneline --graph --all* 1df28eb (HEAD -&gt; master) C3| * 0ebbfb2 (b1) C2|/ * f9e2727 C1b1 브랜치로 옮긴 후 master 브랜치를 b1 브랜치쪽으로 rebase 한다.$ git checkout b1$ git rebase master$ git log --oneline --graph --all* 211448b (HEAD -&gt; b1) C2* 1df28eb (master) C3* f9e2727 C1master를 &apos;fast-forward&apos;로 merge 한다.$ git checkout master$ git merge b1$ git log --oneline --graph --all* 211448b (HEAD -&gt; master, b1) C2* 1df28eb C3* f9e2727 C1 1234567891011121314151617181920212223242526272829브랜치 history가 다음과 같다면,C1 --- C2 --- C3 master \\ C4 --- C5 --- C6 b1 \\ C7 --- C8 --- C9 b2예2) b2 브랜치를 master 브랜치와 연결하기 git rebase -onto [기준브랜치] [토픽 브랜치1] [토픽 브랜치2] - &apos;-onto&apos; 옵션을 사용하면 b2 브랜치로 체크아웃 할 필요없다. - &apos;토픽 브랜치1&apos;과 &apos;토픽 브랜치2&apos;의 공통 커밋 이후부터 &apos;토픽 브랜치2&apos;까지의 모든 변경 사항을 patch로 만들어서 &apos;기준 브랜치&apos;에 적용한다.$ git rebase -onto master b1 b2위 명령을 수행한 후 브랜치의 historyC1 --- C2 --- C3 master \\ \\ \\ C7&apos; --- C8&apos; --- C9&apos; b2 \\ C4 --- C5 --- C6 b1b2를 master에 합쳤으면 master에 대해 &apos;fast-forward&apos;를 수행한다.$ git checkout master$ git merge b2위 명령을 수행한 후 브랜치의 historyC1 --- C2 --- C3 --- C7&apos; --- C8&apos; --- C9&apos; master, b2 \\ C4 --- C5 --- C6 b1 123456789101112131415161718예3) 위의 상황에서 b1 브랜치를 master에 합치기 git rebase [기준 브랜치] [토픽 브랜치]$ git rebase master b1위 명령을 수행한 후 브랜치의 historyC1 --- C2 --- C3 --- C7&apos; --- C8&apos; --- C9&apos; --- C4&apos; --- C5&apos; --- C6&apos; | | master, b2 b1b1을 master에 합쳤으면 master에 대해 &apos;fast-forward&apos;를 수행한다.$ git checkout master$ git merge b1$ git branch -d b1 &lt;=== 필요없는 b1 브랜치 삭제$ git branch -d b2 &lt;=== 필요없는 b2 브랜치 삭제C1 --- C2 --- C3 --- C7&apos; --- C8&apos; --- C9&apos; --- C4&apos; --- C5&apos; --- C6&apos; | master 원격 브랜치 원격 브랜치는 원격 저장소에 있는 브랜치를 가리키는 레퍼런스(포인터) 이다. 원격 브랜치를 가리키는 형식 (remote)/(branch) 예) origin/master ‘git clone’ 명령을 수행하면 원격 저장소를 가리키는 이름으로 ‘origin’이 자동 부여된다. git clone -o [원격저장소이름] ‘-o’ 옵션을 이용하여 원격 저장소 이름을 지정하면 ‘origin’ 대신 지정한 이름이 부여된다. 1234예1) 원격 저장소의 이름을 &apos;orgin&apos; 대신 &apos;ohora&apos;라 짓기$ git clone -o ohora https://github.com/eomjinyoung/git-test$ git remoteohora git ls-remote 원격 레퍼런스(Refs)를 조회한다. 12345678910예1) 원격 저장소의 레퍼런스를 모두 출력하기 git ls-remote [원격 저장소 이름]$ git ls-remote &lt;=== 원격 저장소 이름을 생략하면 전체 출력From https://github.com/eomjinyoung/git-test.git9babde9de3ff3f9c979a8da0c9d65e008a13af31 HEAD9babde9de3ff3f9c979a8da0c9d65e008a13af31 refs/heads/master$ git ls-remote origin &lt;=== origin에 대한 것만 출력9babde9de3ff3f9c979a8da0c9d65e008a13af31 HEAD9babde9de3ff3f9c979a8da0c9d65e008a13af31 refs/heads/master git remote show [원격 저장소 이름] 원격 저장소에 대한 모든 브랜치와 정보를 조회한다. 12345678910111213예1) 원격 저장소의 브랜치 정보를 출력하기 git remote show [원격 저장소 이름]$ git remote show origin* remote origin Fetch URL: https://github.com/eomjinyoung/git-test.git Push URL: https://github.com/eomjinyoung/git-test.git HEAD branch: master Remote branch: master tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (local out of date) git fetch [원격 저장소 이름] 원격 저장소가 로컬 저장소에 없는 정보를 가지고 있다면 모두 가져온다. 그리고 origin/master 포인터를 최신 커밋으로 이동시킨다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556현재 로컬 저장소의 브랜치 및 커밋 역사가 다음과 같다고 가정하자.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- X1 --- X2 | | origin/master master현재 원격 저장소의 브랜치 및 커밋 역사가 다음과 같다고 가정하자.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- Y1 --- Y2 | master예1) 원격 저장소의 내용을 로컬 저장소로 가져온다.$ git fetch origin$ git log --oneline --graph --all* 9babde9 (origin/master, origin/HEAD) Y2* 440c0c1 Y1| * 82efd10 (HEAD -&gt; master) X2| * 4039833 X1|/ * b4dec77 C6* 66d6384 C5* 401d39d C4* 4859dd1 C3* 241b657 C2* 046ea07 C1즉 다음 그래프와 같이 커밋이 구성된다.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- X1 --- X2 \\ | \\ HEAD -&gt; master Y1 --- Y2 | origin/master예2) 원격에서 가져온 정보를 로컬 저장소에 merge하기 $ git merge 9babde9$ git log --oneline --graph --all* f5d2046 (HEAD -&gt; master) X3|\\ | * 9babde9 (origin/master, origin/HEAD) Y2| * 440c0c1 Y1* | 82efd10 X2* | 4039833 X1|/ * b4dec77 C6* 66d6384 C5* 401d39d C4* 4859dd1 C3* 241b657 C2* 046ea07 C1즉 다음 그래프와 같이 커밋이 구성된다.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- X1 --- X2 --- X3 HEAD -&gt; master \\ / --- Y1 --- Y2 --- | origin/master 1234예3) 원격 저장소의 정보를 가져와서 로컬 저장소와 합치기 git pull = git fetch + get merge - &apos;git pull&apos; 명령을 사용하면 더 간단히 처리할 수 있다.$ git pull 12예4) 모든 원격 저장소에서 데이터를 받아오기$ git fetch --all git push 로컬 저장소의 정보를 원격 저장소에 올린다. 로컬에서 생성한 브랜치를 원격 저장소에 올릴 수 있다. 원격 저장소의 브랜치를 삭제할 수 있다. 1234567891011예1) push를 사용하여 로컬 저장소의 정보를 원격 저장소에 올리기$ git push &lt;=== master를 origin/master로 올린다.$ git log --oneline --graph --all* f5d2046 (HEAD -&gt; master, origin/master, origin/HEAD) X3|\\ | * 9babde9 Y2| * 440c0c1 Y1* | 82efd10 X2* | 4039833 X1|/ * b4dec77 C6 12345예2) 로컬 저장소에 있는 &apos;b1&apos; 브랜치를 원격 저장소에 올리기 git push [원격 저장소 이름] [로컬 브랜치 이름] - 로컬 브랜치 이름과 같은 원격 브랜치가 없으면 새로 만든다. - 로컬 브랜치 정보를 원격 브랜치에 올린다.$ git push origin b1 1234예3) 로컬 저장소에 있는 &apos;b1&apos; 브랜치를 원격 저장소의 &apos;other&apos; 브랜치로 올리기 git push [원격 저장소 이름] [로컬 브랜치 이름]:[원격 브랜치 이름] - 로컬 브랜치 이름과 원격 브랜치 이름을 다를 때 유용하다.$ git push origin b1:other 123예3) 원격 저장소의 &apos;b1&apos; 브랜치를 삭제하기 git push [원격 저장소 이름] --delete [브랜치 이름]$ git push origin --delete b1 git checkout -b [로컬 브랜치][원격 저장소]/[원격 브랜치] 원격 저장소의 브랜치를 받아서 로컬 브랜치를 만든다. 1234예1) 원격 저장소의 origin/other 브랜치를 체그아웃 하여 other2 로컬 브랜치 만들기$ git checkout -b other2 origin/otherBranch &apos;other2&apos; set up to track remote branch &apos;other&apos; from &apos;origin&apos;.Switched to a new branch &apos;other2&apos; 123예2) 원격 저장소의 origin/other 브랜치를 체크아웃 하여 같은 이름으로 로컬 브랜치 만들기 - 같은 이름으로 만들 때는 --track 옵션을 사용한다.$ git checkout --track origin/other git branch -vv 트래킹 브랜치의 설정 정보를 조회한다. 출력 결과 ahead n : 로컬 브랜치가 커밋을 n 개 앞서 있다. 즉 로컬 브랜치에 커밋이 2개 더 있다는 의미. behind n : 원격 브랜치에서 로컬 브랜치로 merge 하지 않은 커밋이 n 개 있다는 의미. 123456$ git branch -vv b1 c2be10d [origin/b1] v1.3* b2 664dbb5 v3.1 master 09fb339 [origin/master: ahead 2] v3.0 &lt;=== 로컬 브랜치가 커밋을 2개 앞서 있다는 의미 other ed485e2 [origin/other] v1.2 other2 ed485e2 [origin/other] v1.2","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"설치한 것들, 설정 정리","slug":"181127","date":"2018-11-27T01:40:18.000Z","updated":"2018-12-07T05:37:43.435Z","comments":true,"path":"2018/11/27/181127/","link":"","permalink":"http://eunajjing.github.io/2018/11/27/181127/","excerpt":"","text":"web App는 was에서 실행됨 was의 종류 tomcat jboss webLogic webSphere JEUS(관공서 시스템의 대부분이 돌아감) was는 java를 기반으로 만들어졌기에 jvm이 필요함 때문에 open JDK(JRE가 포함되어 있음)를 설치 자바 EE라는 기술 명세가 있는데 이에 맞춰 구현될 수 있도록 하는 게 Java EE Implement라는 구현체 타 was와 달리 톰캣은 java EE와 관련된 기술 중 서블릿, jsp, jstl, el 등 웹 관련한 것만 지원 즉 서블릿, jsp는 모든 was에서 돌아가지만 ejb는 톰캣에서 돌아가지 않는다. 만약 ejb를 처리할 일이 있다면 스프링 프레임워크를 사용해 pojo로 처리하면 된다. html, css, java script를 기본으로 제이쿼리, 부트스트랩, 앵귤러, 뷰, 리액트, 엠버 등 응용 라이브러리 이용 응용 라이브러리를 쉽게 다운 받기 위해서 npm 이용 때문에 node 사용(npm을 이용해 라이브러리를 관리) 기술 서블릿 jsp sql jdbc - 대용으로 orl 사용 jstl, el 스프링 프레임워크 - IOC 컨테이너, 웹 mvc, aop 라이브러리 관리를 위한 Gradle 사용 마리아 db 이용 git IDE는 이클립스 사용 비주얼 스튜디오 코드 사용 패키지 매니저 역할로 scoop 사용 설치open jdk설치 경로-11버전- 설정 java_home 환경 변수 설정 시스템 설정 - 고급 시스템 설정 - 시스템 속성 - 환경변수로 java_home 생성 - JDK까지만 경로 알려주기 path 환경 변수 설정PATH 경로 맨 앞에 bin까지의 경로 복사, 세미콜론이나 콜론 찍어주기 설정 확인cmd에서 12345echo %java_home%// 결과로 jdk 경로가 출력되어야 정상javac -versionjava -version// 결과로 버전이 출력되어야 정상 비주얼 스튜디오 코드설치 경로 git client설치 경로, cmd 설정 확인cmd 창에서 12git --version// 버전이 뜨면 정상 이클립스공식 홈페이지에서 인스톨러를 다운 받고, update 진행 설정 워크스페이스 디렉토리 선택 preferences - General - Workspace - Text file endcodeing을 utf-8로 설정 preferences - General - Editors - Text Editors에서 tab width를 2로 하고tabs 대신 스페이스를 넣게끔 설정show print margin 선택-칼럼은 100show whitespace characters 체크show line numbers 체크(기본으로 체크되어 있음) java 11 버전을 지원하는 플러그인을 설치 (이클립스 마켓플레이스 이용)java - installed JREs에서 확인할 수 있음 JAVA - Code Style - Formatter에서 구글 스타일 xml import구글의 코드 스타일 가이드 java - compiler에서 level을 맞춰준다 web에서 css, html, jsp 인코딩을 utf-8로 맞춰준다 자바는 모든 것을 2byte-utf-8이 아닌 그의 원형인 유니코드를 쓴다-로 저장하므로, 외부로 내보낼 땐 utf-8-3byte-로 매번 변환시키는 작업이 필요하다. 톰캣공식홈페이지에서 다운로드 preferences - server - runtime Environment에서 다운로드 받은 톰캣 add Scoop 패키지 관리자 설치맥의 경우 homebrew scoop을 이용하기 위해서는 파워쉘이 일정 버전 이상(3 이상)이어야 하기에 윈도우 파워쉘(Windows PowrShell)의 버전을 확인​ 1Get-Host | Select-Object Version 파워쉘 업데이트 1scoop install curl net framework 배우다가 스쿱 다운로드 실패로 중단 gradle빌드 도구가 하는 역할 compile test (report도 만든다) 아카이브 (.jar, .war, .zip) deployment 기존에 많이 쓰던 ant의 경우 build.xml에 빌드 정보 설정 외부 라이브러리 자동 다운로드를 위해 메이븐 등장 build.xml이 pom.xml가 된다. 빌드 명령을 정교하게 작성하고 싶어짐 스크립트 언어로 자바 호환 언어인 groovy 이용 그레이드 등장, 그레이드의 경우 build.gradle에 빌드 정보 설정 그레이드는 메이븐과 호환이 된다. 그레이드 공홈에서 binary-only를 다운로드 환경변수 설정 필요 path 맨 앞에 bin까지의 경로 넣어주고, 세미콜론 찍으며 확인 cmd에서 확인 가능 12gradle --version// 버전이 제대로 떠야 정상 마리아 db공홈에서 다운로드 default instance properties 설정 시 utf-8로 설정해줘야 함 서비스에서 mysql에 maria db가 있는지 확인하고, 상태가 시작됨인지 확인 마리아 db bin 경로를 path 환경변수에 설정 cmd에서 확인 123456mysql -u root -p// 패스워드 입력하는 창 나오고, 입력하면// welcom 마리아 db 문구가 나오며 maria db 명령이 실행 준비됨show databases;// 가지고 있는 database를 보여준다 깃허브에 repo 준비 원격에 repo를 만든 뒤 로컬에 클론을 한다. 1git clone ~url~ 새로운 프로젝트를 만든다. 12gradle init --type java-application// 강의는 groovy로 진행되기에 1, junit을 쓸 예정이므로 1 입력함 ​ jsp를 만들 때 &lt;% %&gt; 사이에 자바를 넣듯, 특정 영역에 집어넣는 언어를 dsl(Domain-specific language)이라 한다. 완성된 폴더에는 샘플 소스도 들어가 있다. 1gradle build 컴파일을 자동으로 실행하며, 필요한 라이브러리를 알아서 다운로드한다. build라는 폴더가 생성된다. 1gradle run 왜인지 내가 했더니 에러가 났다… 그래서 다시 지우고 하니까 또 된다. 왜 에러가 났을까? 이클립스에서는 제대로 된 폴더 구조를 보여주지 않는다. 이를 해결하기 위해 이클립스에선 window에서 show view - navigator로 확인한다. 프로젝트는 그레이드로 만든다! 이후에 import를 이용해 existing projects into workspace로 불러온다. 이 때 파일은 옮겨지는 게 아니라, 그대로 있고 이클립스에서 만질 수 있도록만 만드는 것 이클립스의 파일들 .settings .classpath .project 이것들이 없으면 project를 찾을 수 없다고 뜬다. 때문에 그레이드에 자동으로 생성할 수 있는 기능을 이용한다. build.gradle ​ 1234567891011121314151617plugins &#123; id 'java' id 'application' id 'eclipse' // 이클립스가 읽을 수 있도록 플러그인을 장착 &#125;repositories &#123; jcenter() &#125;dependencies &#123; implementation 'com.google.guava:guava:26.0-jre' testImplementation 'junit:junit:4.12' &#125;mainClassName = 'bitcamp.newdeal.lms.App' 이후에 cmd에서 명령어 실행 12gradle eclipse// 이클립스 설정 파일을 만들기 시작 저장/변경/삭제 명단을 작성(stageing-area에 올린다)명단에 작성할 것이 있는가 12git add .// git 폴더의 하위 모든 요소를 검사해 스테이지에 올린다 로컬 저장소에 저장(snapshot)이 순간 로컬의 .git에 저장된다.저장하는 행위를 커밋이라 한다.​ 1git commit -m &quot;커밋 메시지&quot; 서버에 업로드, 푸시​ 1git push 깃허브 임시 비밀번호 만들기settings - Developer settings - personal access tokens에서 New personal access token 생성 후 보이는 토큰을 잘 보관하기 마치며오늘 만든 프로젝트(?)","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"hexo 블로그 404 에러 트러블슈팅","slug":"hexo_404_error","date":"2018-11-26T08:02:19.000Z","updated":"2018-12-07T09:48:31.210Z","comments":true,"path":"2018/11/26/hexo_404_error/","link":"","permalink":"http://eunajjing.github.io/2018/11/26/hexo_404_error/","excerpt":"","text":"매번 겪을 때마다 대환장해서 트러블 슈팅을 적기로 했다404의 서막hexo 블로그를 포스팅할 때마다, 어떤 포스팅은 제대로 잘 올라가는데 어떤 포스팅은 왜인지 에러가 났다. 내가 겪은 문제는 헥소 서버 상에서는 제대로 나오는데, 실 서버에서는 자꾸 404가 뜨는 경우였다. 그러니까 index까지는 제대로 나오는데, 해당 포스팅을 클릭하면 404가 뜬다. url로 들어가는 파라미터가 뭔가 이상하다고 생각해서, url을 뒤졌지만 무슨 일인지 알 수가 없었고. 재미있는 점은 직접 url을 타이핑해서 들어가면 제대로 페이지가 뜬다. 이게 무슨 일이야 왜 그런지 몰라서 매번 구글링을 하다가, 결국 어떤 이의 조언대로 마크다운 문서의 파일명을 바꾸는 식으로 문제를 해결해왔다. 참고했던 깃 이슈 하지만 인간은 망각의 동물이고, 나는 그 중에서도 망각에 두드러진 재능이 있는 이기 때문에 혹시 몰라 기록을 해둔다…. 저 이슈에 따르면 이 문제가 hexo의 문제가 아니라 github의 문제인 것 같다고 했다. 이미지 넣기이번 포스팅을 하다가, 실 서버에 올라온 이미지가 아니라 내가 가지고 있는 이미지를 블로그에 올리기 위해서 어떻게 해야하는지를 검색하게 되었고, 이것 또한 내가 잊을 게 뻔하기 때문에 함께 포스팅한다. 참고한 포스팅은 hexo 한국 공식 홈페이지","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"국비 교육 과정 수료 후기","slug":"Education_review","date":"2018-11-26T07:18:18.000Z","updated":"2019-04-27T14:45:26.199Z","comments":true,"path":"2018/11/26/Education_review/","link":"","permalink":"http://eunajjing.github.io/2018/11/26/Education_review/","excerpt":"","text":"개발 관련 국비 교육 과정 수료 후기교육 과정을 듣게 된 경위읽기 귀찮으시면 아래 요약있어요 대학을 졸업한 뒤, 나는 1년여 정도를 방송국에서 작가 업무를 했다. 프로그램은 시사였다. 소문대로 방송국 근무 환경은 좋지 않았고, 그 중 내가 속한 프로그램은 해당 방송국에서 절대 꺼지지 않는 3대 등불로 꼽히던 곳이었다. 힘들지 않았다면 거짓말이겠지만 재미가 있어 버틸 수 있던 시간이었다. 내가 업무 중에서 가장 좋아했던 특성은, 새로운 회차를 만들 적마다 매번 새로운 지식을 배워야 하는 점이었다. 프로그램을 만들고자 하는 주제와-흔히 방송 은어로 ‘야마’라고 했다-이를 뒷받침할 수 있는 근거들, 프로그램의 주제를 정면으로 반박 당할 수 있는 논리와 이에 대한 대응 지식에 대해. 제작진인 나는 매번 관련 서적을 읽고, 논문을 읽고, 전문가들의 의견을 구할 수 있는 입장에 있었다. 학창시절을 돌이켜보면 나는 학구열이 높았지만, 무언가 하나를 지속적으로 진행하는 끈기는 약한 학생이었다. 그런 점에서 방송은 최적의 공부 환경이었다. 해당 회차를 털고 나면 그 회차 주제와 관련이 있어 공부하던 것들을 버리고, 다음에 나올 방송과 연계된 새로운 공부를 할 수 있었으니까. 그래서 방송국에서 1년을 버틸 수 있었다. 결과적으로 현재 방송 업무를 하지 않지만, 내가 직업군에서 무엇을 중요시 여기는지. 나 자신을 알 수 있던 시간들이었다. 이런 경험 때문에 나는 다음에 지원할 직군도 늘 배우는 환경이길 바랐다. 내가 처음 만든 방송 주제에 대해 기억한다. 나는 ‘21세기의 인재상’과 관련한 방송에 대해 프로그램을 만들었는데, 떠오르는 산업인 4차 산업과 관련된 직군에 대해 많이 들여다볼 수 있던 시간이었다. 취재원 중 한 명은 흥미로운 역사를 지닌 이였다. 그는 군대에 있을 적, 갑작스럽게 어떤 아이디어를 떠올렸고 이를 구체적으로 발달시켜 사업을 시작하게 되었다. 전역 후, 그는 그 구체화된 것을 구현하기 위해 학교에서 개발을 배웠다. 방송에 나오는 이가 대부분 그렇듯, 시간이 흘러 그는 그 아이디어로 사업을 시작해 현재 시점서는 성공했다. 인터뷰할 당시에는 그냥 재미있는 이라고 여겼지만 방송국에서 퇴사를 하고 난 뒤 그가 부러웠다. 특정한 아이디어, 혹은 무언갈 만들겠다는 계획이 있다면 이를 직접 만들 수 있는 능력을 가지고 싶었다. 그래서 국비 교육 과정으로 개발을 배우게 되었다. 사실 이를 시작할 땐 취업을 하기 위해, 좋은 개발자가 되기 위해, 같이 특정한 목표는 없었다. 그냥 개발을 좀 배워보고 싶었고, 배울 수 있는 루트를 알아보다보니 고용노동부가 특정한 사업들을 통해 취업준비생들에게 교육에 관한 재정적 지원을 해준다는 걸 알게 되어 신청했을 뿐이었다. 취업을 하게 되면 좋은 것이지만, 결국 나와 맞지 않아 중도 포기하거나 취업을 못하게 된다고 해도 어쩔 수 없다는 마음가짐이었다. 지금 돌이켜보면 약간 무모하기도 했다. 또래들은 취업 전선에 허덕이고 있는데, 그저 배우고 싶다는 이유로 취업과 관계 없을 수도 있는 걸 6개월 동안 수강하다니. 6개월이 지난 지금, 어제 나는 최종적으로 해당 교육과정을 수료했다. 즐겁고 힘들고 과거의 나를 한 대 패고 싶던 시간이기도 했지만 후회하진 않는다. 이에 대해 기록해보고자 한다. 요약 사회생활 중 어떤 사람을 만나 개발을 배우고 싶어짐 근데 비전공자에 개발 1도 모름(그런데 정보처리기사 필기는 공부를 한 상태-퇴사한 뒤 바로 국비 지원을 신청할 수 있는 상황이 아니었기에, 그 기간 동안 뭘 해볼까 하다가 많은 이들이 개발 첫 걸음으로 정보처리기사 공부를 추천하기에 공부를 했다.-) 이클립스 툴(코딩 툴)을 이용해본 적 있음(어쩌다가 코딩 일일클래스? 같은 걸 듣게 되었는데 거기서 만져봄) 간단한 별찍기 알고리즘은 이해할 수 있었다.(마찬가지로 일일 클래스에서 배웠고 이해는 할 수 있지만 짤 수 있진 않았다) 2번의 정처기 공부 경험과 3번의 이클립스 툴 경험, 4번의 알고리즘 이해 부분을 보고 ‘뭐지 얘는?’ 싶은 분들도 있겠지만(특히 나처럼 1도 모르는 상태로 시작하려는 사람들에게)개발의 맛을 좀 보신 분들은 아시죠, 2, 3, 4가 개발에 대한 지식이 있는 상태라는 말은 아니라는 거… 취업 욕심이 그리 급하지 않아 안일한 상태로 시작 교육 기관 알아보기다들 알겠지만 국비 교육 과정은 HRD-Net 에서 볼 수 있다. 본 사람이라면 알겠지만 개발 관련 교육 기관은 너무나 많고, 교육도 세부적으로 많이 갈린다. 흔히 개발을 백과 프론트로 많이 나누어서 말을 하시는 것 같은데 신청할 당시 나는 뭘 하고 싶다, 이런 것도 없었다. -근데 굳이 뭐 하나를 지향해서 교육과정을 듣는 게 의미가 있었을까 이런 생각도 든다. 그냥 시기나 장소 잘 맞는 교육과정 하나 열심히 듣고, 나중에 안 배운 지식이 필요하거든 그 때 따로 배우면 되지 않나…? 이것도 내가 너무 안일한가- 그런데 한 가지 분명히 하고 싶었던 게 있다면 모바일을 너무 배우고 싶었다. 그런데 모바일 관련해서도 알려준다는 교육 기관이 너무 많았고, 교육 기관 내 교육 과정도 수가 너무 많아서 어떤 게 좋을지 감이 잘 오지 않았다. 주변에 조언을 여쭈니, 국비 교육 과정을 들은 언니는 우선 순위를 정했다고 했다. 학원이 얼마나 집에서 가까운지(이 언니는 집이 무척 멀었다) 교육 시작일이 언제인지(취준생 입장에서는 빨리 시작해서 빨리 배우고 취업을 하고 싶으니까) 나도 이런 우선 순위를 세워보기로 했다. 하지만 우선 순위에 둘 항목조차 무얼 할지 결정하지 못해서, 구글을 통해 국비 교육 과정 후기라던지, 같은 고민을 하시는 분들의 글을 엄청 찾아 읽었다. 그러다가 개발자 커뮤니티 사이트 내에서 국비 교육 과정 수강생들에 대한 안좋은 이야기도 많이 봤고, 현업하시는 분들 입장에서는 그러실 수도 있겠다 싶어서. 교육 과정 이후에 개발 업무로 근무하게 된다면 계속 공부하는 이가 되어야겠다는 다짐도 했다. 구글링을 하다보니 이야기가 많이 나오는 학원들이 있었다. 블랙리스트급으로 여긴 가지 마세요, 하는 학원도 있었고-심지어 다양한 사이트에서 비추글이 있는 것도 있었다-나는 여기 들었는데 괜찮더라, 이런 학원도 있었다. 일단 괜찮다는 학원들을 리스트업해서 어떤 교육 과정을 신청할 수 있는지를 알아보고, 점차 우선 순위를 정할 수 있었다. 구글링 결과 괜찮은 학원이더라, 라는 평이 있는지 (아래에서 이야기하겠지만 hrd-net의 후기는 별로 믿을만하지 못한 것 같다.) 내가 배우고 싶은 모바일 과정이 있는지 교육 기관이 서울에 있는지 괜찮다는 강사가 진행하는지 비전공자의 비율이 많은지(나는 많길 바랐다) 취업률 사실 교육 기관의 위치는 집에서 가까우면 가까울수록 좋다. 그러나 위의 우선 순위에 모두 해당하는 기관은 모두 한 지역에 집중되어 있었다. 그래서 집에서 가까운지 여부도 중요하지만-프로젝트 기간에는 집이 가까운 게 우주대깡패급이었다. 집 최고!-고려 대상에서 제외가 되었다. 리스트업 후에는 면담을 진행했는데-기관 측에서는 면접이라 이름하는데, 면접이랄 것도 없었다. 그냥 얼굴보고 사람이 이상하진 않은지 그런 것만 확인하는 것 같다-리스트업한 모든 기관에서 면접 합격 통보-합격이랄 것도 없이 신청하면 그냥 되는 경우가 많고, 스타 강사의 경우에는 시험을 보는 경우도 왕왕 있다고는 들었다-를 받았다. 나의 경우 교육 기관 선택에 가장 큰 영향을 준 건 4번이었다. 결국에는 괜찮다는 평을 받은 그 강사에게 수업을 듣진 못했지만-내가 교육 기간을 착각해서 그 강사가 하는 줄 알고 신청했는데 알고 보니 다음 달에 진행할 강사였다-지금 돌이켜 생각하니 그냥 강사가 누구든 내가 열심히하면 되는 문제였던 것 같다. 기초 강의내가 선택한 교육 기관은 전공자들도, 비전공자들도 섞여있는데다가 굉장히 다양한-프로그래밍에 원래 관심이 있었지만 전공이 아닌 사람이나, 타 언어를 사용해 개발을 했던 전직 실무자, 컴공은 아니지만 관련 계열 전공을 한 자 등-수강생들을 한데 모아 가르치는 곳이었다. 기관 측은 아예 프로그래밍 지식이 없는 이들을 위해 매달 기초 강의를 제공을 해줬는데, 사실 지금 돌이켜보니 별 도움은 되지 않았으나 툴을 익힌다던가 원리에 대해 맛을 보고 가는 경험은 좋았던 것 같다. 그 때는 뭐가 뭔지 하나도 모르니까 처음에는 철학 수업에 들어온 줄 알고 착각했다. 추상화가 뭐고, 그러니까 상속을 받으면…. 나도 자바 기초 강의를 듣다가 대학교에서 배운 플라톤의 이데아에 대해 떠올리게 될 줄 상상도 못했다. 본 강의나는 6개월 강의를 들었다. 크게 3개의 분류로 나눠지는 진도였다. 자바 언어 웹 스프링 각각의 진도가 끝날 때마다 프로젝트를 진행했다. 사실 1번이 끝났을 때 구현한 프로젝트는 프로젝트라고 하기에도 민망할 정도였고, 2번부터 어디서 본 듯한 웹사이트 구현까지는 가능했다. 여기서 비전공자들이라면 들 법한 생각. 정말 아예 모르는 상태로 시작해서, 전공자들이랑 비등하게 프로젝트 구현이 가능할까?사실 구현까지는 가능하다고 생각한다 -물론 알고리즘이라던가, 자료 구조 같이 세부적인 내용까지 고려해서 효율 높은 구현은 안될 것 같지만-6개월 동안 공부하면서 느낀 건, 정말 공부하는만큼 느는 것 같다는 것. 나와 마지막 프로젝트에서 만난 한 분은 매일 저녁마다 새로운 공부를 하는 이였다. 다음날 내가 등원하면 요상한 게 구현되어 있었다. 그가 한 짓이었다. 그는 개발이 재밌다고 했고, 우리 기수에서 두번째로 빠르게 취업을 했다.-전공자들보다 빨리 취업을 했다.-나도 그처럼 열정 넘치게 개발에 몰두했으면 좋았으련만…. 나는 그가 아니니까 뭐, 할 수 있는 만큼 했다는 것에 의의를 둔다. 아래는 내가 위에서 설명한 3개의 분류를 조금씩 자세히 설명한 것들이다. Java와 Oracle지금 돌이켜 생각해보면 자바를 그렇게까지 열심히 공부할 필요가 있었을까, 하는 의문도 들지만 프로그래밍 언어를 처음 접하기엔 좋았던 것 같다. 나중에 웹에 들어간 뒤 자바의 많은 것을 잊는 나 자신을 발견하기도 했지만(…) 어쨌든 스프링에서 다시 만나기도 하고, 다른 언어를 배우는 근간을 세울 수 있다는 점에서 유익했다. 나중에 다른 언어-파이썬이라던가, C#등-을 배울 때 비교 대상으로 쓸 수 있을 것 같긴 하다. 오라클 또한 DB를 공부하는 첫 걸음으로 썼다. 기본적인 CRUD(자료 넣기, 자료 읽기, 자료 업데이트 하기, 자료 삭제하기를 줄여서 crud라 한다)를 배웠고 그 안에 프로시저, 트리거, 커서 등을 만들어 사용하는 방법을 배웠는데 어떤 db를 사용하는지에 따라 문법이 조금씩 달라져서… 자바와 마찬가지로 비교군으로 쓰기 좋았다. WEB웹이라고 통칭했지만 배운 건 세부적으로 다음과 같다. HTML CSS Java Script Ajax Json Bootstrap 각종 API 활용 WAS 내가 제일 어려워했던 건 css였다. 그러니까, 예제까지는 괜찮았는데 어쨌든 실제 구현에 들어갔을 적 화면에서 내가 원하는 대로 변형이 잘 안되니까 미칠 것 같았다. -‘왜 옆으로 안가니’라고 곡소리가 나게 만드는 대표적인 구현으로, 우리끼리는 차라리 모니터를 오려서 붙이자는 우스갯소리도 했다- 그 외에는 사실 다… 하다보니 되었다. 사실 지금도 공공데이터 api를 json으로 받아와 파싱하는 건 조금 자신 없긴 한데(…) 쉬는 기간동안 연습을 많이 해볼 작정이다. 스프링과 mybatis위에서는 스프링, 이러고 넘어갔지만 왜인지 mybatis를 빼먹으면 섭섭할 것 같아서 같이 기록. 개인적으로 스프링이 모든 걸 자동화하는 터라 처음에는 너무 혼돈의 도가니였는데-어떤 분께 스프링이 너무 어렵다, 말씀 드리니 스프링이 어려운 게 아니라 그 전의 기초가 잘 안되어 있는 것 같다는 현답을 주신 적이 있다-내가 어려워하는 이유를 곰곰이 생각해보니 세팅을 꼼꼼하게 잘 못하는 성격 탓인 것 같았다. 그러나 이 무지는 현재까지도 계속 진행 중. 변명 아닌 변명을 좀 해보자면, 3차 프로젝트의 모든 세팅을 한 사람이 몰아서 한데다가 그가 메서드 이름까지 모든 걸 만들어둬서, 나는 그 안, 비워진 메서드를 채워넣는 식으로 작업을 했다. 그래서 결국 세팅도… 다시 공부해야할 필요를 느낀다. 쓰다보니 제대로 아는 게 없는 것 같네 그 외, 따로 공부했던 것다른 포스팅에서 언급했듯 우리는 node.js와 aws를 사용했다. 노드의 경우 크롬 확장프로그램 때문에 사용할 수밖에 없었고, aws는 프로젝트 중에 사진 첨부 때문에 어쩌다보니 사용하게 됐다. 사실 구현을 한 소스를 봐도 정확히 뭐가 어떤 역할을 하는지 설명하라고 그러면 못할 것 같다. 정말 이런 말을 하고 싶지 않지만 내가 구현하지 않은 부분을 잘 모르겠다.-이걸 포트폴리오랍시고 낼 수 있을까도 너무 염려스럽다-현재로서는 내가 만든-만들었다고 할 수 있을지 모를-이 프로젝트를 내가 공부할 판이다-근데 다들 그런 것 같았다-원래는 서로가 서로의 소스에 대해 설명하는 시간을 가지려고 했으나 어쩌다보니… 결국…. 못했다. 우리 기수의 유일한 취업자들이 다 나랑 같은 팀일 건 또 뭐람. 내가 우리 프로젝트에서 맡아 구현한 부분은 아래와 같다. 웹소켓을 이용한 실시간 알림 처리(관련 포스팅을 해두었다) 트리거를 이용한 db 자동 인서트, 업데이트(관련 포스팅을 해두었다) 프로젝트 프론트 단 하이차트를 이용한 관리자 통계 데이터 테이블을 이용한 관리자 단 유저 관리 및 유저의 게시물 관리, 신고 확인 및 신고 처리(유저를 강제로 탈퇴 시키거나, 유저가 쓴 게시물 블라인드 처리, 신고한 게시물과 댓글을 확인하고 블라인드 처리하는 것) TinyMCE 에디터기 웹팩 번들링 및 커스터마이징 쓰고보니 정말 별 걸 안했다… 그래서 개인 프로젝트에 더 욕심을 내는 것 같기도 하고. 아, 2차 프로젝트는 이런 걸 했다. ajax를 이용한 비동기 댓글 crud 페이징 처리를 한 게시판 만들기 게시글 crud 썸머노트 에디터기를 이용한 게시물 작성 뷰단 구현 사실 3차는 2차에서 한 것을 제외하고 맡고 싶었던 터라 선택지가 많이 없었는데-원래 회원가입을 하고 싶었는데 가위바위보에서 졌다-지금 생각해보면 그냥 2차에서 한 거에서 더 디벨롭 시키는 방향을 욕심내도 되지 않았을까 싶다. 강의 수료 후, 아쉬운 점 및 느낀점어쩌다가 다른 기수나 다른 교육 기관에서 교육 받으신 분들과 교류하는 기회가 있었는데 기관마다, 강사마다 가르치는 차이가 크다는 걸 알게 됐다. 심지어 같은 분야의 수업인데도 강사가 누구인지에 따라 배우는 분야도 차이가 났다.-어떤 반은 언어를 두 개 배웠다고도 하고, 나의 경우 RDBMS(관계형 데이터베이스)만 배웠는데 어디는 또 NOSQL도 배웠다고 해서 혼란의 도가니-결국 느낀 건, 그냥 진짜 궁금하면 내가 하는 수밖에 없다는 것. 떠먹여주는 걸 바라면 안된다는 것. 나의 경우에는 갑작스러운 강사 교체가 이루어져서, 진도에서 분류 2에 해당하는 웹단을 한 번 더 듣는 일이 발생했는데, 처음에는 기관 측에서 분명 부족한 부분이 있으면 보강해주겠다고 했지만 그런 일은 벌어지지 않았고(…) 객관적으로 봤을 때 다른 기관에서 배운 이들 뿐만 아니라 다른 기수보다 우리 기수가 배운 것이 더 적지 않을까 하는 걱정도 된다. 제일 아쉬운 점은 모바일을 안 배웠다는 것. 도대체 나는 왜 이 수업을 들은 것인가 약간 자괴감에 휩싸이긴 하지만서도 안드로이드가 자바 기반이기 때문에 혼자서도 할 수 있을 것 같다는 희망을 얻게 되어 혼자서나마 공부해볼 작정이다. 이번 프로젝트에서 뼈 저리게 느낀 건, 의외로 개발적인 부분은 아니었다. 제일 난관이었던 건 협업의 어려움이었다. 사실 나는 대학에 진학해 일반적인 대학 교육 과정을 수료했으므로 팀플을 경험한 적이 수도 없이 많았다. 혼자 독박도 써봤고, 의도찮게 민폐도 끼쳐봤고-인과응보라고, 성적이 좋지 않았지만-함께 하는 이와 의견 충돌을 겪으며 더 나은 대안을 생각해보는 일련의 과정을 겪은 적이 있었다. 심지어 이번에 함께 프로젝트에 참여하는 이들은 나와 친한 이들이었다.-수료 프로젝트를 만드는 것이니만큼, 하고 싶은 이와 팀을 할 수 있도록 강사님이 배려해주셨다-그래서 대학 팀플보다 쉬우면 쉬웠지, 어렵진 않으리라 여겼다. 왜냐하면 일단 구성원 중 프리라이딩을 할 사람이 없으리라 여겼고, 모두 다 맡은 바 소임을 다할 이들이었기 때문에. 사람이 좋으니까 잘 되리라 여겼는데. 이게 오만이었을 줄은 상상도 못했다. 처음 협업이 어렵다고 느낀 건, 다름 아닌 뷰단 구성에서부터였다. 주제를 합의하는 건 굉장히 쉬웠는데 사람들마다 머리 속에 그리는 뷰단의 모습이 제각각이었다. 넣고 싶은 기능도 달랐고, 사이드바에 무엇을 넣을 건지, 네브 바(메뉴)는 어떻게 만들 것인지, 테마는 어떻게 갈 것인지. 이를 구체화해서 명시해야 하는 문서 작업에 들어가면서 정말 머리채 잡기 전까지 피 터지게 싸워댔다. 감정적으로 고조되었다가 화해하고, 술 마시고(…) 그걸 반복했다. 서로 잘하고자 하는 욕심이 있었기에 싸움은 더 격했다. 어찌 어찌 뷰단을 합의 보고 난 뒤에 다시 싸우게 된 건 서로가 서로의 소스를 이해하지 못하는 상황이 닥치고 나서였다. 병합을 하면 충돌이 났고, 충돌이 가시적으로 보이지 않아도 됐던 기능이 안되었다가, 대환멸의 서막이었다. 서로가 서로의 소스를 읽기에는 너무 바빴고, 확인을 하지도 않고 병합을 해버리는 상황들이 반복되며-물론 그건 대부분 특정인들이 그랬지만 그들은 프로젝트 끝까지 습관을 고치지 못했다-감정적으로 갈등이 쌓여갔다. 사실 자바를 배울 적에 강사님이 말씀하시길 “코딩 스타일이 있다. 편한 대로 하면 된다” 고 했건만 서로의 스타일을 인정하지 못했다. 솔직히 말해서 위와 같은 뷰단, 스타일 합의 부분은 우리가 평등하기 때문에 갈등이 더 심한 것 같았다. 그냥 누가 ‘이렇게 해!’라고 시키면 군말 없이 할 법한 것도 왜 그렇게 해야만하는지 서로를 설득하는데 너무 많은 노력이 필요했다. 코딩을 잘해봤자 같이 배우는 입장에서 얼마나 특출나게 잘하겠으며, 같은 곳에서 같은 사람에게 코딩을 배웠는데 얼마나 많이 벗어난 코드를 구현했을까. 그저 프로젝트가 조금씩 궤도에 오르며, 에러가 미친 듯이 나기 시작하며 스트레스를 받기 시작하고 조금만 건들이면 툭, 터지는 그런 상황이었던 것 같다. 왜 면접에서 협업을 해본 경험이 있는지 그렇게 물어대는지 알 수 있던 경험이었다. 모든 갈등의 병합이 효율적이고 성공적이었던 것만은 아니지만 이후 협업은 보다 나아지리라 믿는다. +) 아 그리고 생각보다 커뮤니케이션이 어려운 사람이 많았다. 물론 내가 부족한 탓도 있으리라 여기지만, 말이 너무 이해하기 어려워서 차라리 문서로 정리해서 달라고 말씀드리니 글로 자신의 생각을 적는 것도 힘들어하는 이들이 많아서 조금 놀랐다. 도대체 어떻게 커뮤니케이션을 하는 게 효과적인 건지 고민하는 계기가 되었다. 통합해서이 글을 과연 누가 읽을까, 를 고민하다가 누구에게 필요한 글을 쓰고 싶은 걸까, 를 고민해봤다. 나는 이 글을 나처럼 국비교육과정을 고민하는 이들이 읽기를 바라기에 그들에게 하고 싶은 말을 몇 자 적는 것으로 이 포스팅을 마치고자 한다. 노력하는 만큼 배울 수 있던 시간이었습니다. 국비교육과정은 세금으로 운영되기에, 예산이 널널한 기간에 듣는 게 좋습니다.(만약 연말에 듣게 된다면 제 때 훈련 수당이 지급되지 않을 가능성이 높습니다) 세상은 넓고 다양한 사람이 많습니다. 공부도, 취업도 누가 떠먹여주진 않는 것 같습니다. 6개월을 고생해 만든 수료 프로젝트는 이것이고, 사실 에러가 너무 많이 나서(…) 공개가 약간 민망한 감이 있기도 하고 과연 aws는 언제까지 살아있을지 알 수가 없다. 왜냐하면 내 aws 계정이 아니기 때문!","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"node.js","slug":"node-js","date":"2018-11-21T07:53:21.000Z","updated":"2018-11-26T07:22:24.495Z","comments":true,"path":"2018/11/21/node-js/","link":"","permalink":"http://eunajjing.github.io/2018/11/21/node-js/","excerpt":"","text":"노드JS공부하게 된 계기프로젝트에서 노드를 사용할 것 같다는 의견이 있어서 나름 낑낑거리며 공부했다. 프로젝트 막바지인 지금, 당시 정리해둔 문서가 많이 허접하긴 하지만 뭐… 공부했던 기록을 남겨둔다. 참고한 것Do it! Node.js 근데 많이 참고하진 않았다…변명처럼 들리겠지만 당시에 나는 플젝에서 필요할 것만을 보고 싶었고, 실제로 프로젝트 팀원들에게 그렇게 요구 받았다.(프로젝트 시작 전 우리가 어떤 기능을 쓸 것인지에 대해 고민해보고, 각자 특정 부분을 맡아 공부 후 다른 팀원에게 설명하는 식으로 스터디를 진행했다) 참고한 책은 모든 장이 연결되어 순차적으로 한 웹사이트를 구현하는 방식에 대해 이야기하고 있어서… 예를 들어 우리 프로젝트에서는 몽고 디비를 빼자고 해서, 나는 공부할 당시엔 몽고 디비를 간략히 보거나 아예 보지 않아도 됐다. 이런 식으로 특정 장을 훑듯 보고 다음 장으로 건너 뛰니, 제대로 이해가 되지 않은 파트가 발목을 잡아 정말 이해해야할 예제 소스가 잘 이해가 되지 않았다. 사실 노드를 써서 이번 프로젝트를 진행한 것도 사실이고, 내 블로그도 노드를 기반으로 해서 만든 프레임웤이긴 한데. 아직도 잘 모르겠다. 그냥 그 때 그 때 검색하면서 진행을 해서… 정말 본론 시작 - 당시에 정리한 문서시작하기 전에 node.js 다운로드 후 설치 : https://nodejs.org/en/ (8.12.0 LTS 버전을 이용하였습니다) 이클립스에서 사용할 예정이므로 이클립스에서 node.js 플러그인 설치(http://marketplace.eclipse.org/content/nodeclipse) node.js자바 스크립트를 이용해 서버를 만들 수 있는 개발 도구 node.js 특징 비동기 입출력 가능 이벤트 기반 모듈과 패키지 npm(Node Package Manager) 노드 패키지의 설치, 삭제를 지원하는 프로그램 패키지(모듈+α)는 만든 이가 다른 사람도 사용할 수 있도록 인터넷에 공유해놓는 게 일반적 노드에서 사용할 수 있는 대표적인 전역 객체 console exports process 노드에서 사용할 수 있는 대표적인 전역 변수 __filename __dirname console의 메서드들log() 형식 특수문자 예시 코드 콘솔 %d 숫자 console.log(“ 숫자 : %d”, 10) 숫자 : 10 %s 문자열 console.log(“ 문자 : %s”, 문지은) 문자 : 문지은 %j JSON console.log(“JSON : %j”, { 팀장 : “ 이주원”}) JSON {“ 팀장” : “ 이주원”} log() 외 메서드 설명 dir(object) 객체 속성 출력 time( 객체명) 실행 시간 측정을 위해 실행 시작 시간 기록 timeEnd( 객체명) 실행 시간 측정을 위해 실행 종료 시간 기록 모듈 사용(exports)기존에 여러 개로 나눠둔 무언가를 필요에 따라 맞춰다가 쓰는 식 예시module1.jsexports.methodName = function() { retrun result; }; main.jsvar module = require(&apos;module1&apos;); // require() // : 모듈을 불러올 때 사용하며 파라미터는 모듈의 이름이나 모듈의 경로 // 모듈 객체가 리턴되어 모듈객체.함수명(); 으로 접근 가능 // 만약 이름에 해당하는 파일이 없다면, 이름에 해당하는 폴더를 찾아 그 안의 index.js 실행 module.methodName(); exports와 module.exports이해에 참고했던 블로그 exports module.exports 여러 개의 변수, 함수를 각각의 속성으로 추가 가능 하나의 변수나 함수, 객체를 직접 할당, 참조가 끊기면 빈 객체 리턴됨 (단 하나의 객체만 사용 가능하다고 이해) process 속성 / 메서드 설명 예시 argv 프로세스를 실행할 때 전달되는 파라미터 정보를 가진 속성 process.argv.length : 파라미터 개수 process.argv[2] : 2 번 배열의 파라미터 env 환경 변수 정보를 가진 속성 process.env[‘OS’] : OS 환경 변수의 값(data) exit() 프로세스를 끝내는 메서드 내장 모듈과 외장 모듈 내장 모듈 : 사용자가 직접 만든 js 모듈 외장 모듈 : 다른 사람이 만들어 놓아 사용자가 npm 패키지를 이용해 다운로드한 js 모듈 외장 모듈 경로 : 프로젝트 폴더 &gt; node_modules 폴더 &gt; 모듈명 폴더 만약 매번 프로젝트마다 같은 패키지를 이용한다면 brackets-nodejs에 node_modules 폴더를 이동시키면 된다. 내장 모듈 사용하기(path만 정리) 모든 내장 모듈은 여기에서 볼 수 있다 메서드 설명 join() 여러 개의 이름을 모두 합쳐 하나의 파일 패스로 만들며, 구분자 등을 알아서 조정 dirname() 파일 패스에서 디렉터리 이름만 반환 basename() 파일 패스에서 파일 이름만 반환 extname() 파일 패스에서 확장자만 반환 외장 모듈 사용하기사용 예시 기존에 nconf라는 외부 모듈을 설치했다는 전제 하외장모듈 설치 단축키 : % npm install 외장모듈이름 var nconf = require(&apos;nconf&apos;); // 외부 모듈의 경우 경로가 아닌 모듈의 이름을 직접 불러야 함 nconf.modulInMethod(); package.json% npm init 명령어를 실행하면 생기는 json 파일로, 프로젝트에 대한 기본 정보가 들어 있으며 현재 프로젝트에 설치된 외부 모듈의 의존도 함께 기록됨향후 다른 PC에서 같은 모듈들을 사용하고 싶다면 package.json만 옮겨서 가져가면 된다. 사용법 % npm init: package.json 파일 생성 % npm install 외부모듈이름 –save : 의존 설정할 외부모듈을 설치한다. package.json이 있는 상태에서 설치된 것들만 package.json이 기록한다. 향후 다른 PC로 옮길 때 PC로 json 파일 옮기고, % npm install 명령어 실행 : package.json의 의존 속성을 참고해 패키지 설치","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"nodeJS","slug":"개발공부/nodeJS","permalink":"http://eunajjing.github.io/categories/개발공부/nodeJS/"}],"tags":[]},{"title":"websocket","slug":"websocket","date":"2018-11-08T07:27:20.000Z","updated":"2018-11-26T07:22:24.496Z","comments":true,"path":"2018/11/08/websocket/","link":"","permalink":"http://eunajjing.github.io/2018/11/08/websocket/","excerpt":"","text":"websocket을 이용한 간단한 알림 구현 유용하게 참고했던 링크들시니어코딩 유튜브 강좌 스프링 시큐리티를 사용하지 않아 http세션과 웹소켓을 잇는 작업이 존재 연속된 강의라서 도중에 강의만 따라해서는 모르는 과정이 있음, 이 부족한 부분은 깃허브에 소스가 오픈되어 있어서 보면서 해야함 블로그 포스팅 xml 단에서 설정해야할 부분이 빠져있음 간단하게 몇 건의 send를 받았는지 표기하는 예제 개인적으로 제일 많은 도움을 받았음 그런데 왜인지 똑같은 소스인데 override가 안되더라ㅠㅠ 근데 이건 안되어도 일단 기능은 제대로 발동해서 놔둠 블로그 포스팅 위의 블로그 포스팅에서 누락된 것을 보기 위해 참고했었음 이상한 곳에서 계속 헤메이던 웹소켓 구현 다들 저 위의 링크들을 따라하다보면 나…름 구현은 가능할 듯 근데 내가 힘들었던 건 많이 참고했다는 블로그 포스팅을 보고 1차로 페이지 이동 시 웹소켓 발동까지는 했는데 갑자기 실시간으로 알림 받기로 변경하라는 피드백을 받아서 일부를 수정하면서 생긴 것. 인강은 디비에 있는 데이터를 뿌리지 않고 웹소켓이 보낸 데이터를 클라이언트 단에 단순히 뿌려주는 식으로 구현됨 그런데 나는 디비에서 가져와야 하기 때문에 쵸큼 달랐고 걍 핸들러에서 db에 select를 하게끔 만들었다. 나는 send된 파라미터가 여러 개일 때만 처리하려고 했는데 왜인지 파라미터 여러 개 send가 먹지 않았던 문제가 제일 힘들었다. 나중에 알고보니까 아래처럼 써서 그랬던 거 같다. websocket.send(&quot;~~~&quot;, &quot;~~~&quot;, &quot;~~&quot;); 이렇게 썼다면 되지 않았을까?(어쩌다보니 이렇게 보낼 필요가 없어서 나는 시도는 안해봤다) websocket.send(&quot;~~~~, ~~~~, ~~~&quot;); 그리구 인강에서 전역 변수로 빼서 사용하는 웹소켓, 나는 먹지 않아서 그냥 고치기 전? 전역 변수로 빼지 않고 사용하는 웹소켓으로 구현했다. 테스트 웹소켓 테스트 가능 사이트","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"trigger","slug":"trigger","date":"2018-11-01T02:06:33.000Z","updated":"2018-11-26T07:22:24.496Z","comments":true,"path":"2018/11/01/trigger/","link":"","permalink":"http://eunajjing.github.io/2018/11/01/trigger/","excerpt":"","text":"트리거의 이용 트리거특정한 테이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램 문법create trigger 트리거명 [before OR after] [insert OR update OR delete] on DML_실행되는_테이블명 [for each row] begin 실행할_쿼리_작성 end; before : DML 실행 전에 트리거 발동 after : DML 실행 후에 트리거 발동 insert : 만약 이 테이블에 인서트되면 해당 트리거 발동 update : 만약 이 테이블이 업데이트되면 delete : 삭제되면 for each row : 한 레코드 당 한 번씩 발동 레코드 구조체 나는 mariaDB를 사용해서 프로젝트 구현 중이기에 new.칼럼명 : 입력된 레코드에서 해당 칼럼의 데이터 old.칼럼명 : 기존에 있던 레코드에서 칼럼의 데이터 (delete문에서는 new.칼럼명을, insert문에서는 old.칼럼명을 사용할 수 없다) 트리거에서 조건문 만들기create trigger blind after update ON report FOR EACH ROW -- blind란 트리거를 생성한다. 이 트리거는 report 테이블에 레코드 하나가 들어간 이후에 실행된다. begin -- 트리거 정의 시작 if new.checkCode = &apos;PS02&apos; then -- 만약 업데이트된 레코드의 checkCode 칼럼의 값이 &apos;PS02&apos;라면(if절 1번) if new.noteOrCommCode = &apos;NC00&apos; then -- 만약 업데이트된 레코드의 noteOrCommCode 칼럼의 값이 &apos;NC00&apos;라면 (if절 2번) insert into notify(userEmail, notifyCode, notifyTarget, readCheck) values ((select userEmail from note where noteNum=new.noteNum), &apos;RN&apos;, new.noteNum, 1) -- 해당 SQL문을 실행한다. on DUPLICATE KEY update readCheck=1; -- 만약 이미 중복하는 레코드가 있다면 insert하지 않고 update하겠다. -- readCheck라는 칼럼의 데이터를 1로 else -- 업데이트된 레코드의 noteOrCommCode 칼럼의 값이 &apos;NC00&apos;이 아니라면 insert into notify(userEmail, notifyCode, notifyTarget, readCheck) values ((select userEmail from notecomm where noteCommNum=new.noteNum), &apos;RC&apos;, (select noteNum from notecomm where noteCommNum=new.noteNum), 1) on DUPLICATE KEY update readCheck=1; end if; -- if절 2번 종료 end if; -- if절 1번 종료 end; -- 트리거 정의 종료 on DUPLICATE KEY는 트리거의 문법이 아닌 일반 쿼리 문법 트리거로 루프 돌리기create trigger QNAAdmin after insert on notify for each row begin DECLARE done INT DEFAULT FALSE; declare tempoUserEmail varchar; declare curUserEmail cursor for select userEmail from roles where roleCode=&apos;ROLE_ADMIN&apos;; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; if (select roleCode from roles where userEmail=new.userEmail) = &apos;ROLE_ADMIN&apos; then open curUserEmail; ins_loop: LOOP fetch curUserEmail into tempoUserEmail; if done then leave ins_loop; end if; insert into notify(userEmail, notifyCode, notifyTarget) values (tempoUserEmail, &apos;QNA&apos;, new.qnaNum); end loop; close curUserEmail; end if; end; 관리자가 여러 명일 수 있어서, 쿼리의 결과가 다중일 때 트리거 안에서 루프를 돌게끔 쿼리문을 짜보았다.그런데 위 쿼리는 실제로 프로젝트에 사용은 못했다.roles가 예약어로 잡혀있는 것 같다고 강사님이 그러셨다.문법 자체는 오류가 없어보인다고 그러셔서, 나중에 또 내가 이런 뻘짓하고 싶어할까봐 같이 기록. 프로젝트에선 파라미터로 role이 관리자인 것들을 리스트 형태로 보낸다음, foreach로 돌렸다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"notification API를 이용한 웹 알림 구현","slug":"notification-API를-이용한-웹-알림-구현","date":"2018-10-16T03:43:02.000Z","updated":"2018-11-26T07:22:24.495Z","comments":true,"path":"2018/10/16/notification-API를-이용한-웹-알림-구현/","link":"","permalink":"http://eunajjing.github.io/2018/10/16/notification-API를-이용한-웹-알림-구현/","excerpt":"","text":"notification API를 이용한 웹 알림 구현&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;notify()&quot;&gt;알림 띄우기&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { if(window.Notification) { Notification.requestPermission(); } // 온 로드되면 공지 기능을 허용한다. function notify() { var notification = new Notification(&apos;공지 타이틀&apos;, { icon: &apos;https://camo.githubusercontent.com/7710b43d0476b6f6d4b4b2865e35c108f69991f3/68747470733a2f2f7777772e69636f6e66696e6465722e636f6d2f646174612f69636f6e732f6f637469636f6e732f313032342f6d61726b2d6769746875622d3235362e706e67&apos;, body: &apos;github 블로그로 이동&apos; }); notification.onclick = function() { window.open(&apos;http://eunajjing.github.io&apos;); }; // 알림 메시지 클릭하면 해당 페이지 새 창이 뜬다. } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 원래 커뮤니티 사이트에서 내가 쓴 게시물에 댓글 달면 댓글 달렸다고 알리는 기능? 구현하고 싶어서 검색하다 발견한 소스. 간단하게 잘라서 구현해봤다. 내가 원한 건 이게 아닌데…","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"mongoDB_01","slug":"mongoDB-01","date":"2018-10-15T02:09:06.000Z","updated":"2018-11-26T07:22:24.495Z","comments":true,"path":"2018/10/15/mongoDB-01/","link":"","permalink":"http://eunajjing.github.io/2018/10/15/mongoDB-01/","excerpt":"","text":"MogoDB(NoSQL) 기초01공부한 강의 근데 강의가 오래 전 것 같고, 아예 nosql을 처음 접하는 나로는 조금 어려운 부분이 있어서(group, map-reduce 등) 이번 것만 듣고 다른 강의 찾아 들어볼 생각 NoSQL관계형 DB로 처리하기에는 약간 부족한 부분들을 매꿔줄 수 있는 DB. KEY VALUE 형 문서형 (MongoDB) 컬럼 제한형 그래프 기반형 몽고 DB 데이터 구성 데이터 베이스 : 컬렉션들의 집합 컬렉션 : 테이블과 유사 BSON : 스키마에 맞춰 저장하는 유형 BSON: JSON의 바이너리 형태라는 뜻 몽고 DB 특징 조인을 지원하지 않는다(대부분의 NOSQL이 그러함) 스키마가 존재하지 않는다 create DB 구문이 존재하지 않는다(하지만 drop절은 있다) 몽고 DB 첫걸음몽고디비가 제공하는 자바스크립트 쉘 인터페이스로 몽고디비에 접속을 하게 되면 use 데이터베이스명 구문을 사용하면 데이터베이스가 자동으로 생성된다.but 파일이 자동으로 생성은 안된다. (컬렉션을 생성해야함) db.stats(); 해당 DB 설정 상황 확인 db.createCollection(“컬렉션명”); 컬렉션 생성 명령어 db.help 어떠한 명령어가 있는지 확인하는 명령 db.getCollectionNames(); 실제로 컬렉션이 만들어져있는지를 확인하는 메서드 몽고 DB의 파일들 mongod.lock : 실제 서버를 실행시키는 프로세스 id 저장 .ns : 몽고디비는 컬렉션, 인덱스를 생성하게 되면 각각에 네임스페이스 필드를 만들게 되어 있음. 해당 값들을 저장하는 파일 0 또는 1 : 실제 데이터를 저장하는 파일들 (파일의 크기 0은 64메가, 1은 128메가가 초기 할당된 상태로, 이후 메모리 증가가 필요한 경우 숫자 크기가 늘어난다, 메모리는 2기가가 될 때까지 2배씩 늘어난다.) 몽고 DB의 컬렉션 종류일반적인 용도의 컬렉션 캡드 컬렉션 고정된 크기 이상 증가하지 않음 만약 크기 이상 데이터가 들어갈 경우 가장 오래된 도큐먼트를 덮음 개별 도큐먼트 삭제가 불가능함 기본적으로 몽고 디비에서 자신의 데이터를 관리하기 위한 시스템 컬렉션들이 두 개 생성되어 있음 (system.index, system.namespaces) 복제를 위한 컬렉션 insert db.컬렉션명.insert({“컬럼1”:”value1”, “컬럼2”:”value2”}) db.컬렉션명.find({“컬럼1”:”value1”}) – find할 조건, select와 비슷 {“_id” : ObjectId(“명시적으로 쓰지 않았다면 몽고 디비가 임의로 붙였을 id 값, 이 id는 내부적으로 관리를 위해 생성”), “컬럼1” : “value1”, “컬럼2” : “value2”} – find 결과 update db.컬렉션명.update({“기존 컬럼명”:”기존 value”}, {“치환할 컬럼명”:”치환할 value”}}) db.컬렉션명.update({“기존 컬럼명”:”기존 value”}, {$set{“덮어씌울 컬럼명”:”덮어씌울 value”}}) 첫번째 매개변수는 update 대상이 될 것을 찾는 조건이되며 두번째 매개변수는 치환할 데이터 매개변수.관계형 DB와 다르게 몽고 디비는 만들어진 도큐멘트를 치환하는 방식으로 update가 이루어진다.치환의 경우 오버헤드가 발생할 수도 있기 때문에 $set이라는 명령어를 사용하여 문서를 치환하지 않고 원하는 부분만 바꿀 수 있다. remove db.컬렉션명.remove({“삭제할 컬럼명”:”삭제할 value”}) selectfind 검색 조건이 참일 때 커서가 반환 db.컬렉션명.find(); {“_id” : ObjectId(“-“), “칼럼1” : value1} {“_id” : ObjectId(“-“), “칼럼2” : value2} {“_id” : ObjectId(“-“), “칼럼3” : value3} findOne (= find.limit(1);) 검색 조건에 해당하는 문서가 여러 개라도 하나만 반환 {“_id” : ObjectId(“-“), “칼럼1” : value1} 정규표현식(대표적인 지시자)범위 지시자 $gt $gte $lt $lte집합 지시자 $in $all $nin부울 지시자 $ne $not $or $exists기타 $mod $type $where group개발자가 원하는 함수를 만들어 쓸 수 있으나 결과가 16메가가 넘으면 처리가 되지 않음 map-reduce개발자가 원하는 함수를 만들어 쓸 수 있음 map : 그룹화, 리듀스 계산을 위한 데이터 전달 reduce : 실제 연산 인덱스 system.namespaces : 색인의 이름 정보 데이터 저장되어있음 system.indexs : 색인의 상세 정보 데이터 저장되어있음 ensureIndex : 색인 생성 dropIndex : 색인 삭제 db.컬렉션명.ensureIndex({“칼럼”:1}) // 1은 임의로 준 값db.system.indexs.find() // 상세 정보 데이터들이 출력됨","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"몽고DB","slug":"개발공부/몽고DB","permalink":"http://eunajjing.github.io/categories/개발공부/몽고DB/"}],"tags":[]},{"title":"SQLD 후기-제30회 자격검정","slug":"SQLD_후기-제30회_자격검정","date":"2018-10-07T06:55:41.000Z","updated":"2018-11-26T08:02:37.000Z","comments":true,"path":"2018/10/07/SQLD_후기-제30회_자격검정/","link":"","permalink":"http://eunajjing.github.io/2018/10/07/SQLD_후기-제30회_자격검정/","excerpt":"","text":"SQLD 후기 - 제30회 자격검정 응시 어쩌다보니 조금 즉흥적으로 응시하게 된 SQLD 시험. 발표가 난 건 좀 됐지만, 정처기 공부 때문에 정신이 없어서 후기를 못 올렸다. 보게 된 경위원래 나는 2018년도 정보처리기사 2회차 필기 시험을 봤었고, 해당 회차에 한 번에 합격을 하긴 했었다. 그런데 실기 공부를 너무 안해서(..) 실기는 다음 회차를 노리게 되었고 그 붕 뜬 기간 동안 무얼 공부할까 하다가, 마침 SQLD 시험 일정이 맞는 거 같아서 시험을 보게 되었다. 2017년도 시험이 너무 어려웠다는 후기가 많았기에-물론 2018년도 시험은 쉽다는 후기가 현재에는 많지만 당시에는 29회(2018년도 2회차 시험) 발표 전이라 쉽다는 후기가 별로 없었다-되게 스트레스를 많이 받아가며 공부를 했었다. 막판에는 이렇게 힘들어할 바엔 그냥 시험지나 보고 오자, 마인드로 공부를 잘 안했을 정도. 그런데 치루고 나니까 난이도가 쉬웠던 터라, 막판까지 공부를 열심히 할 걸 그랬다는 아쉬움이 남는다. 시험 준비나는 다른 분들의 후기를 따라 기본서는 사지 않았고, 공식 홈페이지에서 설명해놓은 개념을 몽땅 프린트해서 스프링제본했다. 홈페이지와 기본서의 내용은 같다곤 하는데…. 사실 홈페이지가 가독성이 정말 많이 떨어져서 책을 구매하는 것도 나쁘지 않았을 것 같다는 후회가 들었다. 나는 막판에 내가 프린트한 스프링 책을 버리고, 그냥 sqld를 공부하시던 분들이 인터넷에 정리 겸 해서 올려두신 걸로 공부했다. 너무 가독성이 안좋아서 무슨 소리인지 당최 이해가 안돼서… 그리고 많은 분들이 추천하셨던 책인, ==SQL 자격검정 실전문제== 이 문제집은 구매해서 풀었다. 진짜 후기들 말따라 기본서의 그 모든 어려운 개념을 차근차근 읽어서 이해하는 것보단 문제에 있는 것 위주로 일단 공부를 한다음에 확장하는 식으로 공부하는 게 더 효율적이었던 것 같다. 근데 시험의 80% 지분이 있는 2과목 위주로 시험 문제가 많고, 1과목은 그렇게 문제가 많은 것 같지가 않아서 좀 불안했다. 그래서 나는 찾아보니 시중에 ==SQLD,SQLP 연습문제 300== 이 문제집도 있길래 마저 풀었다. 이 책은 이북으로만 출판이 되어있고, 아직 학적이 남아있는 학교 도서관에서 빌릴 수 있어서 사진 않고 빌려 보았다. 실전문제집이 정말 데이터 뽑아내기 위주의 문제가 많다면 이 책은 개념을 묻는 문제 위주여서 나름 도움이 되었다. 1과목에서 과락하시는 분들이 제법 있다고 하길래 계속 불안했거든. 그런데 ‘나름’ 도움이 됐다고 하는 게 너무 오타가 많다ㅠㅠ… 굳이 굳이 없는데 사서 볼 책인지는 사실 잘 모르겠다. 그리고 다른 분들은 복원 문제 찾아서 많이 풀어보기를 추천하시던데, 나는 사실 잘 모르겠다. 막판에 나도 복원 문제를 구글링해서 몇 번 풀어보긴 했지만… 차라리 문제집을 여러 번 풀어보거나(근데 문제집 여러 회독하면 문제 답을 아예 외우게 되어서 내가 진짜 이 쿼리문을 이해하고 체크하는 건지, 아니면 외워버려서 체크하는 건지 잘 모르겠다) 헷갈리는 개념을 바로 잡는 게 내게는 더 도움이 되었던 것 같다. 마치며정말 자격증 한 줄 채우기 위해 봤던 시험이긴 했지만, 정보처리기사 공부하는 것보다 얻어가는 게 많은 시험이었다. 잘 쓴 쿼리문은 코드량을 줄인다는 걸 좀 많이 느낄 수 있기도 했고. 개인적으로 여유가 된다면 sqlp에도 도전해보고 싶다.","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"정보처리기사-신기술용어","slug":"정보처리기사-신기술용어","date":"2018-10-06T10:14:47.000Z","updated":"2018-11-26T07:22:24.497Z","comments":true,"path":"2018/10/06/정보처리기사-신기술용어/","link":"","permalink":"http://eunajjing.github.io/2018/10/06/정보처리기사-신기술용어/","excerpt":"","text":"신기술용어 지그비 : 저속, 저비용, 저전력의 무선 망을 위한 기술. 주로 양방향 무선 개인 영역 통신망 기반의 홈 네트워크 및 무선 센서망에서 사용되는 기술 피코넷 : 여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신기술을 사용하여 통신망을 형성하는 무선 네트워크 기술 애드훅 : 고정된 유선망을 가지지 않고 이동 호스트(Mobile Host)로만 이루어진 통신망 스콤 : 미국 전자 학습 표준 연구 개발 기관인 ADL에서 제정한 사실 표준 디봅스 : 시스템 개발과 운영을 병행 및 협업하는 방식 하둡 : 대량의 자료(Big Data)를 처리할 수 있는 큰 컴퓨터 클러스터에서 동작하는 분산 응용 프로그램을 지원하는 자유 자바 소프트웨어 프레임워크 ICN : 통신을 기반으로 한 이전의 인터넷 통신 패러다임을 정보 중심으로 재편성하려는 네트워킹이다 OGSA : 애플리케이션 공유를 위한 웹 서비스 표준과 인프라 자원의 공유를 위한 그리드 기술이 결합된 개방형 표준이다. SOA : 기업의 소프트웨어 인프라인 정보 시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보 기술 아키텍처 ITIL : 세계적으로 공인된 Best Practice(모범 실무)를 제공하는 IT서비스 품질모델 ITSM : 프로세스와 고객에 초점을 맞춘 서비스 관리 AMR :자동 원격검침 시스템으로 검침원이 일일이 고객을 방문하지 않고 단말기를 이용해 검침 데이터를 읽고 컴퓨터 운영프로그램과 연계해 고지서 발급은 물론 수요 패턴까지 효율적으로 관리할 수 있는 시스템 SDN : 하드웨어 중심의 네트워크를 소프트웨어 기반으로 전환시키는 것 DLP : 기업 내부자의 고의나 실수로 인한 외부로의 정보 유출을 방지하는 솔루션 MDM : OTA(Over The Air, 휴대폰무선전송기술)을 이용하여 언제 어디서나 모바일기기가 Power On 상태로 있으면 원격에서 모바일 기기를 관리할 수 있는 시스템 SCM : 제조, 물류, 유통업체 등 유통 공급망에 참여하는 모든 업체들이 협력을 바탕으로 정보기술을 활용, 재고를 최적화하고 리드 타임을 대폭적으로 감축하여 결과적으로 양질의 상품 및 서비스를 소비자에게 제공함으로써 소비자 가치를 극대화하기 위한 21세기 기업의 생존 및 발전전략 디지털 프로슈머 : 인터넷 커뮤니티에 참여해 콘텐츠를 즐기고 정보와 자료를 얻는 소비자이면서 동시에 의견을 적극 개진해 생산에도 영향을 미치는 사람 크리슈머 : 프로슈머보다 발전된 개념으로 소비를 통해 욕구를 충족하는 수준을 넘어 자신의 개성을 표현하는 창조적인 소비자 올랩 : 이용자가 직접 데이터베이스를 검색, 분석해서 문제점이나 해결책을 찾는 분석형 애플리케이션 개념 디지털 발자국 : 사람들이 여러 웹페이지에 로그인을 하거나 결제 정보를 입력하는 등 온라인 활동을 하면서 남긴 기록 웨버홀리즘 : 생물학적 데이터를 수집, 관리하는 기술 노모포비아 : 스마트폰 등 휴대전화가 없을 때 초조해하거나 불안감을 느끼는 증상을 일컫는 말 생물 정보학 : 생물학적 데이터를 수집, 관리하는 기술 모바일컴퓨팅 : 무선 이동통신과 PDA, 인터넷을 통해 컴퓨터와 통신기술을 효과적으로 연계시켜 언제, 어디서나 이동하면서 정보교환이나 수집, 검색, 정리, 저장하는 기술 소셜다이닝 : SNS를 통해 관심사가 비슷한 사람끼리 만나 식사를 즐기며 인간관계를 맺는 것 소셜엔지니어링 : 컴퓨터 보안에서 인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안 절차를 깨트리기 위한 비기술적 시스템 침입 수단 CC : IT 제품의 보안성을 평가하기 위한 국제 기준 ERM : 기업의 모든 단위업무별로 흐름도를 분석하여 어떤 과정에 어느 정도의 위험요인이 있는지 평가하여 전 조직원들이 공유하도록 함 USIM : 사용자 인증과 글로벌 로밍, 전자상거래 등 다양한 기능을 1장의 카드에 구현한 것 원격 현장감 : 공간적으로 떨어져 있는 장소 또는 가상의 장소를 신체적으로 경험하는 것 ISO20000 : 국제표준화기구(ISO)가 2005년 발표한 IT서비스관리(ITSM) 국제 표준 SLA : 서비스 사업자와 서비스 사용자가 제공될 정보 서비스 및 그와 연관된 여러 조건들에 대한 서로의 책임과 의무 사항을 기술해 놓은 협약서 플래시메모리 : RAM과 ROM의 장점을 한 대 묶은 메모리 VOD : 방송 프로그램을 시청자의 요구에 따라 시간과 공간을 초월하여 제공하는 시스템 IMS : 인터넷 프로토콜(IP)을 기반으로 음성, 오디오, 비디오 및 데이터 등의 멀티미디어 서비스를 제공하는 규격 NDN : 콘텐츠 중심 네트워크와 동일한 개념 포스퀘어 : 구글에서 독립한 데이스 크롤리(Dennis Crowley)가 2009년 3월에 발표한 위치기반 소셜네트워크서비스 정보전염병 : ‘정보’와 ‘전염병’의 합성어 해시태그 : #(샤프 기호)와 특정 단어(들)을 붙여 쓴 것 스모크테스팅 : 소프트웨어 일부를 개발한 후 본격적인 시험 수행에 앞서 소프트웨어의 결함을 식별하고 변경의 유효성을 검사하는 시험의 형태 랜섬웨어 : 인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 스프레트시트, 그림파일 등을 암호화해 열지 못하도록 만든 후 돈을 보내주면 해독용 열쇠 프로그램을 전송해 준다며 금품을 요구하는 악성 프로그램 포직스 : 서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격 비트코인 : 사토시 나카모토라는 필명의 프로그래머가 개발하였다. 실제 생활에서 쓰이는 화폐가 아니라 온라인 거래상에서 쓰이는 가상화폐 코드커터족 : 지상파와 케이블 등 기존 텔레비전 방송 서비스를 해지하고 인터넷 방송 서비스를 선택하는 소비자군 핀테크 : 금융과 IT의 융합을 통한 금융서비스 및 산업의 변화를 통칭 트랙백 : 다른 사람의 글을 읽고 그 글에 직접 댓글을 올리는 대신에 자신의 블로그에 글을 올리고 글의 일정 부분이 다른 사람의 댓글로 보이도록 하는 것 subscription commerce : 구매자가 정기 구독료나 가입비를 서비스업체에 지급하면 해당 업체가 상품을 알아서 선정해 정기적으로 배달해주는 상거래 재핑효과 : 채널을 돌리다가 중간에 있는 채널의 시청률이 높아지는 현상 IOT : 가전제품, 전자기기뿐만 아니라 헬스케어, 원격검침, 스마트홈, 스마트카 등 다양한 분야에서 사물을 네트워크로 연결해 정보를 공유 스마트 그리드 : 기존의 전력망에 정보기술(IT)을 접목하여 전력 공급자와 소비자가 양방향으로 실시간 정보를 교환함으로써 에너지 효율을 최적화하는 차세대 지능형 전력망 NFC : 10cm 이내의 가까운 거리에서 다양한 무선 데이터를 주고받는 통신 기술 IAM : 조직이 필요로 하는 보안 정책을 수립하고 정책에 따라 자동으로 사용자의 계정과 권한을 관리하는 솔루션 NScreen : 하나의 콘텐츠를 스마트폰ㆍPCㆍ스마트TVㆍ태블릿PCㆍ자동차 등 다양한 디지털 정보기기에서 공유할 수 있는 컴퓨팅ㆍ네트워크 서비스 APT : 다양한 IT 기술과 방식들을 이용해 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격 제우스 : 사용자의 온라인 뱅킹 계정 정보를 탈취하기 위해 개발된 상용 멀웨어 DES : 데이터 암호화 표준으로, 대표적인 비밀키 암호화 기법 widget : 컴퓨터에서 운영체제의 응용 프로그램을 동작시키고 결과를 화면에 표시하는 작은 그래픽사용자 인터페이스(GUI) 도구 죽음의 핑 : 인터넷 프로토콜 허용 범위 이상의 패킷을 고의로 전송하여 발생한 서비스 거부 공격 인터넷 제어 메시지 프로토콜 : 인터넷 프로토콜과 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로의 변경 등을 위한 제어 메시지를 취급하는 무연결 전송용의 프로토콜 SYN : 동기식 신호 방식에서 동기를 유지하기 위한 신호로 사용되는 전송 제어 문자 UWB : 초광대역을 사용하는 초고속의 무선 데이터 전송 기술 WPA : Wi-Fi에서 제정한 무선 랜 인증 및 암호화 관련 표준 동기식 접속 지향 링크(SCO) : 블루투스 데이터 링크의 하나. 두 장비 간에 음성과 같이 지정된 대역폭 통신을 위한 전용 회선의 동기식 접속 방법이다. 스턱스넷 : 독일 지멘스사의 원격 감시 제어 시스템(SCADA)의 제어 소프트웨어에 침투하여 시스템을 마비하게 하는 악성 코드 래드섹 : 네트워크 이용자의 인증을 위해 전송 제어 프로토콜 ‘RADIUS over TLS(Transport Layer Security)’의 준말 OWASP : 개방형 웹 애플리케이션 보안 프로젝트 스니핑 : 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나 BLE : 저전력 저용량 데이터 송수신이 가능한 블루투스 기술 인포러스트 : 정보와 열광의 합성어로 ‘정보열광자’라고도 한다 텔레매틱스 : 통신과 정보과학의 합성어로 자동차와 컴퓨터·이동통신 기술의 결합을 의미하는 개념 킬스위치 : 분실한 정보기기를 원격으로 조작해 개인 데이터를 삭제하고 사용을 막는 일종의 자폭 기능 SAN : 광저장장치영역 네트워크 스마트 카 : 자동차와 IT 기술을 융합하여 인터넷 접속이 가능한 자동차 씬 클라이언트 : 서버 기반 컴퓨팅 AR : 실제 화면에 가상의 정보를 덧붙여 보여주는 기술. 집단 지성 : 다수의 개체가 서로 협력하거나 경쟁하여 얻게 되는 지적 능력의 결과로 얻어진 집단적 능력 시멘틱 웹 : 컴퓨터가 이해할 수 있는 웹 DOS : 시스템에 과도한 부하를 일으켜 정보 시스템의 사용을 방해하는 공격 방식 유선급 프라이버시 : 유선 랜(LAN)에서 기대할 수 있는 것과 같은 보안과 프라이버시 수준의 무선 랜(WLAN)의 보안 프로토콜 LTE : 3세대 이동통신(3G)을 ‘장기적으로 진화’시킨 기술이란 뜻에서 붙여진 명칭 기밀성 : 정보보안 3가지 목표 중 인가된 사용자만 정보 자산에 접근할 수 있는 것을 의미 IPIN : 인터넷에서 주민등록번호 대신 쓸 수 있도록 만든 사이버 주민등록번호 IT 규제준수 : 기업의 활동이 정보시스템에 의존하는 바 기업이 따라야 하는 규정과 지침 및 법규를 준수하는 것 에스크로 : 전자 상거래 등에서 구매자와 판매자 사이에 중개 서비스 회사가 개입해 상품 인도와 대금 지불을 대행해 주는 서비스 OCAP : 모든 종합 유선 방송(CATV)에서 운용될 수 있도록 대화형(interactive) 텔레비전 서비스나 응용 프로그램을 설계할 수 있는 자바(Java) 기반의 미들웨어 소프트웨어 계층을 포함하는 디지털 케이블 방송 미들웨어 표준 데이지 : 시각장애인이나 독서 장애인을 위한 국제 디지털 문서 포맷 저작권 라이선스 통합 관리 시스템 : 정부가 디지털 저작물에 대한 체계적인 관리를 위해 추진하고 있는 시스템 사이버 스토킹 : 정보 통신망을 이용해 악의적인 의도로 지속적으로 공포감이나 불안감 등을 유발하는 행위 사이버 불링 : 특정인을 사이버상에서 집단적으로 따돌리거나 집요하게 괴롭히는 행위 RVC : 하나의 디지털 미디어 기기에서 다양한 콘텐츠를 재생할 수 있도록 만든 표준 WBAN : 몸에 심는(implant) 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술 그린 IT : 정보 기술(IT) 전 분야에서 유해 물질 사용을 자제하고 에너지 절감을 통해 친환경 제품과 서비스를 제공하는 개념 WBS : 광대역 전송을 지원하는 무선 통신 시스템 PKI : 공개 키 암호 시스템을 안전하게 사용하고 관리하기 위한 정보 보호 표준 방식 CA : 보안 적격 여부 및 메시지 암호화를 위한 공개 키의 발급과 관리를 담당하는 신뢰성이 보장된 온라인상의 기관 XML : 하이퍼텍스트 생성 언어(HTML) 기능을 확장할 목적으로 월드 와이드 웹 컨소시엄(WWW Consorsium)에서 표준화한 페이지 기술 언어 BCP : 재난 발생 시 비즈니스의 연속성을 유지하기 위한 계획 인증서 폐기 목록 : 더 이상 유효하지 않은 인증서 목록 보안토큰 : 전자 서명 생성 키 등 비밀 정보를 안전하게 저장, 보관할 수 있고 기기 내부에 프로세스 및 암호 연산 장치가 있어 전자 서명 키 생성, 전자 서명 생성 및 검증 등이 가능한 하드웨어 장치 DDOS : 감염된 대량의 숙주 컴퓨터를 이용해 특정 시스템을 마비시키는 사이버 공격 LED : 전류가 흐르면 빛을 방출하는 다이오드의 한 종류 복호화 : 암호화 과정의 역과정 이중인증 : 기존의 아이디 및 비밀번호에 의한 인증 외에 인증 수단을 추가적으로 사용토록한 것 W3C : 월드 와이드 웹 브라우저/서버 기술의 표준화를 추진하고 있는 교육/연구 기관 및 관련 회사들의 단체 메타데이터 : 일련의 데이터를 정의하고 설명해 주는 데이터 생체 인식 : 개인마다 다른 신체 정보를 이용하여 개인을 식별하는 인증방법 증분 백업 : 데이터 영역 중 변경되거나 증가된 데이터만을 백업 받는 방식 RTO : 비상사태 또는 업무중단 시점부터 업무가 복구되어 다시 정상가동 될 때까지의 시 무결성 : 정보보안 3가지 목표 중 적절한 권한을 가진 사용자에 의해 인가된 방법으로만 정보를 변경할 수 있도록 하는 것을 의미한다. 가용성 : 정보보안 3가지 목표 중 정보 자산에 대해 적절한 시간에 접근 가능한 것을 의미한다. 살라미 : 이탈리아 소시지를 얇게 썬다는 의미로 계좌를 불법으로 조금씩 옮기는 해킹 다크 데이터 : 정보를 수집한 후, 저장만 하고 분석에 활용하고 있지 않는 다량의 데이터 블록 체인 : 온라인 금융 거래 정보를 블록으로 연결하여 피투피(P2P) 네트워크 분산 환경에서 중앙 관리 서버가 아닌 참여자(피어, peer)들의 개인 디지털 장비에 분산·저장시켜 공동으로 관리하는 방식 그레이웨어 : 정상 소프트웨어와 바이러스 소프트웨어의 중간에 해당하는 일종의 악성 소프트웨어 타이포스쿼팅 : 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 일 파밍 : 합법적으로 소유하고 있던 사용자의 도메인을 탈취하거나 도메인네임시스템(DNS) 이름을 속여 사용자들이 진짜 사이트로 오인하도록 유도하여 개인 정보를 훔치는 신종 인터넷 사기 수법 QOS : 인터넷이나 네트워크 상에서 전송률 및 에러율과 관련된 서비스 품질을 가리키는 말 QOE : 서비스 이용자가 각자의 기대치(expectation)에 근거하여 주관적으로 인지하는 어플리케이션 혹은 서비스의 총체적인 허용도 AJAX : 비동기적인 웹 애플리케이션의 제작을 위해 자바스크립트 언어와 기타 웹 표준을 사용하는 기술 제로데이 공격 : 보안 취약점이 발견되었을 때 그 문제의 존재 자체가 널리 공표되기도 전에 해당 취약점을 악용하여 이루어 지는 보안 공격 크라우드소싱 : 군중(crowd)과 외부 용역(outsourcing)의 합성어 IPV6 : IPv4 프로토콜의 주소가 32비트라는 제한된 주소 공간 및 국가별로 할당된 주소가 거의 소진되고 있다는 한계점으로 인해 지속적인 인터넷 발전에 문제가 예상되어, 이에 대한 대안으로 개발된 프로토콜 LBSNS : 스마트폰에 내장된 GPS수신기를 통해 고객의 위치를 인식하고 이를 바탕으로 각종 이벤트의 정보공유, 의사소통까지 가능하게 하는 서비스. DMB : 음성, 영상 등 다양한 멀티미디어 신호를 디지털 방식으로 고정·휴대·차량용 수신기에 제공하는 방송 서비스 지상파 DMB : ITU-R의 디지털 라디오의 표준 DSB System A(Eureka-147)에 기반하여 우리나라에서 개발한 지상파 디지털 멀티미디어 방송 표준 킬러앱 : 오랜 기간 시장을 지배하고 있던 경쟁자를 압도한 소프트웨어 EA : 기업의 목표와 요구 사항을 효과적으로 지원하기 위해 정보 기술(IT) 인프라 각 부분의 구성과 구현 기술을 체계적으로 기술하는 작업 디지털 포렌식 : ‘컴퓨터 법의학’이라 불리는데 전자증거물을 사법기관에 제출하기 위해 휴대폰, PDA, PC, 서버 등에서 데이터를 수집 분석하는 디지털수사과정 펨토셀 기지국 : 사무실이나 집에 설치하는 초소형 이동 통신 기지국 NRI : 세계 경제 포럼(WEF)이 국제적인 경영대학인 인시아드(INSEAD)와 공동으로 개인과 정부, 기업의 정보통신기술(ICT) 발전도와 경쟁력을 국가별로 평가한 지수 데이터 마이닝 : 각 데이터의 상관관계를 인공 지능 기법을 통해 자동적으로 찾아 주는 과정 EDI : 기업 간 전자상거래 서식 또는 공공 서식을 서로 합의된 표준에 따라 표준화된 메시지 형태로 변환해 거래 당사자끼리 통신망을 통해 교환하는 방식 고객 관계 관리 : 기업이 고객을 관리하기 위해 필요한 방법론이나 소프트웨어 등을 가리키는 용어 VOIP : 공중 교환 전화망(PSTN)을 통해 이루어졌던 음성 서비스를 IP 네트워크를 통해 음성을 디지털 패킷의 형태로 전달하는 기술 CTTH : 기존 케이블 방송망으로 초고속/대용량 서비스를 제공하는 새로운 전송 방식. 총 1Gbps 용량을 여러 가입자가 공유하는 구조로 일반 가정에 130Mbps의 빠른 인터넷 속도를 제공 C4I : 군의 전 자원을 전산화하고 네트워크로 연결해 효율적인 전쟁을 수행할 수 있도록 한 통합 전장 관리 체계 멀웨어 : 악의적인 목적으로 작성된 것으로 악성 코드(Malicious Code) 또는 악성 프로그램(Malicious Program) 등으로 불린다 SEO : 검색 엔진에서 검색했을 때 상위에 나타나도록 관리하는 것 특허괴물 : 특허권을 비롯한 지적 재산권을 통해 로열티 수입만으로 이익을 창출하는 특허 관리 전문 기업 건물 에너지 관리 시스템 : 빌딩 내 에너지 관리 설비의 다양한 정보를 실시간 수집ㆍ분석해 에너지 사용 효율을 개선하는 시스템 우주클럽 : 자국 영토에서 자국 기술로 인공위성 및 우주선 발사가 가능한 국가들의 모임 글로나스 : 러시아의 전파 위성 항법 시스템이다 SSO : 단 한번의 로그인만으로 기업의 각종 시스템이나 인터넷 서비스에 접속하게 해주는 보안 응용 솔루션 OTP : 로그인 할 때마다 그 세션에서만 사용할 수 있는 일회성 패스워드를 생성하는 보안 시스템 위성DMB : 디지털 비디오·오디오 및 데이터 등의 방송 프로그램 신호를 위성 송신 설비 및 지상 중계 설비를 이용해 극초단파 대역에서 방송하는 것 VHF : 파장이 더 긴 전파와는 달리 이 전파는 대기에서 심하게 반사하지 않기 때문에 지구의 굴곡을 따라 쉽게 휘지 않고 따라서 지평선 너머로는 전송할 수 없다. LBS : 이동성(Mobile) 기기를 통해 각종 교통 및 생활 정보를 실시간으로 받아 삶의 질을 향상시키는 서비스를 총칭 ITS : 교통수단 및 교통 시설에 전자·제어 및 통신 등 첨단 기술을 접목하여 교통 정보 및 서비스를 제공하고 이를 활용함으로써 교통 체계의 운영 및 관리를 과학화·자동화하고, 교통의 효율성과 안전성을 향상시키는 교통 체계 GPS : 1970년대 초 미국 국방부가 지구 상에 있는 물체의 위치를 측정하기 위해 만든 군사용 시스템이었다. 그러나 오늘날에는 미 의회의 승인을 거쳐 민간부문에서도 사용되고 있다 GIS : 지도에 관한 속성 정보를 컴퓨터를 이용해서 해석하는 시스템 데이터 웨어하우스 : 정보와 창고의 의미가 합성되어 만든 어휘 데이터 마트 : 데이터의 한 부분으로서 특정 사용자가 관심을 갖는 데이터들을 담은 비교적 작은 규모의 데이터 웨어하우스 EIS : 기업의 상급 경영 관리직의 전략 구상을 지원할 목적으로 구축된 시스템 위피 : 한국형 무선 인터넷 플랫폼 표준 규격 그룹웨어 : 여러 사람이 함께 쓸 수 있는 소프트웨어 부여 리눅스 : 공개소프트웨어 리눅스의 한국형 데스크톱 및 서버용 운영체제 표준 배포판 롱테일 : 1년에 단 몇 권밖에 팔리지 않는 ‘흥행성 없는 책’들의 판매량을 모두 합하면, 놀랍게도 ‘잘 팔리는 책’의 매상을 추월한다는 온라인 판매의 특성을 이르는 개념 망 중립성 : 모든 네트워크 사업자는 모든 콘텐츠를 동등하게 취급하고 어떠한 차별도 하지 않아야 한다는 원칙 반달리즘 : 다수가 참여할 수 있도록 공개된 문서의 내용을 훼손하거나 엉뚱한 제목으로 변경하고 낙서를 하는 일 OSMU : 우수한 기획을 통해 제작된 1차 콘텐츠를 시장에 성공 시킨후 재 투자 및 라이센스를 통해 2차, 3차 콘텐츠로 발전시키는 전략 포스트넷 : 우체국 택배와 국제 특별 수송(EMS)을 강화하기 위해 우편물에 RFID 칩을 달아 언제 어디서나 실시간으로 그 우편물의 위치를 확인할 수 있는 우편 물류 시스템","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-알고리즘","slug":"정보처리기사-알고리즘","date":"2018-10-04T11:38:18.000Z","updated":"2018-11-26T07:22:24.497Z","comments":true,"path":"2018/10/04/정보처리기사-알고리즘/","link":"","permalink":"http://eunajjing.github.io/2018/10/04/정보처리기사-알고리즘/","excerpt":"","text":"알고리즘과 소프트웨어 개발 소프트웨어 생명주기 개발 타당성 검토 개발 계획 수립 요구사항 분석 소프트웨어 설계 소프트웨어 구현 테스트 운용 유지보수 소프트웨어 관리요구관리형상관리유지관리품질관리 효율성 신뢰성 기능성 사용성 이식성 유지보수성 알고리즘의 효율성공간 효율성 고정 공간 가변 공강시간 효율성 (빅오 표기법) 번역 시간 실행 시간 소프트웨어 아키텍처 MVC 구조 C/S 구조 다층 구조 저장소 구조 객체지향설계의 개념과 원리 분류화 캡슐화 추상화 일반화 다형성 동적 바인딩 소프트웨어 디자인 패턴 리팩토링 SOLID : 객체지향설계의 5대 원칙 단일 책임의 원칙 개방 폐쇄 원칙 리스코프 교환 원칙 인터페이스 분리 원칙 의존관계 역전 원칙 소프트웨어 테스트 기법 화이트박스 테스트 기법 블랙박스 테스트 기법 소프트웨어 3R 재공학 역공학 재사용 소프트웨어 개발 방법론폭포수 방법론애자일 방법론 스크럼 XP","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-DB_4","slug":"정보처리기사-DB_4","date":"2018-10-01T10:37:51.000Z","updated":"2018-10-07T08:18:39.983Z","comments":true,"path":"2018/10/01/정보처리기사-DB_4/","link":"","permalink":"http://eunajjing.github.io/2018/10/01/정보처리기사-DB_4/","excerpt":"","text":"인덱스 인덱스 파일 : 데이터의 위치 관리 [키 값, 주소] 데이터 파일 : 실제 데이터 기억 인덱스 구조B-트리: 검색 효율을 높이기 위해 자료 구조를 트리 구조로 나타내는 방법 B+-트리: B-트리의 변형으로 인덱스 세트와 순차 세트로 구성 클러스터드 인덱스 하나의 속성을 기준으로 정렬 후 테이블을 재구성해 인덱스를 만드는 방법 물리적 순서와 인덱스 순서 동일 하나의 테이블에 하나의 인덱스 넌 클러스터드 인덱스 주소값으로 인덱스를 만들어 검색 여러 개의 인덱스 OODB 객체 속성 메시지 메소드 클래스 캡슐화 상속 다형성 복합 객체 : 한 객체가 가진 속성으로 다른 객체를 이용하기 위한 것, FK와 유사한 개념 보안정보 보안의 목표 기밀성 : 허락되지 않은 대상이 정보의 내용을 알 수 없도록 하는 것 무결성 : 허락되지 않은 대상이 정보를 수정/삭제할 수 없는 것 가용성 : 허락된 대상이 정보에 접근하고자 할 때 방해받지 않는 것 보안 어휘 평문과 암호문 암호화와 복호화 대칭키 시스템 : 암호화와 복호화의 키가 동일 비대칭키 시스템 : 암호화할 때는 공개키, 복호화할 때는 비밀키 이용, 공개키와 비밀키를 키 페어라고 한다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-DB_3","slug":"정보처리기사-DB_3","date":"2018-10-01T09:59:27.000Z","updated":"2018-10-07T08:18:39.983Z","comments":true,"path":"2018/10/01/정보처리기사-DB_3/","link":"","permalink":"http://eunajjing.github.io/2018/10/01/정보처리기사-DB_3/","excerpt":"","text":"이상과 정규화 이상DB 내 데이터의 중복과 종속으로 인해 발생되는 문제점 삭제 이상: 원하지 않는 자료까지 함께 삭제가 이루어지는 이상 삽입 이상 : NULL이면 안되는 값에 NULL이 들어가 삽입이 안되는 이상 갱신 이상 : 갱신 과정에서 일부만 갱신되어 정보의 파악이 안되는 현상 함수적 종속 완전 함수 종속 부분 함수 종속 이행적 함수 종속 정규화 제1정규형(원자값): 한 릴레이션을 구성하는 모든 도메인이 원자값으로만 구성 제2정규형(부분 함수 종속 제거): 모든 속성이 기본키에 완전 함수 종속이 되도록 구성 제3정규형(이행적 함수 종속 분해) 보이스-코드 정규형(후보키가 아닌 결정자 관계 제거): 릴레이션에서 모든 결정자가 후보키(PK)가 되도록 하는 과정 제4정규형(다치 종속 관계 제거) 제5정규형(조인 종속 관계 제거): 조인 종속이 후보키를 통해서만 성립이 되도록 하는 정규형 역정규화릴레이션 역정규화릴레이션 병합릴레이션 분할 수직 분할 수평 분할 속성 역정규화(파생 속성 추가)트랜잭션 원자성 : 모두 수행되거나 모두 수행되지 않거나 일관성 : 완료되면 일관성 있는 DB 상태여야 한다 격리성 : 하나의 트랜잭션이 수행 중에는 다른 트랜잭션이 접근 할 수 없음 영속성 : 트랜잭션이 성공적으로 완료된 후 결과는 지속적으로 유지되어야 함 트랜잭션 스케줄 직렬 스케줄 : 순차적 비직렬 스케줄 : 비순차적 직렬 가능 스케줄 : 직렬 스케줄 기법의 결과와 비직렬 스케줄 기법의 결과가 동일하게 나오는 경우 회복 로그 : 트랜잭션이 수행되어 변경되는 데이터베이스 상황 정보를 기록(로그파일)하는 것 회복 기법 즉시 갱신 기법 : 트랜잭션 실행 중에 변경되는 내용을 바로 DB에 적용 지연 갱신 기법 : 트랜잭션이 부분 완료되면 DB에 적용 검사 시점 기법 : 트랜잭션 실행 중 검사 시점을 지정해 그 때 완료된 내용을 DB에 적용 그림자 페이징 : 로그를 사용하지 않고, DB를 동일한 크기의 단위인 페이지로 나누어 각 페이지마다 복사하여 보관하는 기법. 장애가 발생되면 그림자 페이지를 이용해 회복 REDO(재수행) UNDO(취소)병행 제어: 여러 트랜잭션이 실행되는 경우 트랜잭션 간의 격리성을 유지해 에러가 발생하지 않도록 하는 것 병행 제어를 하지 않았을 때의 문제점 갱신 분실 모순성 연쇄 복귀 비완료 의존성 : 하나의 트랜잭션 수행이 실패한 후 회복되기 전 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상 로킹 트랜잭션의 고립성 같은 것, 하나의 트랜잭션이 이미 DB에 접근해 있으면 다른 트랜잭션이 접근하지 못하게 막음 LOCK과 UNLOCK, 교착 상태가 있다. 공유락과 배타락이 있다. 2단계 로킹 기법에는 확장 단계와 축소 단계가 있다. 타임 스태프: 각 트랜잭션이 데이터에 접근할 시간을 미리 지정해 기억시킨 뒤 그 시간의 순서에 따라 순서대로 데이터에 접근하여 수행하는 방법","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-DB_2","slug":"정보처리기사-DB_2","date":"2018-09-28T11:01:27.000Z","updated":"2018-10-07T08:18:39.982Z","comments":true,"path":"2018/09/28/정보처리기사-DB_2/","link":"","permalink":"http://eunajjing.github.io/2018/09/28/정보처리기사-DB_2/","excerpt":"","text":"SQL DDL제약조건 primary key unique foreign key ~ references ~ check(속성명 = 범위 값) constraint 제역조건명 제약조건(속성명) 스키마 정의create schema 스키마명 authorization 유저명; 도메인 정의create domain 도메인명 데이터타입; 도메인에도 속성에 줄 수 있는 check 제약조건을 똑같이 명시 가능 (디폴트 값, check(value in(‘값’, ‘값’))) 인덱스 정의create index 인덱스명 on 테이블명(속성명) 외래키 지정 옵션 on delete on update cascade set null set default no action DML (헷갈리는 것 위주로 용어만 정리) order by(asc, desc) exists: 부속 질의문의 검색 결과 존재 여부에 따라 메인 쿼리 진행 여부가 달라짐 DCL grant: grant 권한내용 on 테이블명 to 유저명 [with grant option] with grant option: 자신이 가진 권한을 다른 유저에게도 부여가 가능하다 revoke: revoke 권한내용 on 테이블명 from 유저명 [cascade] 만약 권한을 취소 당한 유저가 다른 유저에게 해당 권한을 부여했다면, 그 권한 또한 연쇄적으로 취소된다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사 - DB_1","slug":"정보처리기사-DB_1","date":"2018-09-28T04:02:15.000Z","updated":"2018-10-07T08:18:39.982Z","comments":true,"path":"2018/09/28/정보처리기사-DB_1/","link":"","permalink":"http://eunajjing.github.io/2018/09/28/정보처리기사-DB_1/","excerpt":"","text":"데이터베이스 데이터베이스의 정의 공용 데이터 통합된 데이터: 하나의 주제에 따라 중복을 최소화한 데이터의 집합 저장된 데이터 운영 데이터 데이터베이스의 특징 내용에 의한 참조 계속적인 변화 동시 공유 실시간 접근성 데이터 중복의 최소화 DBMS: 사용자와 데이터베이스 간의 중계 역할을 하여 모든 사용자나 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리, 운영해주는 소프트웨어 시스템 데이터베이스의 특성 중복성 종속성 데이터베이스 언어 DCL DML DDL 스키마: 데이터베이스의 전체적인 구조와 제약조건 명세를 기술, 정의한 것 스키마 종류 설명 내부 스키마 물리적 저장 장치 관점 개념 스키마 논리적 사용자 관점 외부 스키마 사용자가 사용하는 한 부분에서 본 논리적 구조, 서브 스키마 데이터베이스 설계 요구 조건 분석 설계 설계 구분 개념적 설계 구축할 db 정하기, db 구성요소 정하기, 관계 설계 논리적 설계 사용자가 알아볼 수 있는 형태로 변환, 스키마 정의 물리적 설계 기계가 처리하기에 알맞게 내부 저장 장치 구조와 접근 경로 설계 구현 운영 및 개선(유지보수) 관계 데이터 모델 릴레이션: 테이블 속성 튜플: 레코드 도메인 릴레이션 인스턴스 : 튜플들의 집합 차수 : 속성의 수 카디널리티 : 튜플의 수 릴레이션의 특징 릴레이션의 튜플은 모두 상이하다. 릴레이션의 튜플들은 유일하며 순서에는 의미가 없다. 릴레이션의 속성들 간의 순서는 의미가 없다. 릴레이션의 속성 값은 원자값으로 구성되며 분해가 불가능하다. 유일성과 최소성 유일성 : 각 튜플을 유일하게 식별하는 성질 최소성 : 유일성을 만족하되 최소 구성으로 이루어진 것 무결성 제약조건 개체 무결성 : pk와 같은 것 참조 무결성 도메인 무결성 고유 무결성 null 무결성 키 무결성 : 하나의 릴레이션에는 하나 이상의 튜플이 존재해야만 한다. 관계 데이터 연산관계대수(절차적 언어)셀렉트(σ선택조건(테이블명))프로젝트(π칼럼명(테이블명))조인(테이블명▷◁조건 테이블명) 동일 조인 자연 조인 외부 조인 세타 조인 디비전(테이블명1(테이블명1의 속성 ÷ 테이블명2의 속성)테이블명2)일반 집합 연산자 합집합 교집합 차집합 카디션 프로덕트 관계해석(비절차적 언어, {결과값|조건})ex. {학점,이름|학점^학점.수강번호=’7777’^학점.점수&gt;=80} 용어 뷰 : 가상 테이블로 물리적으로 기억공간을 차지하지 않으며, 논리적 독십성을 제공하고 데이터 접근제어로 보안성 향상 내장 SQL : 일반 응용 프로그램에 SQL을 삽입해 DB 이용 및 조작을 할 수 있도록 한 것 커서 : 튜플 단위로 처리하는 것 declare : 사용할 커서 선언open : 커서를 첫 번째 튜플로 이동fetch : 다음 튜플로 이동close : 커서 종료 스토어드 프로시저 튜닝 : DB 시스템 최적화를 위해 재조정 하는 것 CRUD 매트릭스 : 응용 시스템과 DB 간의 업무 분석을 위한 상관 분석표 트리거 행 이주 : 저장 공간이 없을 때 블럭을 옮겨 저장하는 현상으로 데이터 타입이 varchar일 때 발생, 검색이 느려진다 행 연결 : 저장 공간이 적어 새로 입력하려는 데이터의 일부만 저장하고 일부는 다른 블럭에 저장해 두 블럭을 연결하는 방법 OLAP : 사용자가 직접 DB 검색과 분석을 통해 문제점이나 해결책을 찾도록 해주는 분석형 애플리케이션 MOLAP : 다차원 배열ROLAP : 관계형 DB를 기초로 함HOLAP : MOLAP + ROLAP 스타 스키마 : 활동한 내용을 수치로 표현한 사실 테이블, 추가적인 관점을 제공하는 차원 테이블로 구성\\ OLTP : 사용자 단말기에서 요청한 트랜잭션 처리를 중앙 컴퓨터에 처리해 처리 결과를 사용자 측으로 되돌려 보내는 처리 형태 시스템 카탈로그(=데이터 사전) : 개체들에 대한 정보와 정보들 간의 관계를 저장한 것(시스템 테이블) 메타 데이터 : 시스템 카탈로그 안에 저장된 데이터, 정보의 정보 DBA : DB 시스템의 전체적인 관리 운영에 책임을 지는 사람이나 집단 DA : 데이터 정의와 체계화, 감독 및 보안 업무를 담당하는 관리자이며 데이터에 대한 관리를 총괄하고 정보 활용에 대한 계획수립과 통제 수행자 E-R Model Mapping Rule : 개념적 데이터베이스 모델링에서 관계형 데이터베이스로 변환하는 과정 교차 엔티티 : 다대다 관계를 구현하기 위해 추가로 생성되는 엔티티 슈퍼키 : 후보키+다른 속성들과의 모든 조합으로, 유일성은 만족하지만 최소성은 만족하지 않는다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"first","slug":"first","date":"2018-09-24T00:08:52.000Z","updated":"2018-09-24T13:51:00.093Z","comments":true,"path":"2018/09/24/first/","link":"","permalink":"http://eunajjing.github.io/2018/09/24/first/","excerpt":"","text":"깃허브를 이용해서 블로그 만들기 그러니까, 도전은 한 3일 정도 된 듯참고 도움이 많이 된 포스트1도움이 많이 된 포스트2 보통 블로그로는 지킬과 헥소를 많이 사용하는 것 같은데,처음 블로그를 할 수 있음을 알려준 이가 헥소를 사용 중이기도 했고,헥소가 검색이 더 잘된다는 말이 있어서 나도 헥소로 만들기로 결정하고 만들기 위해 엄청 끙끙댔다. 저장소만 한 5번은 다시 만든 듯ㅋㅋㅋㅋ 왜인지 계속 경로 에러가 나서, 노드도 다시 깔고 별 짓을 다했다. 솔직히 아직…. 나는 포털 사이트가 제공해주는 블로그 사이트가 제일 편한 것 같은데. 어쨌든 개발자를 꿈꾸는데 블로그 하나 제대로 못 만들면 안될 것 같아서ㅠㅠㅠㅠ 정처기 시험 며칠 남지도 않았는데 이러고 있다. 때려칠 뻔한 대환장에러파티hexo YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line ~ 나는 수많은 이들이 구글과 깃의 이슈로 물은 YAMLException 때문에 대부분의 시간을 버렸다. 재미있게도 핵소 공홈에도 이 에러…는 트러블슈팅으로까지 올라와있는데, 나에게 있어서 별 도움은 안됐다. 핵소 공홈 트러블 슈팅// 18.09.24. 기준 제일 윗줄에서 확인 가능 대부분의 사람들이 해결책이라며 내놓은 건, 따옴표 표기 같은 거였다. 화가 난 나는 에러 메시지가 뜬 줄부터 아래까지 모조리 따옴표를 넣어버리는 미친 짓도 벌여봤지만 계속 에러 잼…ㅎㅎㅎ… 헥소 나한테 외그래… 며칠 째 똑같은 에러를 보고 있자니 너무 화가 나서 걍 딴짓할 겸 헥소의 트러블 슈팅 모두를 읽기 시작. 그러다가… Make sure you are using soft tabs and add a space after colons. 몇 번 반복하다가 맨 윗 문단의 마지막 문장이 눈에 띄어서, 혹시나 해서 살펴봤는데…. 내가 그 콜론 다음에 띄어쓰기를 잘못한 사람이었고…. 내가 추가로 쓴 옵션 칼럼에는 모조리 띄어쓰기가 없어서 나는 에러였다. 아니 근데 웃긴 게 그럼 띄어쓰기 없는 라인부터 에러라고 말을 해줘야지 왜 얘는 요상한 곳에서 에러 표기를 하는 거람. 웹단 처음 들어와서 강사님이 에러가 나면 그 줄부터 보지 말고, 그 위부터 읽는 거라고 그렇게 귀에 뭐가 박힐 듯 잔소리를 해댔는데. 여기서도 똑같은 실수를 했다. 모든 헥소를 이용한 깃허브 블로그 가이드에는 브랜치 두 개 만들라는 팁이 있어야 하는 거 아닌가? 사실 블로그 배포에 성공한 건 한 3번 정도인데, 매번 당황하고 지웠던 건 다름 아닌 소스 관리를 어떻게 해야할지 모르겠다는 거. 아예 파일 구조가 달라져버리는 터라, 풀 받는데 계속 에러가 났다. 구글링을 좀 해보니, 저장소를 아예 두 개 파서 운용하시는 분도 계셨고, 브랜치를 두 개 판 분도 계셨다-사실 브랜치 두 개가 다수였다- 아니 그러면 처음부터 브랜치 두 개 파라고 이야기를 해주던가ㅠㅠㅠ(위에 내가 참고했다는 블로그에는 아쉽게도 브랜치 두 개 생성 얘기는 없었다) 농담이 아니라 이 블로그 때문에 명절 연휴 통째로 날릴 삘….","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]}]}