{"meta":{"title":"ERecord","subtitle":"일상 및 개발 공부 기록용 블로그","description":"일상 및 개발 공부 기록용 블로그","author":"euna","url":"http://eunajjing.github.io"},"pages":[{"title":"Categories","date":"2016-08-16T06:00:44.000Z","updated":"2018-12-07T09:47:13.380Z","comments":false,"path":"categories/index.html","permalink":"http://eunajjing.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Express","slug":"2019-01-08-Express","date":"2019-01-08T05:45:18.000Z","updated":"2019-01-09T13:57:34.253Z","comments":true,"path":"2019/01/08/2019-01-08-Express/","link":"","permalink":"http://eunajjing.github.io/2019/01/08/2019-01-08-Express/","excerpt":"","text":"Express 경량 HTTP 웹 프레임워크 요청과 응답 미들웨어 사용 템플릿 엔진 사용 가능 Express 미들웨어 요청 분석 , 처리하는 모듈을 여러 개 쓸 수 있음 app.use(미들웨어)로 사용 12345app.use(function(req,res)&#123; res.send('Express');&#125;);// 이 경우 어떤 요청에 대한 함수인지 알 수 없음 npm install express로 시작 Express 생성 및 시작12345678910111213var express = require('express');var app = express();// 객체 생성하는 것과 유사// 여기까지가 세팅app.use(function(req, res) &#123; res.send('Hello World'); // 미들웨어로 익명함수 // res.write와 비슷함 // http보다 편하게 사용 가능&#125;);app.listen(3000);// 포트번호 3000번에서 대기 Http 모듈 서버와 Express 혼용1234var http = require('http');var express = require('express');var app = express();http.createServer(app).listen(3000); Express 라우팅 (routing) 요청에 따라 처리 미들웨어로 분배하는 것(프론트 컨트롤러의 역할) HTTP Method 별로 라우팅 가능 1234// GET 요청 - Hello Express로 응답app.get('/', function (req, res) &#123;&#125;);// POST 요청 - 응답app.post('/', function (req, res) &#123;&#125;); URL 경로 별로 라우팅 가능(REST PULL 같은…) 1234// user 경로에 GET 요청 - 응답app.get('/user', function (req, res) &#123;&#125;);// items 경로에 GET 요청 - 응답app.get('/items', function (req, res) &#123;&#125;); Express 요청 분석요청 분석 req.query : 쿼리 문자열 req.path : 요청 URL 중 경로 req.params : URL의 파라미터 req.cookie : 요청 메시지 내 쿠키(쿠키 파서 필요) req.body : 요청 메시지 바디 분석(바디 파서 필요) 응답 res.json() : JSON 응답 메시지 전송 res.redirect() : 리다이렉션 응답 전송 res.render() : 템플릿으로 렌더링 res.send() : JSON, HTML, Buffer 전송, 메시지 헤더에 Content-Type 자동 설정 res.sendStatus() : 상태 코드와 상태 메시지 전송 res.status() : 상태 코드 설정. 응답 메소드 종료 안함 res.download() : 파일 다운로드 미들웨어 함수 형태의 작은 모듈 요청과 응답 처리 함수 형태 미들웨어 설정 하기1234app.use(sayHello); function sayHello(req, res) &#123; res.send('Hello Express!!'); &#125; HTTP 메서드별 미들웨어 설정1234app.get('/movies' , showMovieList);app.post(‘/movies’, addMovieInfo);app.put(‘/movies/:id’, updateMovieInfo);// /:id라고 쓰면 id로 들어오는 것의 값을 뽑아 쓸 수 있다 next();12345678910app.use(function(req, res, next) &#123; var now = new Date(); console.log(now.toDateString() + ' - url : ' + req.url); // 다음 미들웨어 실행 next();&#125;);app.use(function(req, res) &#123; res.send('Hello Express!!');&#125;); 하나의 요청에 다수의 미들웨어를 파라미터로 지정12345678//하나의 요청에 다수 미들웨어// 두 미들웨어를 스택 형태로 설정app.use(logger, sayHello);// next()를 호출해야 sayHallo(req, res) 실행function logger(req, res, next) &#123; next();&#125;function sayHello(req, res) &#123; &#125; 그 외 내장 미들웨어 써드 파티 미들웨어 정적 파일 요청 처리 미들웨어 12app.use(express.static(‘images’));// 정적 파일 경로 미리 만들어주고 요청이 들어오면 자동으로 images 폴더 안에서 찾게끔 SERVER-ADDRESS/cute1.jpg -&gt; ./images/cute1.jpg SERVER-ADDRESS/images/cute1.jpg -&gt; ./images/image/cute1.jpg 가상 경로 설정 12345app.use('/static', express.static(‘files’));// 해당 url로 들어오면 files란 실제 폴더에서 찾는다// app.use(express.static(‘images’)); 와 다른 점은// url을 지정해준다는 점이 다름 만약 실패하면 다음의 미들웨어 진행 12app.use(express.static('public')); app.use(express.static('files')); 메서드 경로 별 라우팅 함수123456789101112app.get('/', function (req, res) &#123; res.send('GET request, /');&#125;);app.delete('/', function(req, res) &#123; res.send('DELETE method');&#125;);app.put('/item/1', function(req, res) &#123; res.send('PUT method, /item/1');&#125;);app.all('/all', function(req, res) &#123; res.send('모든 HTTP 메소드, /all');&#125;); 메서드 별로도 라우팅이 가능하다. 위의 예제는 메서드 + 경로까지 합쳐서 라우팅 함수를 정의한 것 동적 파라미터의 문법1app.get(‘/user/:item’, [Callback]); :블라블라가 핵심 사용할 때는 이렇게 쓴다. 다수의 동적 파라미터 사용이 가능하다. 사용 예제는 아래와 같다. 123456789app.get('/user/:id', function (req, res) &#123; var userId = req.params.id; ...&#125;);app.get('/movies/:movieId/:actor', function (req, res) &#123; var movieId = req.params.movieId; var actor = req.params.actor; ...&#125;); 경로에 정규 표현식도 사용 가능 ? : 문자 존재하거나 생략 + : 1번 이상 반복 * : 임의의 문자 1234567891011// /abcd, /acdapp.get('/ab?cd', function(req, res) &#123;&#125;)// /abcd, /abbcd, /abbbcdapp.get('/ab+cd', function(req, res) &#123;&#125;)// abcd, abxcd, abRABDOMcd, ab123cdapp.get('/ab*cd', function(req, res) &#123;&#125;)// /abe, /abcdeapp.get('/ab(cd)?e', function(req, res) &#123;&#125;) 에러 처리 미들웨어에러 처리 방법 미들웨어 내부에서 처리하거나 에러 처리 미들웨어에게 위임 1234// 에러 파라미터는 아래와 같다.app.use(function(err, req, res, next) &#123; res.status(500).send(‘에러 발생!');&#125;); 123456// 에러 처리 미들웨어로 에러 전달app.use(function(req, res, next) &#123; var error = new Error(‘에러 메세지’) error.code = 100; return next(error);&#125;); 1234567891011121314// 환경 별 에러 처리 코드if (app.get('env') === 'development') &#123; // 환경 쪽에서 에러가 나면 app.use(function(err, req, res, next) &#123; res.end(err.stack); &#125;); // 미들웨어 실행&#125;else &#123; app.use(function(err, req, res, next) &#123; res.status(err.code || 500); res.end('잠시 후 다시 시도해주세요'); &#125;);&#125; express의 route 함수1234567891011121314app.route(‘/book')// 경로가 /book으로 들어오긴 했는데// 상단에 기재를 해두고// 메서드 별로 분리// 이렇게 하면 미들웨어를 분리할 수 있다는 장점이 있다 .get(function(req, res) &#123; res.send('Get a random book'); &#125;) .post(function(req, res) &#123; res.send('Add a book'); &#125;) .put(function(req, res) &#123; res.send('Update the book'); &#125;); 라우팅 로직 별로 분리 가능 1234567// router.jsvar express = require(‘expres’);var router = express.Router();router.get('/hello', sayHello);router.get('/howAreYou/:who', sayThankYou);module.exports = router; 123// 이렇게 사용도 되고,app.use(require('./router')); 123//greeting/hello 경로의 요청이 들어오면 router 모듈 사용// 이렇게 사용도 된다!app.use('/greeting', require('./router’)); 로그 처리1234console.info(‘Info Message’);console.log(‘Log Message’)console.warn(‘Warn Message’)console.error(‘Error Message’) 로그 미들웨어 (morgan) npm install morgan로 시작 요청과 응답을 자동으로 로그 남김 12var morgan = require('morgan');app.use(morgan('dev')); 바디 파서 POST 메서드 요청 : 요청 메시지 바디 분석 가능 npm install body-parser로 설치 필요 Body 메시지 인코딩 타입 json 12bodyParser.json(option)app.use(bodyParser.json()); Raw Text URL-Encoded 1app.use(bodyParser.urlencoded(&#123; extended: false &#125;)) 바디파서는 멀티 파트 메세지 파싱 불가능(formidable , multer 같은 써드 파티 미들웨어 사용) 사용 예제 12345678910111213// 바디파서를 사용하지 않은 기존 예제function addMovie(request, response) &#123; var buffer = ''; request.on('data', function(chunk) &#123; buffer += chunk; &#125;); request.on('end', function() &#123; // 바디 파싱 var query = querystring.parse(buffer); var name = query.name; var director = query.director; &#125;);&#125; 위의 코드를 아래로 123456789101112131415var express = require('express');var bodyParser = require('body-parser');var app = express();app.listen(3000);// 세팅해주고app.use(bodyParser.urlencoded(&#123;extended:false&#125;));// extended 는 중첩된 객체표현을 허용할지 말지를 정하는 것// 객체 안에 객체를 파싱할 수 있게 하려면 trueapp.use(bodyParser.json());// 바디파서 세팅function addMovie(req, res) &#123; var name = req.body.name; var director = req.body.director;&#125; 이렇게 쓴 예제도 있다 1234567app.post('/', function (req, res) &#123; var title = req.body.title; var message = req.body.message; res.send('title : ' + title + ' message : ' + message); &#125;); Express Template템플릿 엔진 ejs HTML 태그 그대로 사용 코드 실행 : &lt;% %&gt; 결과 출력 : &lt;%= %&gt; 1234567891011121314&lt;% var value = ‘hello’ %&gt;&lt;% var i = 0 var j = i + 1 var data = [&#123;title:&apos;야구&apos;, image:’baseball.png’&#125;,…];%&gt;&lt;% if ( value ) &#123; %&gt;&lt;div&gt; &lt;%= value %&gt; &lt;img src=“&lt;%= data.image %&gt;”&gt;&lt;/div&gt;&lt;% &#125; %&gt;&lt;% var tag = &apos;h1&apos; %&gt;&lt;&lt;%= tag %&gt;&gt; TAG 만들기 &lt;/&lt;%= tag %&gt;/&gt; jade Express 템플릿 설정 123456app.set('views', [템플릿 폴더]);app.set('view engine', [템플릿 엔진]);// 예시app.set('views', __dirname + '/views');app.set('view engine', 'ejs'); 템플릿에 적용 : 렌더링 123456789101112131415res.render(view [, locals] [, callback])// locals : 템플릿의 지역 변수로 설정될 데이터// callback : 렌더링 콜백// 리졸버와 비슷함// 예시// index 템플릿 파일을 렌더링한 결과로 응답// 페이지만 준다res.render('index');// index 템플릿 파일에 name 이름으로 데이터를 제공res.render('index', &#123; name: 'IU' &#125; );// user 템플릿에 name 이름으로 데이터를 제공한다. 렌더링 한 결과를 다루는 콜백 함수 정의res.render('user', &#123; name: 'IU' &#125;, function(err, html) &#123; // ...&#125;); 예시 123456// jsapp.set('views', __dirname + '/views');app.set('view engine', 'ejs');var data = [&#123;title:'야구', image:’baseball.png’&#125;,…];res.render('sports', &#123;title:'구기 종목',sports:data&#125;);// sports는 배열이다 123456789&lt;!-- sports.ejs --&gt;&lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;&lt;ul&gt;&lt;% sports.forEach(function(item) &#123; %&gt; &lt;!-- sports는 객체 배열,item에는 &#123;title:&apos;야구&apos;, image:’baseball.png’&#125;가 들어온다 --&gt; &lt;li&gt; &lt;img src=&quot;images/&lt;%= item.image %&gt;&quot; height=&quot;50px&quot;&gt; &lt;%= item.title %&gt; &lt;/li&gt;&lt;% &#125;) %&gt;&lt;/ul&gt;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"node JS","slug":"newdeal_node","date":"2019-01-07T03:43:18.000Z","updated":"2019-01-09T13:27:16.013Z","comments":true,"path":"2019/01/07/newdeal_node/","link":"","permalink":"http://eunajjing.github.io/2019/01/07/newdeal_node/","excerpt":"","text":"node 기초 1234567891011121314151617181920var util = require('util');function Parent() &#123;&#125;Parent.prototype.sayHello = function() &#123; // parent를 부모로 하는 것들은 // sayhello 함수를 쓸 수 있게 붙인다 // prototype 원시타입 // function 키워드가 class도 생성 가능 console.log('Hello World, from Parent Class!');&#125;var obj = new Parent();obj.sayHello();function Child() &#123;&#125;// 상속util.inherits(Child, Parent);var obj2 = new Child();obj2.sayHello(); 기본 모듈https://nodejs.org/dist/latest-v10.x/docs/api/process.html 문서 에서 확인 프로세스 환경 : os, process 파일과 경로 , URL : fs, path, URL, querystring, stream 네트워크 모듈 : http, net, dns 전역객체(global) (Java 에서 Console 클래스 사용하는 것처럼 ….)별도의 모듈 로딩 없이 사용가능global.console.log() &gt;&gt; console.log() &gt;&gt; global 생략가능 전역객체 process console Buffer require __filename, __dirname module exports Timeout 함수 등 실습 12345// process.jsconsole.log(process.env);console.log(process.arch);console.log(process.platform); 1234567// timeout.jsfunction sayHello() &#123; console.log('Hello World');&#125;setTimeout(function() &#123; sayHello();&#125;, 2*1000); 1234//interval.jsfunction sayGoodbye(who) &#123; console.log('Good bye', who); &#125; 1234567891011//console.jsvar intVal = 3;var obj = &#123; name : 'NodeJS', how : 'Interesting'&#125;;console.log('hello world');console.log('intVal : ' + intVal);console.log('obj : ' + obj);console.log('obj : ', obj);setInterval(sayGoodbye, 1 * 1000, 'Friend'); 1234567891011// console_custom.jsvar fs = require('fs');var output = fs.createWriteStream('stdout.log');var errorOutput = fs.createWriteStream('error.log');var Console = require('console').Console;var logger = new Console(output, errorOutput);logger.info('info message');logger.log('log message');logger.warn('warning');logger.error('error message'); 123456789// consoleTime.jsconsole.time('TIMER');var sum = 0;for(var i = 1 ; i &lt; 100000; i++ ) &#123; sum += i;&#125;console.log('sum : ', sum);console.timeEnd('TIMER'); 1234567// util.jsvar util = require('util');var str1 = util.format('%d + %d + %d', 1, 2, (1+2));console.log(str1);var str2 = util.format('%s %s', 'Hello', ' NodeJS');console.log(str2); Node.js 애플리케이션의 이벤트들 클라이언트의 접속 요청 소켓에 데이터 도착 파일 오픈/읽기 완료 이벤트 처리 비동기 처리 리스너 함수 1234process.on('exit', function() &#123;console.log('occur exit event');&#125;); process.once('exit', function() &#123;console.log('occur exit event');&#125;);process.emit('exit'); //이벤트 발생 경로 : path 1var pathUtil = require('path'); 경로정보 전역객체__filename__dirname 같은 폴더 내 이미지 경로 1var path = __dirname + '/image.jpg'; 12345678910// path.jsvar pathUtil = require('path');var path = 'C:\\NewDeal\\Script\\read.txt';console.log('dirname : ', pathUtil.dirname(path));console.log('basename : ', pathUtil.basename(path));console.log('extname : ', pathUtil.extname(path));console.log(__dirname);console.log(__filename); 파일 시스템 다루기 파일 시스템 모듈 : fs 1var fs = require(‘fs’); 주요 기능 파일 생성/읽기/쓰기/삭제 파일 접근성/속성 디렉토리 생성/읽기/삭제 파일 스트림주의 : 모든 플랫폼에 100% 호환되지 않음(윈도우, 리눅스 파일 경로 다르듯) fs 모듈 사용시 비동기식 : callback 사용 논-블럭 방식 123456789fs.readFile('textfile.txt', 'utf8',function(error, data) &#123;&#125;); fs.readFile('none_exist.txt', 'utf-8', function(err, data) &#123; if ( err ) &#123; console.error('Readfile error ', err); &#125; else &#123; // 정상 처리 &#125; &#125;); 동기식 : readFileSync 블럭방식 : 성능상 주의 123456var data = fs.readFileSync('textfile.txt', 'utf8'); try &#123; var data = fs.readFileSync('none_exist.txt', 'utf-8');&#125;catch ( exception ) &#123; console.error('Readfile Error : ', exception); &#125; 123456789var fs = require('fs');fs.writeFile('textData.txt', 'Hello World', function(err) &#123; if ( err ) &#123; console.error('Error : ', err); return; &#125; console.log('Write');&#125;); 12345678910111213141516171819202122232425262728293031323334353637// FileRead.jsvar fs = require('fs');var file = 'read.txt';fs.access(file, fs.F_OK, function(err) &#123; if ( err ) &#123; console.log('파일 없음'); process.exit(1); &#125; else &#123; console.log('파일 존재'); fs.stat(file, function(err, stats) &#123; if ( err ) &#123; console.error('File Stats Error', err); return; &#125; console.log('Create : ', stats['birthtime']); console.log('size : ', stats['size']); console.log('isFile : ', stats.isFile()); console.log('isDirectory : ', stats.isDirectory()); console.log('isBlockDevice : ', stats.isBlockDevice()); if ( stats.isFile() ) &#123; fs.readFile(file, function(err, data) &#123; if ( err ) &#123; console.error('File Read Error', err); return; &#125; // encoding을 작성하지 않으면 Buffer로 var str = data.toString('utf-8'); console.log('File Contents : ', str); &#125;); &#125; &#125;); &#125; &#125;); 스트림 : 데이터 전송 흐름 콘솔 입력/출력 파일 읽기/쓰기 서버/클라이언트 -데이터 전송 스트림종류 읽기 스트림 : Readable Stream 모드 : flowing, paused flowing mode 데이터를 자동으로 읽는 모드 전달되는 데이터를 다루지 않으면 데이터 유실 paused mode 데이터가 도착하면 대기 read() 함수로 데이터 읽기 상태 readable : 읽기 가능한 상태 data : 읽을 수 있는 데이터 도착 end : 더 이상 읽을 데이터가 없는 상태 close : 스트림이 닫힌 상태 error : 에러 123456789101112131415161718192021222324252627var is = fs.createReadStream(file);is.on('readable', function() &#123; console.log('== READABLE EVENT');&#125;);is.on('data', function(chunk) &#123; console.log('== DATA EVENT'); console.log(chunk.toString());&#125;);// end 이벤트is.on('end', function() &#123; console.log('== END EVENT');&#125;);var is = fs.createReadStream(file);// 'data' 이벤트가 없으면 paused modeis.on('readable', function() &#123; console.log('== READABLE EVENT'); // 10바이트씩 읽기 while( chunk = is.read(10) ) &#123; console.log('chunk : ', chunk.toString()); &#125;&#125;) 쓰기 스트림 : Writeable Stream 데이터 출력 http 클라이언트의 요청 http서버의 응답 쓰기 스트림 tcp 소켓 이벤트 drain : 출력 스트림에 남은 데이터를 모두 보낸 이벤트 error : 에러 finish : 모든 데이터를 쓴 이벤트 pipe : 읽기 스트림과 연결(pipe)된 이벤트 unpipe : 연결(pipe) 해제 이벤트 123456789var fs = require('fs');var os = fs.createWriteStream('output.txt');os.on('finish', function() &#123; console.log('== FINISH EVENT');&#125;);os.write('1234\\n');os.write('5678\\n');os.end(); 읽기/쓰기 변환 URL var url = require(‘url&#39;); url.parse(urlStr[, parseQueryString][, slashesDenoteHost]) urlStr : URL 문자열 parseQueryString : 쿼리 문자열 파싱, 기본값 false 1234567var url = require('url');var urlStr = 'http://api.flickr.com/services/feeds/photos_public.gne?tags=raccoon&amp;tagmode=any&amp;format=json&amp;jsoncallback=?';var parsed = url.parse(urlStr, true);console.log(parsed);console.log('protocol : ', parsed.protocol);console.log('host : ', parsed.host);console.log('query : ', parsed.query); 모듈 만들기 모듈 만들기 소스 코들 분리 모듈 단위로 모듈 작성 방법 module.exports 모듈 사용하기 모듈 로딩 : requirerequire(&#39;mymodule.js&#39;); 모듈 로딩 에러require(&#39;mymodule.js&#39;); 이 경우 에러가 난다.(./mymodule.js) 사용자가 생성 한 모듈처리 해야함 모듈 만들기 123456789// mymodule.jsmodule.exports.goodMorning = function() &#123; // 모듈 함수 기능 작성&#125;exports.goodNight = function(arg, callback) &#123; // module 생략 가능&#125; 사용하기 12var greeting = require('mymodule.js');greeting.goodMorning(); exports 하지 않은 함수는 사용 불가^^ 예제) 123456789101112&gt; // student.js&gt; &gt; var student = &#123;&gt; hour : 0,&gt; study : function() &#123;&gt; this.hour++;&gt; console.log(this.hour + '시간째 공부 중');&gt; &#125;&gt; &#125;;&gt; &gt; module.exports = student;&gt; 사용할 때는 123&gt; var you = require('student.js');&gt; you.study();&gt; http서버 구동1234var http = require('http'); var server = http.createServer(function(req, res) &#123; res.end(‘Hello World’); &#125;).listen(3000); http 요청( request)var server = http.createServer(function(req, res){}) req.url : 요청 url, 경로와 쿼리 문자열 req.method : 요청 메소드 req.headers : 요청 메시지의 헤더 req(streamable) : 요청 메시지 바디 요청 쿼리 문자열 분석12 헤더 메시지 분석123456789101112var headers = req.headers;headers.hostheaders.content-typeheaders.user-agentvar server = http.createServer(function(req, res) &#123; console.log(‘HTTP Method : ' + req.method); console.log(‘HTTP URL : ' + req.url); console.log('== HEADERS =='); console.log(req.headers); res.end('Hello Node.js');&#125;); 응답 응답 메시지 상태 코드와 상태 메시지 응답 메시지 헤더 응답 메시지 바디 메시지 상태 response.statusCode response.statusMessage 메시지 헤더 response.writeHead(statusCode, statusMessage, headers)(statusMessage, headers 생략 가능) response.removeHeader(name) response.getHeader(name) response.setHeader(name, value) 메시지 바디 response.end() data, encoding, callback을 파라미터로 가질 수 있으며 생략도 가능 response.write() chunk, encoding, callback을 파라미터로 가질 수 있으며 생략도 가능 123456// 200 OKresponse.statusCode = 200;response.statusMessage = ‘OK’;// 404 Errorresponse.statusCode = 404;response.statusMessage = 'Not found'; 응답 메시지res.writeHead(200, { &#39;Content-Length&#39;: body.length, &#39;Content-Type&#39;: &#39;text/plain&#39; }); 헤더 작성 12res.setHeader(\"Content-Type\", \"text/html\");res.setHeader(\"Content-Length“, body.length); 예제 파일들 123456789var http = require('http');var server = http.createServer(function(req, res) &#123; console.log('Method : ', req.method); console.log('url : ', req.url); console.log('headers : ', req.headers['user-agent']); res.write('Hello World'); res.end();&#125;).listen(3000); 123456789var http = require('http');var server = http.createServer(function(req, res) &#123; res.statusCode = 200; res.statusMessage = 'OKOK'; res.setHeader('content-type','text/plain'); //설정에 따라 Client 화면 다르게 보인다 res.write('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'); res.end();&#125;).listen(3000); 123456789101112131415var http = require('http');var fs = require('fs');var server = http.createServer(function(req, res) &#123; fs.access('cat.jpg', function(err) &#123;\\ //이름 없는 이름 cat1.jpg 테이스 한후에 if ( err ) &#123; res.statusCode = 404; res.end(); return; &#125; fs.readFile('cat.jpg', function(err, data) &#123; res.end(data); &#125;); &#125;);&#125;).listen(3333); 12345678910111213141516171819202122232425262728293031323334var http = require('http');var url = require('url');var server = http.createServer(function(req, res) &#123; // URL 분석 : 쿼리 문자열 var parsed = url.parse(req.url, true); // 이 때 parsed 안에는 프로토콜, 호스트 등의 정보가 담긴 json 객체 var query = parsed.query; // 맵 구조로 돌아온다. // http://127.0.0.1:3000/cal?start=1&amp;end=10 // 이런 url을 치면 실행됨 // 이 때 query 안에는 start 키와 값, end 키와 값이 담긴 json 객체 // start와 end를 사용해 파라미터 값을 받을 수 있다 var start = parseInt(query.start); // 파라미터 이름이 start인 값 var end = parseInt(query.end); // 파라미터 이름이 end인 값 if ( !start || !end ) &#123; // 파라미터가 없으면 res.statusCode = 404; res.end('Wrong Parameter'); &#125; else &#123; // 합계 구하기 var result = 0; for(var i = start ; i &lt; end ; i++) &#123; result += i; &#125; res.statusCode = 200; res.end('Result : ' + result); &#125;&#125;).listen(3000); 정적 파일 서비스123456789101112131415var server = http.createServer(function(req, res) &#123; if ( req.url == '/favicon.ico' ) &#123;&#125; else if ( req.url == '/image.png' ) &#123; res.writeHeader(200, &#123;‘Content-Type':'image/png'&#125;); fs.read… &#125; else if ( req.url == '/music.mp3' ) &#123; res.writeHead(200, &#123;'Content-Type':'audio/mp3'&#125;); fs.createReadStream… &#125; else if ( req.url == '/movie.mp4' ) &#123; res.writeHead(200, &#123;'Content-Type':'video/mp4'&#125;); fs.createReadStream… &#125;&#125;); 요청 URL의 경로를 실제 파일 경로 매핑 myServier.com/resource/image.png -&gt; ./resources/image.png myServier.com/resource/audio.mp3 -&gt; ./resources/audio.mp3 요청 URL에서 경로 생성 123var pathUtil = require('path');var path = __dirname + pathUtil.sep + 'resources' + req.url;// + 로 해야한다! GET , POST 다루기 중복 POST 요청 방지 POST 요청 처리 후 redirect 응답 PRG(Post-Redirect-Get) 패턴 리프레쉬 – Get 요청 중복(OK) 응답 메시지 작성 코드 Redirection : 클라이언트 주소 옮기기 상태코드 : 302 헤더 필드 : Location PRG 패턴 적용 코드 123456req.on('end', function() &#123;// POST 요청 메세지 바디 분석/처리 res.statusCode = 302; res.setHeader(‘Location’, URL); res.end();&#125;); 폼 인코딩 방식(enctype) application/x-www-form-urlencoded (default) multipart/form-data (파일 전송) text/plain 멀티파트 방식 123&lt;form method=\"post\" action=\"upload\" enctype=\"multipart/form-data\"&gt;&lt;/form&gt; post 요청 요청 데이터 얻기 123456789var body = '';request.on('data', function(chunk) &#123; console.log('got %d bytes of data', chunk.length); body += chunk;&#125;);request.on('end', function() &#123; console.log('there will be no more data.'); console.log('end : ' + body);&#125;); 데이터 처리 12345request.on('end', function() &#123; var parsed = querystring.parse(body); console.log(‘name1 : ' + parsed.name1); console.log(‘name2 : ' + parsed.name2); &#125;); 실습 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869var http = require('http');var querystring = require('querystring');// 파라미터를 뽑아낼 수 있는 모듈var movieList = [&#123;title : '비트', director : '뉴딜'&#125;];var server = http.createServer(function(req, res) &#123; if(req.method.toLowerCase() == 'post') &#123; // post 방식으로 전송되었다면 addNewMovie(req, res); &#125; else &#123; // get 방식으로 전송되었다면 showList(req, res); &#125;&#125;);server.listen(3000);// 3000번 포트 사용function showList(req, res) &#123; res.writeHeader(200, &#123; 'Content-Type': 'text/html; charset=UTF-8' &#125;); // 포트 번호, 클라이언트에게 응답할 뷰단 설정 res.write('&lt;html&gt;'); res.write('&lt;meta charset=\"UTF-8\"&gt;'); res.write('&lt;body&gt;'); res.write('&lt;h3&gt;Favorite Movie&lt;/h3&gt;'); res.write('&lt;div&gt;&lt;ul&gt;'); movieList.forEach(function (item) &#123; // each문과 비슷한 역할 res.write('&lt;li&gt;' + item.title + '(' + item.director + ')&lt;/li&gt;'); &#125;, this); res.write('&lt;/ul&gt;&lt;/div&gt;'); res.write( '&lt;form method=\"post\" action=\".\"&gt;&lt;h4&gt;새 영화 입력&lt;/h4&gt;' + '&lt;div&gt;&lt;input type=\"text\" name=\"title\" placeholder=\"영화제목\"&gt;&lt;/div&gt;' + '&lt;div&gt;&lt;input type=\"text\" name=\"director\" placeholder=\"감독\"&gt;&lt;/div&gt;' + '&lt;input type=\"submit\" value=\"upload\"&gt;' + '&lt;/form&gt;' ); res.write('&lt;/body&gt;'); res.write('&lt;/html&gt;'); res.end();&#125;function addNewMovie(req, res) &#123; var body = ''; req.on('data', function(chunk) &#123; // 데이터 들어오면 발생하는 이벤트 부착 body += chunk; &#125;); // PRG 방식, 데이터 들어올 때마다 누적 req.on('end', function() &#123; // 데이터 다 들어오면 발생하는 이벤트 부착 var data = querystring.parse(body); // 데이터는 json 객체 var titledata = data.title; var directordata = data.director; // 배열에 넣기 // 자바스크립트의 배열은 스택구조임 // 때문에 스택의 메서드를 사용할 수 있음 movieList.push(&#123;title:titledata, director:directordata&#125;); // 이렇게 해도 된다 movieList.push(data); // json 객체 push res.end('success'); &#125;);&#125; 12345// 하단에 처리를 이렇게 해도 된다.res.statusCode = 302;res.setHeader('Location', '.');// 화면 재요청, get 방식으로 요청했을 때의 함수를 탄다res.end(); node를 이용한 파일 업로드formidable을 이용한 멀티파일 분석 모듈 이용1npm install formidable IncomingForm의 이벤트 field &gt; 이름/값 도착 이벤트 file &gt; 파일 도착 이벤트 aborted &gt; 요청 중지(클라이언트) end &gt; 종료 IncomingForm의 프로퍼티 form.uploadDir form.keepExtension 확장자 보존 form.multiples 다중 파일 업로드 123form.parse(req, function(err, fields, files) &#123;&#125; // fields : 이름 - 값(fields.이름) 데이터 // files : 업로드 파일 정보 업로드 파일 정보 : Formidable.File file.size 업로드 된 파일의 크기(바이트) file.path 파일 경로 file.name 파일 이름 file.type 파일 타입 file.lastModifiedDate 최종 변경일 file.hash 해쉬값 파일 업로드 서비스 구현 파일 업로드(formidable) - 임시 폴더 파일 업로드 후 -파일을 임시 폴더 -&gt; 리소스 저장소로 이동 -리소스 저장소에서 이름이 충돌되지 않도록 이름 변경 -날짜, 일련번호, 사용자 계정, …","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-18 수업 내용 정리","slug":"2018-12-18","date":"2018-12-18T08:43:18.000Z","updated":"2018-12-26T09:08:16.557Z","comments":true,"path":"2018/12/18/2018-12-18/","link":"","permalink":"http://eunajjing.github.io/2018/12/18/2018-12-18/","excerpt":"","text":"프로시저의 호출순수 원시 코드에서의 프로시저 호출12345678910111213141516CallableStatement cstmt = null;// oracle procedure 사용시 준비String sql=\"&#123;call usp_emplist(?,?)&#125;\";cstmt = conn.prepareCall(sql);cstmt.setInt(1, 1000);cstmt.registerOutParameter(2, OracleTypes.CURSOR);// 두번째 파라미터로 커서 타입을 명기해준다// 두번째 파라미터에 rs의 주소값을 넣을 것boolean result = cstmt.execute();rs = (ResultSet)cstmt.getObject(2);// 주소 정보 얻기while(rs.next())&#123; System.out.println(rs.getInt(1) + \"/\" + rs.getString(2) + \"/\" + rs.getInt(3));&#125; psmt는 쿼리문을 미리 컴파일해놓기 때문에 실행할 때 파라미터만 보낸다. 때문에 보안성이 높은 것","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-17 수업 내용 정리","slug":"2018-12-17","date":"2018-12-17T08:43:18.000Z","updated":"2018-12-26T09:08:16.556Z","comments":true,"path":"2018/12/17/2018-12-17/","link":"","permalink":"http://eunajjing.github.io/2018/12/17/2018-12-17/","excerpt":"","text":"자바의 직렬화 자바 기본(primitive) 타입과 java.io.Serializable 인터페이스를 상속받은 객체는 직렬화 할 수 있는 기본 조건을 가진다. 직렬화란?자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)을 아울러서 이야기 ObjectInputStream, ObjectOutputStream객체 스트림 : 객체 안에 저장되어 있는 내용을 직접 입출력할 수 있도록 해준다 hashMap.keySet()hashMap에 저장된 모든 키 반환 FileInputStream, FileOutputStream 바이트 단위의 입출력을 받는 클래스출발 지점과 도착 지점을 연결하는 통로 생성file로 입력 스트림 생성 File.exists()해당 이름의 파일이나 디렉토리가 있는지 여부를 검사 File.mkdir()폴더 생성 동기화 작업이 진행되는 동안 락이 걸리는 것 123public synchronized void openDoor(String name) &#123; &#125; vector는 동기화가 되어 있고, arrayList는 동기화가 되어있지 않다. arrayList가 vector보다 성능이 좋은 이유는, 동기화가 되어있지 않기 때문이다. 쓰레드 : 순서를 정의할 수 없음 프로세스 : 동작하고 있는 프로그램보통 한 개의 프로세스는 한 가지의 일을 한다. 쓰레드를 이용하면 한 프로세스 내에서 두 가지 또는 그 이상의 일을 동시에 할 수 있게 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//동기화//한강둔치 화장실(공유자원) : 여러명 10명 (각각의 Thread 10개)//한강둔치 비빕밥 축제//Multi Thread 환경에 [공유자원]//해결 방법 : lock//함수 단위 LocK (동기화 보장)class Wroom&#123; public synchronized void openDoor(String name) &#123; //public void openDoor(String name) &#123; System.out.println(name + \"님 화장실 입장 ^^\"); for(int i = 0; i &lt; 50 ;i++) &#123; System.out.println(name + \"사용 : \"+ i); if(i == 1000) &#123; System.out.println(name + \"님 끙 !!\"); &#125; &#125; System.out.println(name + \"시원하시죠 ....\"); &#125;&#125;class Users extends Thread&#123; private Wroom wr; private String who; public Users(String name , Wroom wr) &#123; this.who = name; this.wr = wr; &#125; @Override public void run() &#123; wr.openDoor(this.who); &#125;&#125;public class Ex09_sync_Thread &#123; public static void main(String[] args) &#123; //한강둔치 Wroom w = new Wroom(); //사람들 Users kim = new Users(\"김씨\", w); Users Lee = new Users(\"이씨\", w); Users Park = new Users(\"박씨\", w); kim.start(); Lee.start(); Park.start(); &#125;&#125; PL/SQL오토커밋이 되지 않는다. end구문에 반드시 세미콜론! 123BEGIN DBMS_OUTPUT.PUT_LINE(&apos;HELLO WORLD&apos;);END; 변수 선언123456789DECLARE --선언 vno number(4); vname varchar2(20);BEGIN vno := 100; -- 할당 &gt; String s; s = &quot;홍길동&quot; vname := &apos;kglim&apos;; DBMS_OUTPUT.PUT_LINE(vno); --화면 출력 DBMS_OUTPUT.PUT_LINE(vname || &apos;입니다&apos;);END; 12345678910111213141516DECLARE vno number(4); vname varchar2(20);BEGIN select empno ,ename into vno , vname -- pl-sql 사용하는 구분 (into) . 실행결과 변수에 담기 -- 오라클엔 존재하지 않는다. -- VNO에 EMPNO를 -- VNAME에 ENAME을 담는다 from emp where empno=&amp;empno; -- &amp; 자바 scanner 역할 (입력값 받기) DBMS_OUTPUT.PUT_LINE(&apos;변수값 : &apos; || vno || &apos;/&apos; || vname);END; 실행하면 INPUT 창이 뜬다. 제어문123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113--pl-sql 제어문DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vdeptno emp.deptno%TYPE; vname varchar2(20) := null;BEGIN select empno , ename , deptno into vempno , vename , vdeptno from emp where empno=7788; --제어문 if(조건문)&#123;실행문&#125; IF(vdeptno = 10) THEN vname := &apos;ACC&apos;; -- if(vdeptno==10) &#123; vname = &quot;ACC&quot;&#125; else if()&#123;&#125; ELSIF(vdeptno=20) THEN vname := &apos;IT&apos;; ELSIF(vdeptno=30) THEN vname := &apos;SALES&apos;; END IF; DBMS_OUTPUT.PUT_LINE(&apos;당신의 직종은 : &apos; || vname);END;--IF() THEN 실행문--ELSIF() THEN 실행문--ELSE 실행문--사번이 7788번인 사원의 사번 , 이름 , 급여를 변수에 담고--변수에 담긴 급여가 2000 이상이면 &apos;당신의 급여는 BIG&apos; 출력하고--그렇지 않으면(ELSE) &apos;당신의 급여는 SMALL&apos; 이라고 출력하세요DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vsal emp.sal%TYPE;BEGIN select empno , ename , sal into vempno , vename , vsal from emp where empno=7788; --제어문 if(조건문)&#123;실행문&#125; IF(vsal &gt; 2000) THEN DBMS_OUTPUT.PUT_LINE(&apos;당신의 급여는 BIG &apos; || vsal); ELSE DBMS_OUTPUT.PUT_LINE(&apos;당신의 급여는 SMALL &apos; || vsal); END IF; END; ------------------------------------------------------------------------------- --CASE DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vdeptno emp.deptno%TYPE; v_name varchar2(20);BEGIN select empno, ename , deptno into vempno, vename , vdeptno from emp where empno=7788; -- v_name := CASE vdeptno-- WHEN 10 THEN &apos;AA&apos;-- WHEN 20 THEN &apos;BB&apos;-- WHEN 30 THEN &apos;CC&apos;-- WHEN 40 THEN &apos;DD&apos;-- END; v_name := CASE WHEN vdeptno=10 THEN &apos;AA&apos; WHEN vdeptno in(20,30) THEN &apos;BB&apos; WHEN vdeptno=40 THEN &apos;CC&apos; ELSE &apos;NOT&apos; END; DBMS_OUTPUT.PUT_LINE(&apos;당신의 부서명:&apos; || v_name); END;----------------------------------------------------------------------------------pl-sql (반복문)--Basic loop/*LOOP 문자; EXIT WHEN (조건식)END LOOP*/DECLARE n number :=0;BEGIN LOOP DBMS_OUTPUT.PUT_LINE(&apos;n value : &apos; || n); n := n + 1; EXIT WHEN n &gt; 5; END LOOP;END;/*WHILE(n &lt; 6)LOOP 실행문;END LOOP*/DECLARE num number := 0;BEGIN WHILE(num &lt; 6) LOOP DBMS_OUTPUT.PUT_LINE(&apos;num 값 : &apos; || num); num := num +1; END LOOP;END;--for--java for(int i = 0 ; i &lt; 10 ; i++) &#123;&#125;BEGIN FOR i IN 0..10 LOOP DBMS_OUTPUT.PUT_LINE(i); END LOOP;END; 123456789101112--11g 이전 (continue (x))--11g (continue 추가)DECLARE total number := 0;BEGIN FOR i IN 1..100 LOOP DBMS_OUTPUT.PUT_LINE(&apos;변수 : &apos; || i); CONTINUE WHEN i &gt; 5; --skip total := total + i; -- 1 , 2 , 3 , 4, 5 END LOOP; DBMS_OUTPUT.PUT_LINE(&apos;합계 : &apos; || total);END; 예외처리12345678910111213141516 --예외처리 EXCEPTION WHEN NO_DATA_FOUND THEN DBMS_OUTPUT.PUT_LINE(v_name || &apos;는 자료가 없습니다&apos;); WHEN TOO_MANY_ROWS THEN DBMS_OUTPUT.PUT_LINE(v_name || &apos;는 동명 이인입니다&apos;); WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE(&apos;기타 에러가 발생했습니다&apos;);END;/*질의는 하나의 행만 RETURN 해야 합니다. PL/SQL 블록 내의 SELECT 문장은 다음 규칙을적용하는 Embedded SQL 의 ANSI 범주에 속합니다. 질의의 결과는 하나의 행만을 RETURN 해야 하고 하나의 행 이상 또는 행이 없는 것은 에러를 생성합니다. PL/SQL 은NO_DATA_FOUND 와 TOO_MANY_ROWS 를 예외로 블록의 예외 섹션에서 추적할 수 있는 표준 예외를 조성하여 처리 합니다.*/ 1234-- 변수 제어하기(타입)-- 1.1 타입 : v_empno number(10)-- 1.2 타입 : v_empno emp.empno%TYPE (emp 테이블에 있는 empno 컬럼의 타입 사용)-- 1.3 타입 : v_row emp%ROWTYPE (v_row 변수는 emp 테이블 모든 컬럼 타입 정보, 배열) 시퀀스12345678910create sequence empno_seqincrement by 1-- 시퀀스 증감 숫자start with 8000maxvalue 9999nocycle-- 디폴트 값으로 최대나 최솟값에 도달하면 생성 중지-- cycle이면 다시 최솟값이나 최대값에서 시작nocache;-- 디폴트로 메모리에 시퀀스 값을 미리 할당해 놓지 않으며 디폴트 값은 20 SQL%ROWCOUNT는 마지막에 업데이트 된 행을 뜻한다. 커서123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vsal emp.sal%TYPE; CURSOR c1 IS select empno,ename,sal from emp where deptno=30;BEGIN OPEN c1; --커서가 가지고 있는 문장 실행 LOOP --Memory /* 7499 ALLEN 1600 7521 WARD 1250 7654 MARTIN 1250 7698 BLAKE 2850 7844 TURNER 1500 7900 JAMES 950 */ FETCH c1 INTO vempno , vename, vsal; EXIT WHEN c1%NOTFOUND; --더이상 row 가 없으면 탈출 DBMS_OUTPUT.PUT_LINE(vempno || &apos;-&apos; || vename || &apos;-&apos;|| vsal); END LOOP; CLOSE c1;END;---------------------------------------------------------위 표현을 좀 더 간단하게--java (for(emp e : emplist)&#123;&#125;DECLARE CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR emp_record IN emp_curr --row 단위로 emp_record변수 할당 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(emp_record.empno || &apos;-&apos; || emp_record.ename); END LOOP; CLOSE emp_curr;END;--------------------------------------------------------------------------------DECLARE vemp emp%ROWTYPE; --Type 정의 CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR vemp IN emp_curr --row 단위로 emp_record변수 할당 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(vemp.empno || &apos;-&apos; || vemp.ename); END LOOP; CLOSE emp_curr;END; 1234567891011121314151617181920212223DECLARE vempno emp.empno%TYPE; vename emp.ename%TYPE; vsal emp.sal%TYPE; CURSOR c1 IS select empno,ename,sal from emp where deptno=30;BEGIN OPEN c1; --커서가 가지고 있는 문장 실행 LOOP --Memory /* 7499 ALLEN 1600 7521 WARD 1250 7654 MARTIN 1250 7698 BLAKE 2850 7844 TURNER 1500 7900 JAMES 950 */ FETCH c1 INTO vempno , vename, vsal; EXIT WHEN c1%NOTFOUND; --더이상 row 가 없으면 탈출 DBMS_OUTPUT.PUT_LINE(vempno || &apos;-&apos; || vename || &apos;-&apos;|| vsal); END LOOP; CLOSE c1;END; 12345678910111213DECLARE CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR emp_record IN emp_curr --row 단위로 emp_record변수 할당 -- open과 fetch 생략 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(emp_record.empno || &apos;-&apos; || emp_record.ename); END LOOP; CLOSE emp_curr;END; 1234567891011DECLARE vemp emp%ROWTYPE; --Type 정의 CURSOR emp_curr IS select empno ,ename from emp;BEGIN FOR vemp IN emp_curr --row 단위로 emp_record변수 할당 LOOP EXIT WHEN emp_curr%NOTFOUND; DBMS_OUTPUT.PUT_LINE(vemp.empno || &apos;-&apos; || vemp.ename); END LOOP; CLOSE emp_curr;END; 커서의 타입12345678910111213create or replace procedure usp_emplist( p_sal IN number, p_cursor OUT SYS_REFCURSOR -- app 에서 값을 사용하기 위해서(Multi row))is BEGIN OPEN p_cursor FOR select empno ,ename , sal from emp where sal &gt; p_sal; END; 프로시저에서 한 건 이상의 결과 값은 무조건 커서를 써야 한다. 커서를 아웃풋으로 잡고, 커서의 자료형을 SYS_REFCURSOR로 한다. 트랜젝션 및 예외 처리12345678910111213141516171819202122DECLARE v_ename emp.ename%TYPE := &apos;&amp;p_ename&apos;; v_err_code NUMBER; v_err_msg VARCHAR2(255); BEGIN DELETE emp WHERE ename = v_ename; IF SQL%NOTFOUND THEN -- 만약 해당 데이터가 없으면 RAISE_APPLICATION_ERROR(-20001,&apos;my no data found&apos;); -- 에러 번호, 메시지 --사용자 정의 예외 만들기 END IF; EXCEPTION WHEN OTHERS THEN ROLLBACK; v_err_code := SQLCODE; -- SQLCODE : -20001 v_err_msg := SQLERRM; -- SQLERRM : my no data found DBMS_OUTPUT.PUT_LINE(&apos;에러 번호 : &apos; || TO_CHAR(v_err_code)); DBMS_OUTPUT.PUT_LINE(&apos;에러 내용 : &apos; || v_err_msg); END; 프로시저 생성 123456789create or replace procedure usp_emplistis BEGIN update emp set job = 'TTT' where deptno=30; commit -- 만약 commit을 하지 않으면 rollback 된다! END; 함수는 select 구문, 프로시저는 단독 사용 가능 실행 1execute usp_emplist; 서버와 db가 따로 구축되었을 때 update문을 실행하면 update 쿼리를 빼갈 수 있다. 반면 프로시저를 사용하면 콜하는 프로시저만 빼갈 수밖에 없다. 프로시저가 db 안에 있기 때문 프로시저의 장점은 네트워크 트래픽 감소, 보안 강화 파라미터 사용12345678910111213--parameter 사용가능--종류 : INPUT , OUTPUTcreate or replace procedure usp_update_emp(vempno emp.empno%TYPE)is BEGIN update emp set sal = 0 where empno = vempno; END;--실행방법exec usp_update_emp(7788);-- 단축 표현법 123456789101112131415create or replace procedure usp_getemplist(vempno emp.empno%TYPE)is --내부에서 사용하는 변수 vname emp.ename%TYPE; vsal emp.sal%TYPE; BEGIN select ename, sal into vname , vsal from emp where empno=vempno; DBMS_OUTPUT.put_line(&apos;이름은 : &apos; || vname); DBMS_OUTPUT.put_line(&apos;급여는 : &apos; || vsal); END; input과 output input paramter : 사용시 반드시 입력 (default) output parmater 사용시 입력값을 받지 않는다. 결과를 담고 있어 받을 변수가 필요함 123456789101112131415create or replace procedure app_get_emplist( vempno IN emp.empno%TYPE, -- 강제 vename OUT emp.ename%TYPE, vsal OUT emp.sal%TYPE -- 입력값 받지 않음)is BEGIN select ename, sal into vename , vsal from emp where empno=vempno; END; 실행 123456789DECLARE out_ename emp.ename%TYPE; out_sal emp.sal%TYPE;BEGIN app_get_emplist(7902,out_ename,out_sal); -- 보내는 변수는 프로시저의 out 파라미터 -- 리턴 값을 받아낼 것들 자료형 맞춰서 변수 보냄 DBMS_OUTPUT.put_line(&apos;출력값 : &apos; || out_ename || &apos;-&apos; || out_sal);END; 사용자 함수 프로시저와 다른 점 : return 타입 12345678910111213create or replace function f_max_sal(s_deptno emp.deptno%TYPE)return number-- public int f_max_sal(int deptno) &#123; int max_sal = 0; return 10&#125;is max_sal emp.sal%TYPE;BEGIN select max(sal) into max_sal from emp where deptno = s_deptno; return max_sal;END; 리턴에 대한 타입 정말 리턴되는 것 즉 리턴이 두 개 명기된다. 사용법 12select * from emp where sal = f_max_sal(10);select max(sal) , f_max_sal(30) from emp;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-14 수업 내용 정리","slug":"2018-12-14","date":"2018-12-14T08:43:18.000Z","updated":"2018-12-26T09:08:16.556Z","comments":true,"path":"2018/12/14/2018-12-14/","link":"","permalink":"http://eunajjing.github.io/2018/12/14/2018-12-14/","excerpt":"","text":"JavaScript 람다식 12345var function1=function(text)&#123; return text.repeat(12);&#125; var function2=(text=&gt;text.repeat(12)); 1var 함수명 = (매개변수) =&gt; &#123;실행할내용&#125;; 자바스크립트 과제문제 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;할일 목록 앱&lt;/title&gt; &lt;style&gt; #add-btn&#123; padding: 5px 10px; border: 0; background: #f80; color: white; border-radius: 5px; &#125; ul&#123; padding: 0; list-style-position: inside; &#125; li&#123; border-bottom: 1px solid #999; padding: 5px 0; &#125; .active&#123; background: gold; &#125; /* 목록 클릭 스타일 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id='title'&gt;할일 목록&lt;/h1&gt; &lt;button id=\"add-btn\"&gt;목록 추가&lt;/button&gt; &lt;ul id='list'&gt; &lt;li&gt;밥먹기 1&lt;/li&gt; &lt;li&gt;잠자기 2&lt;/li&gt; &lt;li&gt;밥먹기 3&lt;/li&gt; &lt;li&gt;잠자기 4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //자바 스크립트를 사용하세요 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 모범답안 123456789101112131415161718192021222324252627282930313233&lt;script&gt; // 변수 초기화 var title = document.getElementById('title'); var list = document.getElementById('list'); var li = list.getElementsByTagName('li'); var addBtn = document.getElementById('add-btn'); // 목록 추가 버튼 // 이벤트리스너 list.addEventListener('click', activeItem); function activeItem(event)&#123; // 클릭한 노드가 li이면 if(event.target.nodeName == 'LI')&#123; // event.target은 클릭한 객체를 의미 title.innerHTML = event.target.innerText; // 목록 스타일 초기화 for(var i = 0; i &lt; event.target.parentNode.children.length; i++)&#123; event.target.parentNode.children[i].removeAttribute('class'); &#125; // 클릭한 목록 스타일 지정 event.target.setAttribute('class', 'active'); // 클릭한 대상 &#125; // end if &#125; // end function // 목록 추가 addBtn.addEventListener('click', function()&#123; var txt = prompt('제목 입력'); list.innerHTML += '&lt;li&gt;' + txt + '&lt;/li&gt;'; &#125;); &lt;/script&gt; 최초에 내가 만든 답 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;할일 목록 앱&lt;/title&gt;&lt;style&gt;#add-btn &#123; padding: 5px 10px; border: 0; background: #f80; color: white; border-radius: 5px;&#125;ul &#123; padding: 0; list-style-position: inside;&#125;li &#123; border-bottom: 1px solid #999; padding: 5px 0;&#125;.active &#123; background: gold;&#125; /* 목록 클릭 스타일 */.addColor &#123; background: #f80; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 id='title'&gt;할일 목록&lt;/h1&gt; &lt;button id=\"add-btn\"&gt;목록 추가&lt;/button&gt; &lt;ul id='list'&gt; &lt;li&gt;밥먹기 1&lt;/li&gt; &lt;li&gt;잠자기 2&lt;/li&gt; &lt;li&gt;밥먹기 3&lt;/li&gt; &lt;li&gt;잠자기 4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var title = document.getElementById(\"title\"); var lis = document.getElementsByTagName(\"li\"); function showAlert() &#123; var todo = prompt(\"추가할 할 일\"); if (todo != null || todo != \"\") &#123; todoNode = document.createElement('li'); texttodo = document.createTextNode(todo); todoNode.appendChild(texttodo); document.getElementById(\"list\").appendChild(todoNode); &#125; &#125; function removeColor() &#123; for (var i = 0; i &lt; lis.length ; i++) &#123; lis[i].classList.remove('addColor'); &#125; &#125; function change(e) &#123; title.innerHTML = e.target.innerText; removeColor(); e.target.classList.add('addColor'); &#125; var addbtn = document.getElementById(\"add-btn\"); addbtn.addEventListener(\"click\", showAlert); for (var i = 0; i &lt; lis.length ; i++) &#123; lis[i].addEventListener(\"click\", change); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 나는 스타일 관련한 클래스를 하나 생성하고, 제이쿼리에서 제어하듯 클래스를 추가시켜서 구현했다. 그런데 이 오스는… 스크립트 단에서 새로 insert 시킨 li의 경우 이벤트 효과가 들어가지 않아 다시 짜야 한다. 코드를 짜면서 새롭게 배운 자바스크립트 문법은 classList 링크 prompt 그리하여 다시 짠 소스. click 이벤트를 ul에 주었다. (달라진 소스만) 123456789101112131415161718192021222324252627282930313233&lt;script&gt;var title = document.getElementById(\"title\");var list = document.getElementById(\"list\");function showAlert() &#123; var todo = prompt(\"추가할 할 일\"); if (todo != null || todo != \"\") &#123; todoNode = document.createElement('li'); texttodo = document.createTextNode(todo); todoNode.appendChild(texttodo); document.getElementById(\"list\").appendChild(todoNode); &#125;&#125;function removeColor() &#123; var lis = document.getElementsByTagName(\"li\"); for (var i = 0; i &lt; lis.length ; i++) &#123; lis[i].classList.remove('addColor'); &#125; &#125;function change(e) &#123; title.innerHTML = e.target.innerText; removeColor(); e.target.classList.add('addColor');&#125;var addbtn = document.getElementById(\"add-btn\");addbtn.addEventListener(\"click\", showAlert);list.addEventListener(\"click\", change);&lt;/script&gt; 제이쿼리 함수 안에 셀렉터를 넣으면 객체화된다. 1$(tr).addClass(\"~\"); find()는 배열을 가질 수 있다 data() HTML 엘리먼트 내에 데이터를 저장하고 읽는 역할을 하는 함수 참고에 활용한 링크 사용법 데이터 저장 123$(\"span\").data(\"name\", \"Nextree\");// key와 value 형태로 저장된다$(\"span\").data(\"address\", \"가산\"); 데이터 가져오기 12Evar name = $(&amp;quot;span&amp;quot;).data(&amp;quot;name&amp;quot;);var address = $(&amp;quot;span&amp;quot;).data(&amp;quot;address&amp;quot;); 데이터 삭제 1$(selector).removeData(key); 전송방식1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556$('#delBtn').click(function() &#123; if(confirm('정말로 탈퇴하시겠습니까?')) &#123; $.ajax(&#123; url:'$&#123;root&#125;/member/users/$&#123;user.userid&#125;', type:'DELETE', contentType:'application/json;charset=utf-8', dataType:'json', success:function(response) &#123; console.log(response.result); $(location).attr('href', '$&#123;root&#125;/member/logout.cafe'); &#125;, error:function(xhr,status,msg)&#123; console.log(\"상태값 : \" + status + \" Http에러메시지 : \"+msg); &#125; &#125;); &#125; &#125;);//회원탈퇴 @RequestMapping(value=\"/users/&#123;userid&#125;\", method=RequestMethod.DELETE) @ResponseBody public Map&lt;String, String&gt; deleteMember(@PathVariable String userid) &#123; memberService.deleteMember(userid); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"result\", \"ok\"); return map; &#125; $.ajax(&#123; url: \"$&#123;root&#125;/member/users\", type: 'PUT', dataType: 'json', data: data, contentType: 'application/json;charset=UTF-8', mimeType: 'application/json', success: function(response) &#123; $('#registerModal').modal('hide'); $(location).attr('href', '$&#123;root&#125;/member/view.cafe'); &#125;, error:function(xhr, status, message) &#123; alert(\"status : \" + status + \" error : \" + message); &#125; &#125;); //회원정보수정@RequestMapping(value=\"/users\", method=RequestMethod.PUT, headers = &#123; \"Content-type=application/json\" &#125;)@ResponseBodypublic Map&lt;String, String&gt; modifyMember(@RequestBody MemberDetailDto memberDetailDto) &#123; memberService.modifyMember(memberDetailDto); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"result\", \"ok\"); return map; &#125; delete url로 데이터를 전송하고, 받는 컨트롤러 단에서 메서드 타입에 delete를 명시해준다. put create에 사용되는 방식 원하는 정보를 요청하는 게 아니라 직접 바꿀 수 있다 나한테 왜이래 그 외 @PathVariable : 외부로 value가 노출되지 않음delete 때 썼던 것 같다. @restController : 데이터 자체를 반환해주는 것(문자열, json, xml 반환) serialize() : 다 가지고 올 때 사용 1234var param = $(this).serialize();// 폼에 있는 데이터 다 가지고 오기// 이 경우 name이 key로 가버림// 나중에 이 param 객체를 data에 넣어서 ajax로 쏜다! sql nvl 함수 123SELECT ENAME, NVL(TO_CHAR(COMM),'no commission')--바꾸고자 하는 자료형이 맞아야 한다.FROM EMP 그룹함수 외에 select 절 칼럼은 모두 group by 절에 넣어야 한다. uml 의존과 연관이 잘 이해되지 않는다면 의존 : 지역 변수 연관 : 전역 변수","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-11 수업 내용 정리","slug":"2018-12-11","date":"2018-12-11T08:43:18.000Z","updated":"2018-12-26T09:08:16.555Z","comments":true,"path":"2018/12/11/2018-12-11/","link":"","permalink":"http://eunajjing.github.io/2018/12/11/2018-12-11/","excerpt":"","text":"static 블록 설명 추가 생성자와 같은 역할을 하며 static 자원만 초기화할 때 사용 메모리 기반으로 게시판 만들기링크 지인이 입사 지원 문제로 출제된 걸 봤다고 해서, 시간이 나면(..)-시간 영원히 나지 않을 것 같지만- 소스를 분석해볼 참이다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-07 수업 내용 정리","slug":"2018-12-07","date":"2018-12-07T00:07:18.000Z","updated":"2018-12-07T09:11:04.219Z","comments":true,"path":"2018/12/07/2018-12-07/","link":"","permalink":"http://eunajjing.github.io/2018/12/07/2018-12-07/","excerpt":"","text":"UML 클래스와 클래스 사이의 관계 상속상속 받은 B는 상속한 A를 확장한다. 의존 관계특정 메서드에서만 일시적으로 사용되는 관계 연관 관계, 직접 연관나는 친구와 연관되어 있다. 집합 연관컴퓨터는 마우스를 포함한다. 합성 연관컴퓨터는 메인보드를 포함한다. (집합 연관보다 더 강하게 종속) 컴퓨터가 버려지면 메인보드도 같이 버려진다. Mybatis의 ResultMap 다루기 - 포함 관계에 있는 객체를 vo에서 함께 이용하는 방법12345// vo에 포함 관계에 있는 객체 자료형의 필드를 만든다private 객체 필드명// 마찬가지로 getter, setter 메서드를 만들어준다 123456789&lt;!--xml resultMap을 만들 때, 만약에 있다면 실행하라는 뜻--&gt;&lt;association property=\"vo에 만들어둔 프로퍼티명\" javaType=\"클래스 경로\"&gt; &lt;id column=\"쿼리문의 칼럼명\" property=\"vo에 만들어둔 프로퍼티 vo의 프로퍼티명\"/&gt; &lt;!-- 항상 pk를 포함해야 한다, 만약 pk를 쓰지 않는다고 하더라도! pk는 resultMap에서 쓰듯 id로 써야 한다. 또한 pk 지정은 association 안 뿐만 아니라 resultMap 안에서 지정할 때도 써야 한다 --&gt; &lt;result colum=\"쿼리문의 칼럼명\" property=\"vo에 만들어둔 프로퍼티 vo의 프로퍼티명\"/&gt;&lt;/association&gt; 12&lt;!-- jsp --&gt;$&#123;board.vo자료형의 프로퍼티명.칼럼명&#125; mybatis에 구현체 자동 생성하기AppConfig.java (xml에서 설정할 것들을 대체해 설정했던 class) @MapperScan 어노테이션을 설정해두기 1234567891011121314@PropertySource(\"classpath:/com/....properties\")// mybatis의 dao 인터페이스 구현체를 자동 생성하는 도우미를 추가@MapperScan(\"dao 인터페이스가 들어있는 패키지 경로\")// 자동 생성된 dao 구현체는 sql를 찾을 때 인터페이스의 전체 이름으로 찾는다// 즉 dao 인터페이스가 들어있는 패키지 경로/dao명// 따라서 sql 매퍼 파일의 네임스페이스 이름은 인터페이스의 전체 이름과 같아야 한다.// 인터페이스의 메서드 파라미터, 리턴 타입은 sql 매퍼의 파라미터 타입과 리턴 타입이 같아야 한다.// 인터페이스의 메서드 이름과 매퍼 id는 같아야 한다.public class AppConfig &#123; ..&#125; dispatcherServlet 프론트 컨트롤러 요청을 받으면 jsp 인크루드, 포워딩을 맡거나 페이지 컨트롤러로 요청을 보낸다. 응답이 돌아오면 응답을 전달함 페이지 컨트롤러 : 특정 페이지에 대해서만 제어하는 것 디스패처와 jsp는 톰캣이 관리한다 그러나 페이지 컨트롤러와 dao는 ioc Container 관리 dispatcherServlet 직접 만들기dispatcherServlet webServlet(&quot;/app/*&quot;) 어노테이션 살려두고 클라이언트가 요청한 명령 추출 request.getServletPath() 메서드를 호출하면 /app이 오고, request.getPathInfo()메서드를 호출하면 /app다음의/**이 오므로 getPathInfo()를 이용한다. ioc Container를 얻어 iocContainer.getBean(request.getPathInfo()) 실행 즉 ico Container에서 요청을 처리할 객체를 getPathInfo()를 이용해 찾으면 해당 페이지를 담당하는 컨트롤러 객체가 넘어온다. 이 때 호출의 일관성을 위해 페이지 컨트롤러들의 인터페이스를 정의하고, 개별적인 페이지 컨트롤러가 이를 상속 받도록 조치한다. iocContainer.getBean(request.getPathInfo())에서 돌아오는 리턴 값도 페이지 컨트롤러들의 인터페이스로 한다. 인터페이스에 공통으로 정의할 메서드, 예제에서는 execute()메서드였는데 이 메서드는 파라미터로 httpServletRequest와 httpServletResponse를 가지게끔 한다. String execute(httpServeltRequest request, HttpServletResponse response) ​ page Controller @Component(&quot;경로&quot;) 어노테이션을 기입해준다. 생성자에서 사용할 객체를 주입 받는 식으로 전역 변수를 선언한다. 보통 이 전역 변수는 dao가 많다. (생성자에서 파라미터로 받는 객체는 마찬가지로 스프링 ioc container에 있으므로 따로 지정하지 않아도 자동으로 들어간다) dao의 메서드를 호출해 db 도달 처리를 하고, db에서 받은 것들을 set한 후, utf-8로 맞추는 등의 설정을 한다. 도달해야하는 jsp 경로를 리턴한다. 만약 리턴하지 않으면 요청했던 url로 넘어간다. return &quot;redirect:경로&quot;or return &quot;경로&quot; 다시 dispatcherServlet 페이지 컨트롤러의 메서드, 예제의 execute()메서드를 호출한다. 리턴받은 url을 include하던가 forward한다. 페이지 컨트롤러가 redirect로 보냈을 가능성을 대비해 dispatcher 단에서는 startWith()를 이용해서 어떤 url인지 확인하고, redirect로 왔다면 replace() 메서드를 이용해 redirect 제거 후 response.sendRedirect(&quot;경로&quot;)로 보낸다. 만약 redirect가 아니라면 include하던가 forward한다. Spring WebMVC 프레임워크 도입 spring-webmvc 의존 설정 springframework 의존 설정을 지워도 된다. 어차피 spring-webmvc의 의존 라이브러리이기 때문에 spring-webmvc를 가져올 때 같이 가져오기 때문 웹 어플리케이션이 시작될 때 SpringContextContainerInitializer를 부르고, 이것이 WebApplicationInitializer 구현체를 부른다. WebApplicationInitializer 구현체는 웹 어플리케이션이 시작될 때 호출되어 시작된다. 1234567891011121314151617181920212223242526public void onStartup(ServletContext servletContext) throws ServletException &#123; // 만약 web.xml에서 java 파일로 설정한 것들이 기재되어 있다면 java 파일은 실행되지 않는다. // 만약 스프링 설정 파일을 java 파일로도 한다면, // @Configuration이란 어노테이션을 붙여줘야 IOC Container가 인지한다. // 또한 어노테이션을 읽기 위해서는 xml에서 태그를 붙여줘야 한다. // 프론트 컨트롤러가 사용할 Spring IOC Container 준비 AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext(); ac.register(AppConfig.class); ac.refresh(); // 프론트 컨트롤러를 서블릿 컨테이너에 등록한다. // 프론트 컨트롤러를 생성할 때 이 객체가 사용할 Spring IOC Container를 알려준다 DispatcherServlet servlet = new DispatcherServlet(); // 서블릿 컨테이너에 위에서 만든 프론트 컨트롤러 서블릿을 등록한다. ServletRegistration.Dynamic registration = servlet.addServlet(\"app\", servlet); // 등록한 서블릿에 정보를 설정한다. // 웹 어플리케이션이 시작될 때 프론트 컨트롤러를 생성하라고 지정한다 // 프론트 컨트롤러의 url을 지정한다 registration.setLoadOnStartup(1); registration.addMapping(\"/app/*\");&#125; 상속해 반드시 구현해야하는 이 메서드가 실행된다. 기존의 dispatcherServlet을 제거하고 Spring IOC Container에서 제공하는 dispatcherServlet을 사용할 것 기존의 contextloaderlistener들도 제거 어차피 Spring IOC Container에서 다루기 때문 페이지 컨트롤러들의 인터페이스를 삭제한다. 디스패처가 페이지 컨트롤러를 실행할 때는 다른 규칙에 따라 실행하기 때문. 기존에 사용자가 만든 규칙은 필요치 않다. 페이지 컨트롤러의 어노테이션 @Component(&quot;경로&quot;)를 @Controller로 바꾼다. 페이지 컨트롤러의 메서드에 @RequestMapping(&quot;경로&quot;) 어노테이션을 붙여준다. 컴포턴트 옆의 경로를 붙여준다. 메서드 이름 또한 사용자가 정의 가능 CharacterEncodingFilter 사용 WEB-INF/web.xml 123456789101112131415161718192021222324252627282930313233&lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring/app-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.springframework.web.filter.CharacterEncodingFilter &lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;filter&gt; &lt;!-- 기재하게되면 더이상 java 단에서 encoding을 지정하지 않아도 된다 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; app-servlet.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"com.eomcs.lms\"/&gt; &lt;!-- Spring WebMVC 관련 애노테이션을 처리해주는 도우미 객체를 추가한다. --&gt; &lt;mvc:annotation-driven enable-matrix-variables=\"true\"/&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 원래 어노테이션을 이용한 필터도 사용 가능한데, 구현해야하는 메서드가 많아서 .xml로 처리 dispatcherServlet만 초기화하는 추상 클래스 AbstractDispatcherServletInitializer를 상속 받아 추상 메서드 `getServletFilter()를 재정의 12345@Overrideprotected Filter[] getServletFilters() &#123; return new Filter[] &#123;new CharacherEncodingFilter(\"utf-8\");&#125;&#125;// 왜인지 에러나고 잘 안되어서 수업 중 실행 여부 확인 못함 JSP 파일 감추기 클라이언트로부터 jsp 파일을 감춘다 외부에서 jsp를 직접 접근하지 못하게 WEB-INF/jsp폴더로 옮긴다. appConfig.java에서 Spring WebMVC에 기본으로 설정되어 있는 ViewResolver를 InternalResourceViewResolver로 교체 1234567891011121314@Beanpublic ViewResolver viewResolver() &#123; // viewResolver 인터페이스의 구현체 객체 생성 메서드 InternalResourceViewResolver vs = new InternalResourceViewResolver(); vs.setPrefix(\"/WEB-INF/jsp/\"); // 리턴되는 url에 앞에 자동으로 이것을 붙인다. vs.setSuffix(\".jsp\"); // 뒤에 이것을 붙여라 vs.setViewClass(JstlView.class); // viewClass는 jstlview이다. return vs;&#125; 페이지 컨트롤러의 return 값을 바꾼다. 스프링 자동화 request, responese를 굳이 파라미터로 가져오지 않고, 원하는 값은 파라미터로 가져와 처리한다. httpSession도 가져올 수 있다. request.set으로 객체를 담지 않고, Model에 담는다. 다시 공부해야 할 것 같아…","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-06 수업 내용 정리","slug":"2018-12-06","date":"2018-12-06T00:45:18.000Z","updated":"2018-12-07T05:28:45.687Z","comments":true,"path":"2018/12/06/2018-12-06/","link":"","permalink":"http://eunajjing.github.io/2018/12/06/2018-12-06/","excerpt":"","text":"MVC 모델MVC 모델1 JSP가 요청을 받는 Controller의 역할을 하면서 동시에 View의 역할도 하는 것 MVC 모델2 Servlet이 Controller의 역할 JSP가 View의 역할 Service도 Model의 역할을 한다, DAO만 Model이 아님 업무 로직 트랜젝션 관리 component 부품, 역할적인 의미가 강조될 때 사용되는 용어 object, instance, bean… JSP 실행 방식 JSP를 실행하고 싶다는 요청이 들어오면 JSP 엔진이 JSP를 JAVA 소스로 만든다 이것은 httpServlet을 상속 받은 서블릿 소스가 된다 이것은 .class파일이 되어 실행되는 것 JSP는 서블릿 클래스를 만드는 재료로 사용되는 것 때문에 JSP는 template이라고 불리기도 한다 즉 JSP는 직접 실행되는 것이 아님 직접 print.out할 필요가 없어서 사용하는 것 JSP 안의 &lt;% %&gt; Domain-Specific language = DSL 12&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; 위에 선언하는 이유 그런데 JAVA만 사용이 가능(향후 다른 언어도 가능하게 하려고 만들었다) 스코프 서버가 시작되며 웹 어플리케이션 실행 하나의 서버에는 여러 개의 웹 어플리케이션이 실행될 수 있다 정확히 말하면 웹 어플리케이션이 시작하면 ServletContext 보관함이 생성 이것은 웹 앱을 종료할 때까지 보관함은 유지된다. 이 보관함에는 IOC Container가 대표적으로 있다. 클라이언트가 최초로 서버에 접속하는 순간에 HttpSession 객체가 생성되며 Session을 무효화할 때 보관함이 사라진다. 유저 단에서 요청이 들어오면 ServletRequest 보관함이 생기고, 응답할 때까지 보관함은 유지된다. JSP는 자신만의 PageContext 스코프를 가진다 JSP가 실행되는 동안에만 유지되는 보관소이다. 때문에 응답이 완료되지 않더라도, 다른 JSP로 실행이 옮겨가는 순간 사라진다. sendRedirect로 이동시킬 때는 상대 경로로 지정해도 된다. 브라우저의 입장에서 경로를 인식하기 때문 서버에서 include, forward시키는 경우에는 루트부터 시켜줘야 한다 Expression Language(EL 태그) 표현언어 ${} Expression : 결과를 리턴하는 것 때문에 태그 안에는 결과를 리턴하는 값이 와야 함 Statment의 일부 (if, else의 {} 등) OGNL 오브젝트 그래프 네비게이션 언어 EL 태그 안에서 쓸 수 있다 객체 안의 객체를 가리킬 때 쓰는 표기법 html meta tag 중에 실행 후 reloading을 지원하는 태그가 있다 123&gt; &lt;meta http-equiv=\"Refresh\" content=\"1;url=list\"&gt;&gt; // 1초 후에 어디로 리로딩하겠다&gt; component button에 타입이 지정이 안되면 기본 submit 버튼 Filter 필터 역할을 할 클래스는 Filter 인터페이스를 상속 받아야 함 dofilter메서드를 구현 init() detory() 12345인터페이스 &#123; default 리턴타입 메서드() &#123; 정의 &#125;&#125; 원래 인터페이스는 메서드를 구현할 수 없으나, 인터페이스에 기본적으로 적용이 되는 메서드을 추가 시키기 위해 사용 init와 detory가 대표적인 default 메서드 12345678필터 인터페이스를 상속 받은 필터 클래스 &#123; @Override doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#123; chain.doFilter(request, response); // 이 필터 다음에 또 다른 필터가 있다면 그 필터 실행 // 없다면 원래 목적지인 servlet 실행 &#125;&#125; 필터에 sertCharacterEncoding같은 공통으로 들어가는 메서드를 추가하면 편하다 1@webFilter(\"*\") 어노테이션 기입이 필요하다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-05 수업 내용 정리","slug":"2018-12-05","date":"2018-12-05T00:06:18.000Z","updated":"2018-12-07T05:32:11.038Z","comments":true,"path":"2018/12/05/2018-12-05/","link":"","permalink":"http://eunajjing.github.io/2018/12/05/2018-12-05/","excerpt":"","text":"Bean 컨테이너 SW의 용어Engine 일을 실행하는 역할 Parser 해석하는 역할 엔진보다 협소한 의미, 실행까지 하면 엔진이라고 한다 Container 객체의 생성과 소멸을 관리 VM 생성과 실행과 소멸을 담당하는 역할 컨테이너 + 엔진의 느낌 Bean 인스턴스, 오브젝트, 객체 의존 객체 주입이 필요 생성자에 파라미터로 던져주던 것들 IOC Container(DI Container) 의존 객체를 주입한 빈 컨테이너(IOC != DI)(IOC &gt; DI) 제어의 역행이 일어난다 메인 흐름과 별개의 이벤트 핸들러(리스너) 메서드가 실행된다 생성하지 않은 객체가 외부에서 만들어져 주입 된다 IOC의 3대 예 중 2개 이벤트 리스너 DI = 의존 객체 주입(생성이 아님) DI를 쓰면 좋은 점 의존 객체 대체가 쉽다(예를 들어 지불 수단이라는 인터페이스 급의 객체를 DI해서 넣어두면, 지불 수단 인터페이스를 상속 받은 돈, 카드 등의 재화도 주입이 가능) 단위 테스트가 쉽다 (예를 들어 원래 과일을 가는 믹서기를 만든다고 했을 때, 믹서기를 만드는 도중 테스트를 한다고 가정하자. 과일까지 모두 조달해서 믹서기를 작동하는 구조 OR 믹서만 작동이 가능한 구조 중에 단위 테스트가 쉬운 건 후자. 테스트할 때 과일 외에도 다양한 식품을 넣어볼 수 있다.) 쓸모 없는 데이터의 생성을 최소화할 수 있다(자원 낭비가 덜 함) Spring IOC Container spring 공부 다시 해야할 듯… dependncies에 Spring-context 의존 설정을 해준다.(maven에서 검색함) Spring Ioc 설정 파일 추가 xml로 설정하거나 class로 설정하는 방법 두 개 AppConfig.java(Class) 작성 만약 내가 만든 클래스가 아니라서, 즉 IOC Container가 자동으로 생성할 수 없는 경우 메서드를 정의하여 직접 객체를 생성해야 한다. mybatis 관련 객체의 경우가 대표적으로, sqlSessionFactory가 가 그렇다. SqlSessionFactory 객체를 생성하는 메서드 추가 12345678910111213141516package com.eomcs.lms;// ioc Container에게 패키지 이름을 알려준다// 이름을 알려주면 그 패키지를 뒤져서 @conponent가 붙은 클래스에 대해// 인스턴스를 자동으로 생성@ComponentScan(\"com.eomcs.lms\")public class AppConfig &#123; @Bean // Spring IOC Container에게 이 메서드를 호출하여 리턴 값을 보관하라고 표시하는 어노테이션 public SqlSessionFactory createSqlSessionFactory() throws Exception&#123; String resource = \"com/eomcs/lms/conf/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream); // 리턴 값을 저장할 때 사용할 이름을 따로 지정하지 않으면 메서드 이름으로 저장되기에 // 이런 메서드의 이름은 동사가 아닌 객체의 이름인 명사 형태로 짓는다 &#125;&#125; 이름 지정하는 방법@Bean(&quot;이름&quot;)은 이러하지만 잘 사용하지 않는다. dao 클래스는 내가 만든 클래스므로, 해당 클래스 위에 객체 자동생성하도록 설정 이 때 당연히 인터페이스는 객체 생성이 불가하므로, 상속 받은 클래스에 어노테이션 @Component 이용 Spring Boot xml 설정이 아닌 java class로 설정한다 Spring IOC Container 준비 실행 클래스에 Spring IOC Container 객체 준비 실행 클래스에서 해당 소스 기술 1ApplicationContext iocContainer = new AnnotationConfigApplicationContext(AppConfig.class); 그리고 이 소스를 1Command commandHandler = commandMap.get(command); 이렇게 변경 123Command commandHandler = (Command) iocContainer.getBean(command); // 빈을 찾으면 정상 실행, 빈을 못 찾으면 예외가 발생 // 때문에 if else가 아니라 try catch 처리 차후에 iocContainer도 close() 필요 Class 정보를 보고자 할 때12345678910111213141516171819202122232425262728293031&gt; Class&lt;?&gt; clazz = Class.forName(\"com.eomcs.lms.AppConfig\");&gt; // AppConfig 클래스가 메모리에 로딩되어 있지 않다면 로딩 후 클래스 정보 리턴&gt; // 어떤 클래스라도 상관 없이 받기 위해 제네릭 &lt;?&gt;&gt; // class가 이미 사용되는 예약어라 clazz로 객체 이름 설정이 일반적&gt; // AppConfig.class와 같다.&gt; &gt; // Reflection 클래스 : JVM에 로딩되어 있는 있는 클래스와 메소드 정보를 읽어 올 수 있다&gt; &gt; Method[] methods = clazz.getMethods();&gt; // 클래스의 모든 메서드들이 들어온다&gt; &gt; Constructor[] constructors = clazz.getConstructors();&gt; // 생성자의 정보&gt; Class&lt;?&gt; returnType = methods[0].getReturnType();&gt; // 메서드의 리턴 타입&gt; Parameter[] params = methods[0].getParameters();&gt; // 메서드에 들어가는 파라미터&gt; &gt; ApplicationContext iocContainer = new AnnotationConfigApplicationContext(AppConfig.class);&gt; // 확장자(.class)가 아닌 클래스 변수명임을 기억할 것&gt; System.out.println(iocContainer.getBeanDefinitionCount());&gt; // 몇 개의 객체 생성을 했는지&gt; String[] names = iocContainer.getBeanDefinitionNames();&gt; // 생성된 객체들의 이름을 리턴&gt; &gt; for (String name : names) &#123;&gt; System.out.printf(\"%s ===&gt; %s\\n\", name, iocContainer.getBean(name).getClass().getName());&gt; // 객체 이름 ===&gt; 경로 출력됨&gt; // 객체의 이름을 지정하지 않았다면 클래스명 맨 앞 대문자를 소문자로 변경해 사용&gt; &#125;&gt; Spring IOC 컨테이너와 mybatis 연동 buid.gradle에 mybatis-spring 의존 설정 추가 sqlSessionFactory 객체 생성 mybatis-spring에서 제공하는 도우미 클래스를 사용해 만드는 것으로 메서드 변경 apache common-dbcp 라이브러리 추가datasource 구현체(db 커넥션풀 객체) buid.gradle에 commons-dbcp2 의존 설정 추가 기존 소스가 이런 상태에서 123456@Beanpublic SqlSessionFactory sqlSessionFactory() throws Exception &#123; String resource = \"com/eomcs/lms/conf/mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); return new SqlSessionFactoryBuilder().build(inputStream);&#125; 이렇게 변경하고, 12345678910@Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); // datasource 주입 factoryBean.setDataSource(dataSource); return factoryBean.getObject(); &#125; 123456789101112131415161718192021222324252627282930313233343536클래스 위에 `@PropertySource` 어노테이션을 더 추가해주고, 가져오는 프로퍼티 파일이 들어갈 수 있도록 `@value` 어노테이션도 클래스 변수 위에 기술해준다.```// spring ioc Container에게 프로퍼티 파일을 로딩할 것을 명령@PropertySource(\"classpath:/com/eomcs/lms/conf/jdbc.properties\")// 프로퍼티가 있는 위치를 가리키되, 기술하는 방식을 지켜야 한다.public class AppConfig &#123; @Value(\"$&#123;jdbc.driver&#125;\") String jdbcDriver; @Value(\"$&#123;jdbc.url&#125;\") String jdbcUrl; @Value(\"$&#123;jdbc.username&#125;\") String jdbcUserName; @Value(\"$&#123;jdbc.password&#125;\") String jdbcPassword;```객체 생성 메서드를 만들어준다. (basic datasource 방식)``` @Bean public DataSource dataSource() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(jdbcDriver); dataSource.setUrl(jdbcUrl); dataSource.setUsername(jdbcUserName); dataSource.setPassword(jdbcPassword); return dataSource; &#125;```이제 db 커넥션을 java 파일에서 하므로, `mybatis-config.xml`에서 중복 기술 사항을 삭제한다.- db 커넥션 풀- db 연결 정보를 담은 프로퍼티 파일 로딩 트랜젝션 관리자 spring 트랜젝션 관련 라이브러리 의존 설정(Spring JDBC) 추가 AppConfig에 PlatformTransactionManager를 리턴하는 메서드 구현 이 때 이 객체의 이름은 반드시 transactionManager로 설정 다른 이름으로 설정하면 트랜젝션과 관련한 다른 객체를 생성할 때 그 객체가 트랜젝션 관리자를 자동으로 찾지 못한다. 생성자 메서드 소스는 다음과 같다. 123public PlatformTransactionManager platformTransactionManager(DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; 이제 db 트랜젝션 관리 또한 java 파일에서 하므로, mybatis-config.xml에서 중복 기술 사항을 삭제한다. 도메인 클래스에 별명 구현 SqlSessionFactory를 반환하는 메서드에 다음의 설정을 세팅한다. 1factoryBean.setTypeAliasesPackage(\"com.eomcs.lms.domain\"); 마찬가지로 별명 지정 또한 java 파일에서 했으므로, mybatis-config.xml에서 중복 기술 사항을 삭제한다. SQL을 보관한 XML 파일 경로 또한 java 파일에서 가능 12345678910111213141516@Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource, ApplicationContext iocContainer) throws Exception &#123; SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setMapperLocations(iocContainer.getResources(\"classpath:/com/eomcs/lms/mapper/*Mapper.xml\")); // sql mapper 로딩 // sql 파일이 있는 위치를 파라미터로 보내야 하는 상황 // sql 파일의 위치 정보를 resource 객체에 담아 넘겨야 함 // resource 객체는 Spring IOC Container를 통해 만들 수 있다. // Spring IOC Container 객체를 얻는 방법 : 메서드의 파라미터로 받는다. // 이 경우 ioc container 생성은 실행 클래스에서 하기에 // 실행 클래스에서 해당 객체가 넘어온다. return factoryBean.getObject(); &#125; mybatis-config.xml가 더 이상 필요 없다 웹 어플리케이션 이론 웹 브라우저는 http 프로토콜에 맞춰서 웹 서버에 요청한다. 웹 서버는 우리가 만든 프로그램을 실행해서 결과를 받아서 http 프로토콜 규칙에 맞춰 응답해야 한다. 그런데 웹서버의 역할은 프로그램을 실행하는 게 아니다. 웹서버는 정적 웹 리소스 html, css, java script, png, jpeg 등을 읽어서 웹 브라우저에게 리턴하는 게 원래 역할이다. 웹서버가 프로그램을 실행해야하는 상황이니까 프로그램을 실행할 중간 객체를 필요로 하게 된다. 실행해야 하는 리소스(DB와 같은 것)은 동적 리소스(Dynamic Web Resource) ioc container는 웹서버의 요청이 들어오면 메서드를 호출해 프로그램을 실행시켜 리턴 값을 전달한다. 웹 서버는 웹 브라우저로 http 프로토콜 규칙에 맞춰 리턴 값을 응답한다. 웹 브라우저는 응답 받은 것에 맞춰 화면을 출력한다. 웹 어플리케이션이란 웹 기반으로 프로그램 실행되는 자바 프로그램 웹 어플리케이션이 하나의 객체로 이루어진 게 아닌 만큼, 기능을 잘게 쪼개서 하나의 클래스가 하나의 기능을 수행하게끔 만들어야 한다. 웹 어플리케이션은 서버 프로그램인데 간단한 작업만을 수행한다. 때문에 서버 어플리케이션의 작은 조각이라는 의미로 접미사 let을 붙인다. 서블릿(Servlet) 웹 어플리케이션을 구성하는 요소들 작은 서버 프로그램 서블릿 컨테이너(WAS) 웹 서버 상에서 실행되는 자바 컨테이너 서블릿 컨테이너의 대표적인 예는 톰캣 서블릿 컨테이너는 이미 다운 받아 사용하는 것이고 개발자는 서블릿을 만드는 것 웹 서버, 웹 브라우저는 종속이 아니지만(http 프로토콜 규칙 때문) 서블릿은 서블릿 컨테이너에 종속된다. 예를 들어 버전이 맞지 않는다면 실행되지 않는다. 서블릿 컨테이너와 서블릿이 통신할 수 있도록 규칙이 있고 이들은 인터페이스로 구성되어 있다. 서블릿 필터 리스너 규칙이 들어 있는 인터페이스들이 자동으로 들어있는 것은 JAVA EE(웹 기술와 분산 기술-EJB-, 웹 서비스 기술, 자원 관리 기술) 대표적인 것 : 자바 EE 구현체 웹로직 웹스피어(IBM 서버) JBoss Glasspish Geronemo 톰캣 : EE 모두 구현이 아닌 웹 기술만 뽑아서 만든 것 Jeus 웹 어플리케이션을 구성하는 요소 서블릿 필터 리스너 servlet의 메서드인터페이스로 구현되어 있는 기본 5개의 메서드 init() service() detory() getServletInfo() getServletConfig() 서블릿 구현 1234567891011121314151617// 어노테이션을 이용해 톰캣 서버에 서블릿이 있음을 알리고// 루트 디렉토리부터 쓴 url을 매핑해준다.// 톰캣 서버에 서블릿을 추가한 후 서블릿을 변경하면 일정 시간이 지난 후 리로딩 가능// 추가하는 경우에만 서버 재시작 필요@WebServlet(\"/board/list\")public class BoardListServlet implements Servlet&#123;(4개의 메서드 생략) @Override public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; res.setContentType(\"text/palin;charset=utf-8\"); PrintWriter out = res.getWriter(); // 클라이언트 쪽에 출력할 때 필요한 객체준비 out.println(\"게시물 목록\"); &#125; 1public class BoardListServlet extends GenericServlet &#123;&#125; 이렇게 추상클래스 GenericServlet을 상속 받아도 된다. GenericServlet에는 service메서드를 제외한 메서드가 구현이 되어 있기에 service만 구현하면 된다. 또한 HttpServletRequest와 HttpServletResponse를 파라미터로 사용하기 위해 추상클래스 HttpServlet(GenericServlet을 상속 받음)을 상속 받아도 된다. 12345public class BoardListServlet extends HttpServlet&#123; @Override public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; .. &#125;&#125; HttpServletRequest와 HttpServletResponse를 파라미터로 사용할 수 있는 service는 doget 과 dopost 호출이 가능하다. httpServlet은 service 실행 시 부모인 GenericServlet에 정의된 service메서드를 부르고, 이 메서드는 다시 HttpServletRequest와 HttpServletResponse를 파라미터로 쓰는 service메서드를 내부적으로 부르며 실행된다. 서블릿 컨테이너는 바로 doget과 dopost를 직접 부르지 못한다. filter의 메서드 init() service() detory() listener의 메서드123456789101112131415161718192021222324252627282930313233343536373839@WebListenerpublic class ContextLoaderListener implements ServletContextListener&#123; // 웹 어플리케이션이 시작되거나 종료될 때 호출되는 메서드를 정의한 것 AnnotationConfigApplicationContext iocContainer; // 다른 메서드에서도 접근이 가능하도록 전역변수로 올린다. @Override public void contextDestroyed(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(\"웹 어플리케이션이 종료될 때 자동 호출\"); // Spring IOC Container 자원을 해제 iocContainer.close(); &#125; @Override public void contextInitialized(ServletContextEvent sce) &#123; // TODO Auto-generated method stub System.out.println(\"웹 어플리케이션이 시작될 때 자동으로 호출\"); // AppConfig 클래스가 메모리에 로딩되어 있지 않다면, // Spring IoC 컨테이너 준비하기 iocContainer = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(iocContainer.getBeanDefinitionCount()); String[] names = iocContainer.getBeanDefinitionNames(); for (String name : names) &#123; System.out.printf(\"%s ===&gt; %s\\n\", name, iocContainer.getBean(name).getClass().getName()); &#125; // Spring IOC Container를 servlet이 사용할 수 있도록 // servletContext라는 보관소에 저장 ServletContext sc = sce.getServletContext(); // 파라미터로 들어온 ServletContextEvent를 이용해 IOC Container를 받을 준비 sc.setAttribute(\"iocContainer\", iocContainer); &#125;&#125; WAS가 요청을 받으면 service 메서드가 실행되며 doget이나 dopost 실행됨 servlet 호출됨 이 순간부터 IOC Container가 관리하는 게 아니라 관리자가 WAS로 넘어감 그런데 dao부터는 IOC Container가 관리 때문에 servlet에 IOC Container의 주소를 알려줘야 함 1sc.setAttribute(\"iocContainer\", iocContainer); 이 작업이 이루어지는 이유 그리고 HttpServlet를 상속 받은 BoardListServlet 소스 코드는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 어노테이션을 이용해 톰캣 서버에 서블릿이 있음을 알리고// 루트 디렉토리부터 쓴 url을 매핑해준다.@WebServlet(\"/board/list\")public class BoardListServlet extends HttpServlet&#123; ApplicationContext iocContainer; BoardDao boardDao; @Override public void init() throws ServletException&#123; // 서블릿 인터페이스에 정의된 init(ServletConfig)가 먼저 호출되고, init(ServletConfig)가 init()를 호출하는 것 // 톰캣이 바로 호출하는 게 아님 // boardDao 객체를 꺼내기 위해 먼저 IOC Container를 꺼낸다. ServletContext sc = this.getServletContext(); // ServletContext는 웹 어플리케이션 당 한 개 뿐이다. // ContextLoaderListener에서 꺼낸 것과 같은 객체가 온다. iocContainer = (ApplicationContext) sc.getAttribute(\"iocContainer\"); // 오브젝트 자료형이 리턴되어 applicationcontext 인터페이스로 받는다 try &#123; boardDao = iocContainer.getBean(BoardDao.class); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; res.setContentType(\"text/palin;charset=utf-8\"); PrintWriter out = res.getWriter(); // 클라이언트 쪽에 출력할 때 필요한 객체준비 out.println(\"게시물 목록\"); try &#123; List&lt;Board&gt; list = boardDao.findAll(); for (Board board : list) &#123; out.printf(\"%3d, %-20s, %s, %d\\n\", board.getNo(), board.getContents(), board.getCreatedDate(), board.getViewCount()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; servlet에서 dao 도달 dao에서 mariaDB 도달 설정서블릿 어플리케이션 개발에 사용할 라이브러리 추가 build.gradle에서 빌드 명령 사용이 가능할 수 있도록 설정 eclipse 대신 eclipse-wtp 플러그인 추가 웹 어플리케이션 배치 파일(.war)을 만들 war 플러그인 추가 단독으로 실행이 불가하므로 application 플러그인도 제거 mainClassName = &#39;App&#39; 도 제거 12345plugins &#123; id 'java' id 'eclipse-wtp' id 'war'&#125; servlet-api 의존 설정 1providedCompile group: 'javax.servlet', name: 'javax.servlet-api', version: '4.0.1' providedCompile : 개발하는 동안에만 사용하겠다 compile : 개발하는 동안에도 사용하고, 배포 시에도 함께 쓰겠다. src/main/webapp : 웹 자원을 둘 디렉토리 생성","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"안드로이드 스튜디오를 이용해 안드로이드 앱 만들기","slug":"android1","date":"2018-12-05T00:06:18.000Z","updated":"2018-12-06T15:32:18.270Z","comments":true,"path":"2018/12/05/android1/","link":"","permalink":"http://eunajjing.github.io/2018/12/05/android1/","excerpt":"","text":"설치 Java JDK 설치 및 환경변수 설정 안드로이드 스튜디오 설치 Hello, World! MainActivity 프로그램을 제일 먼저 실행시키는 부분 R.class 안드로이드는 모든 것에 다 복잡한 숫자의 id가 붙어있다. id를 사용자가 직접 타이핑해서 사용하는 건 힘들기 때문에 R 클래스 안 아이디 사용에 관한 static 변수/메서드를 구현해 놓아 사용자가 보다 쉬운 방식으로 요소를 이용할 수 있도록 했다. 자동 import 단축키 alt + Enter 상속 메서드들 보기 단축키 ctrl + o 리스트 뷰 꾸미기 참고하고 있는 강의기존에 처음 html로 페이지를 만들 적에 이 분이 만든 강의를 처음 들었었는데, 당시에 많은 도움을 받았던 기억이 나 이번에도 이 분 강의를 듣는 중! 에러 트러블슈팅 처음에는 강의와 똑같이 했는데도 실행이 안됐다. 강의가 만들어진지 좀 됐기 때문에, 나는 당연히 조금 최신 버전의 os와 에뮬레이터를 선택해 실행했는데… 이게 바로 에러의 서막이었다… 처음에는 맥과 JDK가 충돌나서 그런가 했다. 왜냐하면 지금 안드로이드 스튜디오를 맥 OS로 다운로드 받을 때, JDK 일부 버전에서 에러가 날 수도 있다는 경고가 뜨기 때문이다. 관련하여 맥 OS에서 안드로이드 스튜디오로 앱 만드시는 분께 여쭤봤는데 본인은 잘만 돌아간다며 걱정 말라고…. avd에 관한 에러였는데, 찾아보니까 Emulated Performance 부분의 Graphics을 auto가 아니라 Software - GLES 2.0으로 바꾸면 된다고 했다. 나도 바꾸려고 했지만 바꿀 수 없게 블록 잼…. 언제나 그렇듯 구글링하며 흐느끼다가 마음의 고향 스택옾에 갔고 해결책을 얻었다. 고마워여 스택옾…! 제일 위에 채택 받은 답변을 보면, 구글 플레이스토어를 지원하는 기기의 경우에 바꿀 수 없게 막혀있다고 했다. 즉 다른 기기를 선택하면 된다고… 그래서 해결…","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"안드로이드","slug":"개발공부/안드로이드","permalink":"http://eunajjing.github.io/categories/개발공부/안드로이드/"}],"tags":[]},{"title":"2018-12-04 수업 내용 정리","slug":"2018-12-04","date":"2018-12-04T00:21:18.000Z","updated":"2018-12-07T05:33:06.841Z","comments":true,"path":"2018/12/04/2018-12-04/","link":"","permalink":"http://eunajjing.github.io/2018/12/04/2018-12-04/","excerpt":"","text":"리턴 값은 프로그램의 유연성을 위해 인터페이스 자료형으로 한다. try-with-resources 자바 버전 7에 추가된 기능으로 try에 자원 객체를 전달하면 finally 블록으로 close 처리를 하지 않아도, try 코드 블록이 끝나면 자동으로 자원을 종료해주는 기능 closeable 인터페이스를 상속한 객체만이 try 소괄호 안으로 들어올 수 있다 만약 해당 인터페이스를 상속 받지 못했다면 try 구문에 올 수 없다 try 문의 존재 이유가 finally이기 때문에 try-with-resources로 구현했다면 굳이 catch 문을 구현하지 않는다. 이 경우 메서드에서 예외처리가 같이 명시되어 있어야 한다. PreparedStatement로 쿼리문을 날릴 때, ‘? 처리가 try 소괄호 안에서 처리가 불가능하다 이 경우에는 set을 try 구문 안(중괄호 속)에서 입력 1234567891011121314151617181920212223public Board findByNo(int no) throws Exception &#123; DriverManager.registerDriver(new Driver()); try ( Connection con = DriverManager.getConnection(\"jdbc:mariadb://localhost:3306/studydb\", \"study\", \"1111\"); PreparedStatement stmt = con.prepareStatement( \"select bno, cont, cdt, view, mno, lno\" + \" from board where bno=?\");) &#123; stmt.setInt(1, no); try (ResultSet rs = stmt.executeQuery()) &#123; if (rs.next()) &#123; Board board = new Board(); board.setNo(rs.getInt(\"bno\")); board.setContents(rs.getString(\"cont\")); board.setCreatedDate(rs.getDate(\"cdt\")); board.setViewCount(rs.getInt(\"view\")); board.setWriterNo(rs.getInt(\"mno\")); board.setLessonNo(rs.getInt(\"lno\")); return board; &#125; else &#123; return null; &#125; &#125; &#125;&#125; 만약 try 소괄호 안, 마지막 구문은 세미콜론 생략이 가능하다 만약 try 문을 구현한 메서드에서 예외를 던지게 설정되어 있다면 (throws Exception) catch 블록을 따로 구현할 필요가 없다. MyBatis 적용 gradle에 의존 설정을 해준 뒤 gradle eclipse 실행해 설정 파일 갱신 src/main/resources/자바경로/comf에 mybatis-config.xml를 둔다. resources가 없으면 생성 mybatis-config.xml에 자바 소스 폴더로 등록 후 gradle eclipse 재실행 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; jdbc.properties 파일 작성해서 해당 프로퍼티가 안으로 들어갈 수 있도록 설정 1234jdbc.driver=org.mariadb.jdbc.Driverjdbc.url=jdbc:mariadb://localhost:3306/studydbjdbc.username=studyjdbc.password=1111 12345678910111213141516171819202122232425&lt;-- xml은 이렇게 수정된다 --&gt;&lt;configuration&gt;&lt;-- properties의 경로 설정해준다--&gt;&lt;properties resource=\"com/eomcs/lms/conf/jdbc.properties\"&gt;&lt;/properties&gt;&lt;-- db 연결 정보를 설정, default는 아래와 같다 즉 db 연결 정보를 여러 개 설정할 수 있다 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;-- 트랜젝션 관리는 jdbc를 쓰겠다 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;-- db 커넥션 풀 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;-- value와 프로퍼티 파일의 이름이 같아야 한다 --&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;-- sql을 보관할 xml 파일 경로 설정 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/eomcs/lms/mapper/BoardMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; src/main/resources/자바경로/mapper/BoardMapper.xml에 파일 작성(sql문들) 실행 클래스에서 mybatis의 SqlSessionFactory 객체 준비 12345678String resource = \"com/eomcs/lmes/conf/mybatis-config.xml\";&lt;!-- 팩토리 패턴 --&gt;InputStream inputStream = Resources.getResourceAsStream(resource);&lt;!-- 빌더 패턴 --&gt;SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); BoardDao boardDao = new MariaDBBoardDao(sqlSessionFactory); inputStream : 설계도의 역할 SqlSessionFactoryBuilder는 전문적으로 SqlSessionFactory를 만듦 객체 생성 과정이 복잡할 때는 대부분 *Builder 클래스를 활용해 생성 - 빌더 패턴 디자인 패턴 중 하나인 빌더 패턴, 팩토리 패턴 팩토리 패턴은 간단한 조립의 기능 수행, 빌더는 보다 큰 기능을 수행한다 dao가 사용할 수 있도록 생성자에 해당 객체 주입 dao 단에서 세션 생성 123456public List&lt;Board&gt; findAll() throws Exception &#123; try (SqlSession sqlSession = sqlSessionFactory.openSession()) &#123; return sqlSession.selectList(\"DoardDao.findAll\"); &#125;&#125; 실습 중 에러 기록 mapper의 namespace 대소문자 오타 인터페이스 상속 받은 메서드 오타 메서드 실행 시 필요한 파라미터 값 넘기지 않음 gradle eclipse 실행 후 새로고침 에러 mybatis의 경우 오토커밋이 안되기 때문에 커밋 설정을 따로 해줘야 한다.트랜젝션 관리 때문에 오토커밋을 자동으로 실행하는 옵션을 설정할 수 없다. 1234567public int insert(Board board) throws Exception &#123; try (SqlSession sqlSession = sqlSessionFactory.openSession()) &#123; int count = sqlSession.insert(\"BoardDao.insert\", board); sqlSession.commit(); return count; &#125; &#125; 별명 지정 가능 12345&lt;properties resource=\"com/eomcs/lms/conf/jdbc.properties\"&gt;&lt;/properties&gt;&lt;!-- 프로퍼티 아래로 들어와야 한다 --&gt;&lt;typeAliases&gt; &lt;package name=\"com.eomcs.lms.domain\"/&gt;&lt;/typeAliases&gt; db 내 컬럼과 domain의 이름이 다를 때매퍼의 상위에 아래 코드를 기술해 지정해주고, 123456&lt;resultMap type=\"board\" id=\"boardMap\"&gt; &lt;!-- board 칼럼을 프로퍼티 이름과 연결 --&gt; &lt;id column=\"bno\" property=\"no\"/&gt; &lt;!-- pk는 result가 아니라 id로 해줘야 한다 --&gt; &lt;result column=\"cont\" property=\"contents\"/&gt;&lt;/resultMap&gt; sql 태그에서 파라미터맵이나, resultMap으로 위를 가리켜 실행 123&lt;select id=\"findAll\" resultMap=\"boardMap\"&gt; select bno, cont, cdt, view from board&lt;/select&gt;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-12-03 수업 내용 정리","slug":"2018-12-03","date":"2018-12-03T00:08:18.000Z","updated":"2018-12-07T05:33:39.735Z","comments":true,"path":"2018/12/03/2018-12-03/","link":"","permalink":"http://eunajjing.github.io/2018/12/03/2018-12-03/","excerpt":"","text":"지난주 static 블록과 instance 블록 이해가 안되어서 추가로 찾아보았다 참고한 사이트들 목록 참고한 사이트1 참고한 사이트2 참고한 사이트3 스태틱 블록 클래스가 로딩된 후 클래스 변수를 초기화 시키는 코드를 주로 둔다 인스턴스 블록 인스턴스가 생성된 후 실행 인스턴스 변수를 초기화 시키는 코드를 주로 둔다 어떤 생성자가 호출되든 공통적으로 실행되어야 하는 코드가 있다면 작성한다 일단 클래스를 읽어야 하므로, 클래스 로딩 - 스태틱 블록 실행 - 객체 생성(ex. int i) 완료 - 인스턴스 블록 실행 클래스가 로딩되다 클래스 로더는 자바 바이트 코드를 읽어들여 클래스 객체를 생성하는 역할을 담당 로더가 읽은 바이트 코드가 올바르다면, 메서드 에리어 영역으로 파일이 로딩된다 JVM에 로딩된 클래스만이 객체로 사용이 가능하다 3.7부터 건너 뛰었는데, 따로 공부를 해야할 것 같다. braw 업데이트해야한다 DBMSMYSQLmysql 서버에 접속하기로컬 MySQL 서버에 접속 mysql -u root -pEnter password: 암호입력 원격 MySQL 서버에 접속 mysql -h 서버주소 -u root -pEnter password: 암호입력 mysql root 암호 변경 alter user ‘root‘@’localhost’ identified by ‘1111’; MySQL 사용자 추가 CREATE USER ‘사용자아이디‘@’서버주소’ IDENTIFIED BY ‘암호’; 로컬에서만 접속할 수 있는 사용자를 만들기: CREATE USER ‘study‘@’localhost’ IDENTIFIED BY ‘1111’; =&gt; 이 경우 stidu 사용자는 오직 로컬(서버를 실행하는 컴퓨터)에서만 접속 가능한다.=&gt; 다른 컴퓨터에서 실행하는 MySQL 서버에 접속할 수 없다는 것을 의미한다. 원격에서만 접속할 수 있는 사용자를 만들기: CREATE USER ‘study‘@’%’ IDENTIFIED BY ‘1111’; =&gt; 이 경우 study 사용자는 원력에서만 접속 가능하다. (% = 원격) MySQL 사용자 목록 조회 select user from 데이터베이스명.테이블명; select user from mysql.user; MySQL 데이터베이스 생성 CREATE DATABASE 데이터베이스명DEFAULT CHARACTER SET utf8DEFAULT COLLATE utf8_general_ci; CREATE DATABASE studydbDEFAULT CHARACTER SET utf8DEFAULT COLLATE utf8_general_ci; MySQL 사용자에게 데이터베이스 사용 권한 부여 GRANT ALL ON 데이터베이스명. TO ‘사용자아이디‘@’서버주소’;GRANT ALL ON studydb. TO ‘study‘@’localhost’;GRANT ALL ON studydb.* TO ‘study‘@’%’; 데이터베이스 목록 조회 show databases; 사용자 교체 quit (프로그램 종료 후)mysql -u study -p (다시 실행) 기본으로 사용할 데이터베이스 지정하기 use 데이터베이스명use studydb; 데이터베이스의 전체 테이블 목록 조회 show tables; 흐름 웹 브라우저의 요청 서블릿 필터가 거른다 디스패처 서블릿 호출 인터셉터 발동 가능 페이지 컨트롤러 호출 jsp 호출 서비스 호출 dao 동작 db 도달 스프링의 3대 필터 서블릿 필터 인터셉터 aop 자유로운 영혼, 메서드 호출 전후에 꼽는 필터 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용하도록 지원 DB 포함 관계 : 회원과 학생 엔티티의 관계 상호 배타 관계 : 학생과 교사 엔티티의 관계 인덱스 칼럼의 지정: insert, update, delete 시 실행 속도는 느려지나 select 속도가 빨라짐 도메인 : 실무에 가면 엔티티가 많아지므로, 비슷한 종류의 칼럼들을 묶어 관리하기 위해 사용 gradle 사용법 maven에서 jar 파일을 gradle로 복사한 뒤 build.gradle에 dependencies에 붙여넣고 cmd에서 gradle ecilpse","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-11-30 수업 내용 정리","slug":"2018-11-30","date":"2018-11-30T00:08:18.000Z","updated":"2018-12-07T05:35:26.530Z","comments":true,"path":"2018/11/30/2018-11-30/","link":"","permalink":"http://eunajjing.github.io/2018/11/30/2018-11-30/","excerpt":"","text":"과제 이건 좀 어려워서 복습 과제 할 예정(25)! 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.eomcs.lms.handler;import java.util.Arrays;import com.eomcs.lms.domain.Lesson;public class LessonList &#123; static final int LENGTH = 10; private Lesson[] list; private int size = 0; public Lesson[] toArray() &#123; return Arrays.copyOf(list, size); &#125; void add(Lesson lesson) &#123; if (size &gt;= list.length) &#123; int oldLength = list.length; // int newCapacity = oldLength + (int)(oldLength + 0.5); // 만약 배열의 크기만큼 데이터가 찼다면 // 새 배열을 만들어서 복제를 해야함 // 그래서 새 배열을 기존 배열의 1.5배로 늘려준다 // cpu는 부동 소수점 연산이 복잡함 // 그래서 이렇게 쓴다 int newCapacity = oldLength + oldLength &gt;&gt; 1; // 소수점을 좌측으로 이동해 우측의 소수점을 버린다 // 비트 이동 연산자 사용 list = Arrays.copyOf(list, newCapacity); &#125; list[size++] = lesson; &#125; public LessonList() &#123; list = new Lesson[LENGTH]; &#125; public LessonList(int initialCapacity) &#123; if (initialCapacity &gt; LENGTH) &#123; list = new Lesson[initialCapacity]; &#125; else &#123; list = new Lesson[LENGTH]; &#125; &#125;&#125; 1234567891011121314151617181920212223242526package com.eomcs.lms.handler;import java.sql.Date;import java.util.Scanner;import com.eomcs.lms.domain.Lesson;public class LessonHandler &#123; Scanner keyboard; LessonList list; public LessonHandler(Scanner keyboard) &#123; this.keyboard = keyboard; list = new LessonList(); &#125; public void listLesson() &#123; Lesson[] lessons = list.toArray(); for (Lesson lesson : lessons) &#123; System.out.printf(&quot;%3d, %-15s, %10s ~ %10s, %4d\\n&quot;, lesson.getNo(), lesson.getTitle(), lesson.getStartDate(), lesson.getEndDate(), lesson.getTotalHours()); &#125; &#125; 다형적 변수 사용 과제 12345678910111213141516package com.eomcs.lms.handler;import java.util.Arrays;public class ArrayList &#123; final int DEFAULT_CAPACITY = 10; int size = 0; // 배열은 어떻게 처리하지? // 다형적 변수 사용! Object[] list; // 그러나 모든 자료형을 받을 수 있기 때문에-오토박싱(자동으로 객체로 포장)로 싸서- // 이를 막고자 핸들러 측에서 제네릭 사용 public ArrayList() &#123; list = new Object[DEFAULT_CAPACITY]; &#125; 123456789101112131415161718192021222324252627282930package com.eomcs.lms.handler;import java.sql.Date;import java.util.Scanner;import com.eomcs.lms.domain.Board;public class BoardHandler &#123; Scanner keyboard; ArrayList&lt;Board&gt; list; public BoardHandler(Scanner keyboard) &#123; this.keyboard = keyboard; this.list = new ArrayList(20); &#125; public void listBoard() &#123; Object[] boards = list.toArray(); // 여기서 강제 형변환을 할 수 없음 for (Object obj : boards) &#123; Board board = (Board) obj; // 여기서는 가능함 // 실제로 object 배열이기 때문에 board 배열로 바꾸는 건 안되는 것이고, // 배열에 들어있는 data는 원래 자료형이 board이기 때문에 // 형 변환이 여기서는 가능한 것 System.out.printf(\"%3d, %-20s, %s, %d\\n\", board.getNo(), board.getContents(), board.getCreatedDate(), board.getViewCount()); &#125; &#125; 오토박싱과 오토언박싱123456&gt; int i = 10;&gt; Integer obj = new Integer(100);&gt; &gt; obj = 200; // 이렇게도 되는데, 사실 오토박싱으로 new Integer(200); 된 것&gt; int j = obj; // 이렇게도 되는데, 사실 오토언박싱으로 obj.intValue(); 된 것&gt; System.arraycopy의 이용 배열을 복사할 때는 arraycopy(소스가 되는 배열, 소스 배열의 몇 번째 인덱스부터, 저장할 배열, 저장을 시작할 배열 인덱스, 배열 복사할 개수) 12배열.arraycopy(src, srcPos, dest, destPos, length);// dest 배열 destPost 번부터 length 개를 복사해 src 배열 srcPost 번째부터 저장 만약 저장할 배열이 복사 받을 배열보다 크기가 작다면 카피를 하되, 자료형을 가져온다. 123if(a.,length &lt; size) &#123; (WhatType[]) Arrays.copyOf(list, size, a.getClass());&#125; 못 따라감 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.eomcs.util;import java.util.Arrays;public class ArrayList&lt;T&gt; &#123; // T : 어떤 타입 final int DEFAULT_CAPACITY = 10; Object[] elementData; // 여기는 T로 쓸 수 없고, 최초이므로 Object로 배열 만들기 int size = 0; public ArrayList() &#123; elementData = new Object[DEFAULT_CAPACITY]; &#125; public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; DEFAULT_CAPACITY) elementData = new Object[initialCapacity]; else elementData = new Object[DEFAULT_CAPACITY]; &#125; @SuppressWarnings(\"unchecked\") // 에러 체크하지 않는다 public T[] toArray(T[] a) &#123; if (a.length &lt; size) &#123; // 만약 size가 a보다 크다면, 즉 배열의 방이 다 찼다면 return (T[]) Arrays.copyOf(elementData, size, a.getClass()); &#125; System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) // 보통 빈 배열일 경우 자동으로 null 값이지만 // 배열을 재사용했을 경우를 대비해 데이터 뒤를 null로 만들어준 것 // 배열의 끝을 모르기 때문에 null 처리 a[size] = null; return a; &#125; public void add(T obj) &#123; if (size &gt;= elementData.length) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); elementData = Arrays.copyOf(elementData, newCapacity); &#125; elementData[size++] = obj; &#125; public int size() &#123; return this.size; &#125;&#125; 12345678910111213141516171819202122232425262728package com.eomcs.lms.handler;import java.sql.Date;import java.util.Scanner;import com.eomcs.lms.domain.Member;import com.eomcs.util.ArrayList;public class MemberHandler &#123; Scanner keyboard; ArrayList&lt;Member&gt; list; public MemberHandler(Scanner keyboard) &#123; this.keyboard = keyboard; this.list = new ArrayList&lt;&gt;(20); // 위에서 정의를 했기 때문에 제네릭을 비운 것 &#125; public void listMember() &#123; Member[] members = list.toArray[list.size()]; // 이거는 이렇게 할 수도 있음 // Member[] members = list.toArray(new members[] &#123;&#125;); // 빈 배열을 보내도, 어차피 ArrayList에서 조건문을 걸었기 때문에 가능한 것 for (Member member : members) &#123; System.out.printf(\"%3d, %-4s, %-20s, %-15s, %s\\n\", member.getNo(), member.getName(), member.getEmail(), member.getTel(), member.getRegisteredDate()); &#125; &#125; Arrays.copyOf와 .clone()의 차이 Arrays.copyOf : 배열의 크기만큼 복제 .clone() : 배열 안에 들어 있는 인스턴스만큼 복제 뛰어넘음, 인터페이스가 필요한 이유 인터페이스의 메서드는 모두 공개 상태여야 한다. (Default로 접근 제한을 걸었다) LinkedList와 ArrayList LinkedList List 인터페이스를 구현한 AbstractList를 상속하지 않고 AbstractSequentialList를 상속 자료의 주소 값으로 서로 연결되어 있는 구조 inkedList는 몇 개의 참조자만 바꿈으로써 새로운 자료의 삽입이나 기존 자료의 삭제를 위치에 관계없이 빠른 시간안에 수행 가능 자료의 최대 개수에 영향을 받지 않음(무한 개수의 자료를 삽입 가능) 순차접근만이 가능(무작위 접근 불가) 자료들을 저장 공간에 불연속적인 단위로 저장 메모리 이곳저곳에 산재해 저장되어 있는 노드들을 접근하는데 ArrayList보다는 긴 지연 시간이 소모 참조자를 위해 추가적인 메모리를 할당해야 함 ArrayList List 인터페이스를 구현한 AbstractList를 상속 데이터들이 순서대로 쭉 늘어선 배열의 형식 O(N)만큼의 연산 속도가 걸리기 때문에 자료의 최대 개수에 영향을 받음 ArrayList는 크기가 한정되어 있음 무작위 접근 가능 자료들을 하나의 연속적인 묶음으로 묶어 자료를 저장 스택과 큐 스택 LIFO(Last In Frist Out) push, pop 큐 FIFO(Frist In Frist OUT) offer, poll interface Cloneable clone을 쓰기 위해 상속 받는 것 사실 clone은 object의 메서드이고, Cloneable에서 override 해야할, 실제로 구현할 메서드는 없으나, clone이 사용 된다는 표기 역할을 함 중첩 클래스의 이용(안드로이드가 대개 이런 문법을 이용한다) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.eomcs.util;public class Stack&lt;E&gt; extends LinkedList&lt;E&gt; implements Cloneable &#123; // Cloneable는 clone을 쓰기 위함 // clone은 object의 메서드이나 구현을 하기 위해서는 Cloneable을 상속 받아야 함 // Cloneable에서 실제로 구현할 메서드는 없으나, clone이 된다는 표기 역할을 함 private int maxSize; public Stack() &#123; maxSize = 100; &#125; public Stack(int maxSize) &#123; this.maxSize = maxSize; &#125; @Override public Stack&lt;E&gt; clone() &#123; Stack&lt;E&gt; temp = new Stack&lt;&gt;(); for (int i = 0; i &lt; size(); i++) &#123; temp.add(get(i)); &#125; return (Stack&lt;E&gt;) temp; &#125; // 객체를 생성해서 반복문 돌려서 넣어준 것 public void push(E value) &#123; if (size() == maxSize) remove(0); add(value); &#125; public E pop() &#123; return remove(size() - 1); &#125; public Iterator&lt;E&gt; iterator() &#123; return new IteratorImpl&lt;&gt;(); // 중첩 클래스가 실행되기 전에 인스턴스 블록이 실행될 것이기 때문에 // 게다가 이너 클래스는 외부 클래스에 접근이 가능하기 때문에 // 굳이 객체 클론해서 보내지 않아도 됨 &#125; // 중첩 클래스의 사용 // 어차피 stack에서만 쓸 것이기 때문에 이렇게 구현 class IteratorImpl&lt;T&gt; implements Iterator&lt;T&gt; &#123; Stack&lt;?&gt; stack; int count; int size; &#123; // 인스턴스 블록 // 앞에 아무 것도 없는 것이 특징 // 인스턴스 생성자 호출 전에 먼저 실행되는 블록 // 클래스 안에서 &#123;&#125; 하면 인스턴스 블록 // static 블록은 클래스가 로딩될 때 실행됨 // 이곳의 this는 이너 클래스의 객체 주소를 가리킨다. // 만약 외부 클래스의 객체 주소를 말하고자 한다면 // 클래스명.this로 시작해야 한다. this.stack = Stack.this.clone(); // 이너 클래스는 외부 클래스의 멤버 변수들과 메서드에게 접근 가능 &#125; @Override public boolean hasNext() &#123; return count &lt; Stack.this.size(); &#125; @Override public T next() &#123; count++; return (T) this.stack.pop(); // 중첩 클래스 안이라서 강제 형변환 시킴 &#125; &#125;&#125; 이너 익명 클래스의 활용 1234567public Iterator&lt;E&gt; iterator() &#123; return new IteratorImpl&lt;&gt;() &#123; // 이너 익명 클래스로도 만들 수 있다. // 슈퍼 클래스의 기본 생성자가 호출되며 // 위에서 구현한 메서드 정의가 그대로 들어온다. &#125; &#125; 커맨드 디자인 패턴 메서드 하나만을 구현한 클래스들로 프로그램을 구현한 것 새로운 기능을 추가할 때도 좋고, 유지보수가 보다 원활하다는 장점이 있다. 메서드가 실제 구현된 클래스들은 특정 메서드가 정의된 인터페이스를 상속함 이 메서드는 이름만 같을 뿐 클래스마다 각각 기능이 다르게 구현 실행 클래스에서는 모든 클래스들의 객체를 생성한 뒤, hashMap()에 객체를 담는다. 이 때 키를 기존에 command에 입력하던 문자열로 준다. 그리고 조건문을 돌릴 때 eqauls를 사용하지 않고, 프롬프트에서 받은 문자열을 키로 이용해 interface 자료형으로 value를 받는다. 이 value가 null인지 확인 후, 인터페이스에서 상속된 메서드를 호출하며 기능을 실행한다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-11-29 수업 내용 정리","slug":"2018-11-29","date":"2018-11-29T00:09:18.000Z","updated":"2018-12-07T05:36:32.212Z","comments":true,"path":"2018/11/29/2018-11-29/","link":"","permalink":"http://eunajjing.github.io/2018/11/29/2018-11-29/","excerpt":"","text":"자바 영역 메서드 에리어(Methed Aera) 명령어가 저장 12345678910x &#123; int i = 100; int[] arr; arr = new int[10]; arr[i] = 300; &#125;main &#123; x(); x();&#125; 그런데 만약 문자열이라면? 1234String s = new String(\"Hello World!\");// 이것은 힙으로 간다.String st = \"Hello!\";// 이것은 상수 풀로 간다. 예전에는 String이 char의 배열이었는데, 자바 버전이 올라가며 utf-8로 저장하기 위해 byte의 배열로 변경됨 또한 메서드 호출이 종료되면, 메서드 안의 인스턴스 변수가 소멸된다. 스택(Stack) 메서드 하나 당 하나의 프레임이 형성되고 관련 데이터들의 주소(첫 시작점)가 저장됨 메서드 호출이 종료되면 소멸됨 1234main 프레임 생성x의 프레임 생성 후 소멸x의 프레임 생성 후 소멸프로그램이 종료되면 main 프레임 소멸 힙(Heap) 객체의 데이터가 저장됨 유일하게 garbage가 있는 곳 garbage collector는 특정 객체가 주소를 잃었고 현재 메모리가 부족하다고 생각되면 cpu가 한가할 때 실행됨 (이게 가능한 이유는 참조-레퍼런스- 카운트를 기억하기 때문) 1x 내 데이터들의 메모리가 저장되었다가 garbage collector가 삭제 자바는 객체 배열을 만들 수 없다 그래서 String 배열을 만든다고 했을 때 힙에는 12[ ] [ ] [ ]....// 각각의 칸에 상수 풀 주소가 저장된다 만약 String을 정식 객체 생성을 해서 만들었다고 했을 때 1s의 Hello World가 저장되어 있다 상수 풀(constant pool) 문자열이 저장되었다면 상수 풀(constant pool)에 저장된다! 힙이 아님 이미 같은 문자열이 있다면 새로 메모리를 만들지 않는다 즉 참조 주소가 다르다! 보통 String을 1String st = \"~\"; 로 만들기 때문에(단축 객체 생성) 참조 주소가 같은 것 그래서 equals를 써야 함 헷갈리니까 이전에 했던 예제123456789101112131415&gt; main &#123;&gt; String s1 = new String(\"hello\");&gt; String s2 = new String(\"hello\");&gt; String s3 = \"hello\";&gt; String s4 = \"hello\";&gt; String s5 = s1;&gt; &gt; if(s1 == s2) System.out.println(\"s1과 s2 주소값이 같음\");&gt; if(s2 == s3) System.out.println(\"s2과 s3 주소값이 같음\");&gt; if(s3 == s4) System.out.println(\"s3과 s4 주소값이 같음\");&gt; if(s5 == s1) System.out.println(\"s5과 s1 주소값이 같음\");&gt; if(s1.equals(s2)) System.out.println(\"s1과 s2 객체 내용이 같음\");&gt; if(s1.equals(s3)) System.out.println(\"s1과 s2 객체 내용이 같음\");&gt; &#125;&gt; 콘솔은 s3과 s4 주소값이 같음 s5과 s1 주소값이 같음 s1과 s2 객체 내용이 같음 s1과 s2 객체 내용이 같음 복습 끝내고 수업 시작클래스와 데이터 타입 클래스의 용도 데이터 타입 만들기 오늘의 첫 과제는 여기 처음에 혼자 코딩했을 때 이렇게 했는데, 에러가 났다. 1234567891011121314151617public class App &#123; public static void main(String[] args) &#123; Scanner keyboard = new Scanner(System.in); final int LENGTH = 10; Lesson[] lesson = new Lesson[LENGTH]; // 클래스는 잘 정의했음 int i = 0; while (i &lt; LENGTH) &#123; System.out.print(\"번호? \"); lesson[i].no = Integer.parseInt(keyboard.nextLine()); (중략) &#125; &#125;&#125; 이렇게 하면 nullpointerException이 뜬다. 현재 객체 생성이 되지 않았음! 때문에 while 문 안에서 객체를 생성해주면서 해당 방에 넣어줘야 함 답은 이것 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.sql.Date;import java.util.Scanner;public class App &#123; public static void main(String[] args) &#123; Scanner keyboard = new Scanner(System.in); final int LENGTH = 10; Lesson[] lessons = new Lesson[LENGTH]; int i = 0; while (i &lt; LENGTH) &#123; // 클래스로 정의한 새 데이터 타입의 메모리(인스턴스) 만들기 Lesson lesson = new Lesson(); // 사용자가 입력한 값을 메모리에 담는다. System.out.print(\"번호? \"); lesson.no = Integer.parseInt(keyboard.nextLine()); System.out.print(\"수업명? \"); lesson.title = keyboard.nextLine(); System.out.print(\"설명? \"); lesson.contents = keyboard.nextLine(); System.out.print(\"시작일? \"); lesson.startDate = Date.valueOf(keyboard.nextLine()); System.out.print(\"종료일? \"); lesson.endDate = Date.valueOf(keyboard.nextLine()); System.out.print(\"총수업시간? \"); lesson.totalHours = Integer.parseInt(keyboard.nextLine()); System.out.print(\"일수업시간? \"); lesson.dayHours = Integer.parseInt(keyboard.nextLine()); // i 번째 배열에 수업 정보를 담고 있는 Lesson 객체(의 주소)를 보관한다. lessons[i] = lesson; i++; System.out.print(\"\\n계속 입력하시겠습니까?(Y/n) \"); String answer = keyboard.nextLine().toLowerCase(); if (!answer.equals(\"y\") &amp;&amp; answer.length() &gt; 0) &#123; break; &#125; System.out.println(); &#125; keyboard.close(); System.out.println(); // 빈 줄 출력 for (int j = 0; j &lt; i; j++) &#123; System.out.printf(\"%3d, %-15s, %10s ~ %10s, %4d\\n\", lessons[j].no, lessons[j].title, lessons[j].startDate, lessons[j].endDate, lessons[j].totalHours); &#125; &#125;&#125; 그 외 분기문, 조건문 통합 과제 메서드의 존재 이유를 알아보는 과제(..)쉽게 말해 유지 보수가 쉽도록 만듦 12345678910111213141516171819202122232425262728public class App &#123; static Lesson[] lessons; final static int LENGTH = 10; static int lessonIdx = 0; static Scanner keyboard; // static 메서드에서 접근이 안되기 때문에 모두 클래스 변수로 만든 것 static void addLession() &#123; (중략) &#125; public static void main(String[] args) &#123; keyboard = new Scanner(System.in); lessons = new Lesson[LENGTH]; boards = new Board[LENGTH]; while (true) &#123; System.out.print(\"명령&gt; \"); String command = keyboard.nextLine().toLowerCase(); // 사실 이 2줄의 코드도 메서드로 뺄 수 있다! if (command.equals(\"/lesson/add\")) &#123; addLession(); &#125; (중략) &#125; &#125;&#125; 클래스를 활용하여 메서드 분류 Low Coupling 낮은 결합도 한 클래스는 최대한 적은 클래스를 의존해야 한다. High Cohesion 높은 응집도 한 클래스는 하나의 역할만을 담당한다. 패키지를 사용해 클래스 분류 도메인 : dto, vo, 사용자 정의 데이터 타입 접근 제한자 privatge : 같은 클래스 내에서 접근 가능 default : 같은 패키지 내에서 접근 가능 protected : 같은 패키지 내에서 접근이 가능하고 해당 클래스를 상속 받은 자식 클래스의 경우 접근 가능 public : 누구나 접근 가능 접근 제어자(modifier) 본래 성질을 변경시키는 것 ex : 접근 제한자, static, final 등 클래스 변수와 클래스 메서드의 한계, 인스턴스 변수와 인스턴스 메서드가 필요한 이유 클래스 변수와 인스턴스 변수의 할당 변수 선언은 클래스 로딩이 안된다 클래스 로딩은 단 한 번만 된다. 때문에 클래스 변수는 한 개가 만들어진다 : 클래스가 로딩될 때(클래스 멤버를 사용할 때) 최초 할당 12&gt; Class.forName();&gt; static 블럭 : 클래스가 최초 로딩될 때 실행됨, 즉 여러 번 클래스 멤버를 사용해도 한 번만 실행됨 1234&gt; static &#123;&gt; &gt; &#125;&gt; this : 인스턴스 메서드 내장 변수, 생략 가능 static 메서드에서 사용이 불가능함 this는 객체의 주소 getter, setter의 등장 인스턴스가 유효한 값을 갖도록 제어하기 위해, 변수에 직접 접근을 막으려 접근 제한자를 건다. 멤버 변수들 = 필드 멤버 변수의 이름 = 필드명 getter, setter = 프로퍼티 get, set을 떼고 소문자로 첫 문자를 변경한 것 = 프로퍼티명 필드명과 프로퍼티명은 다른 개념이다 getter만 구성된 경우 : read only property setter만 구성된 경우 : write only property 인스턴스 메서드 = message 라고 하기도 하며, 인스턴스를 다루는 연산자(operator)로 보기도 한다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"2018-11-28 수업 내용 정리","slug":"2018-11-28","date":"2018-11-28T05:45:18.000Z","updated":"2018-12-07T05:37:04.466Z","comments":true,"path":"2018/11/28/2018-11-28/","link":"","permalink":"http://eunajjing.github.io/2018/11/28/2018-11-28/","excerpt":"","text":"2018-11-28 수업이클립스 프로젝트에 파란 느낌표가 있는 경우 동작하지 않는다. 설정 파일이 꼬여서 컴파일이 제대로 안될 가능성이 높다. 1gradle cleanEclipse 이클립스와 관련된 설정 파일이 모두 날라간다(폴더는 그대로 있는 경우도 있다) 자바 프로젝트 폴더 구성첫 날 했으므로 링크로 대체하지만 간단히 요약하자면 gradle init –type… 을 이용한다. build.gradle에서 이클립스 플러그인을 추가 이클립스 플러그인 설치 리터럴(literal), 변수(variables), 키보드 입력 사용 연습 과제1 해결 1234567891011121314151617181920212223242526272829303132333435public class App &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); System.out.println(\"번호?\"); int num = Integer.parseInt(scan.nextLine()); System.out.println(\"수업명?\"); String classTitle = scan.nextLine(); System.out.println(\"수업내용?\"); String classContent = scan.nextLine(); System.out.println(\"시작일?\"); Date classStartDate = Date.valueOf(scan.nextLine()); // sql date 클래스를 이용했다. // Date.valueOf()는 String으로 들어온 값을 date 객체로 만들어주는 것 System.out.println(\"종료일?\"); Date classEndDate = Date.valueOf(scan.nextLine()); // int month = classEndDate.getMonth(); // 이렇게도 된다. System.out.println(\"총수업시간?\"); int totalClassTime = Integer.parseInt(scan.nextLine()); System.out.println(\"일수업시간?\"); int dayClassTime = Integer.parseInt(scan.nextLine()); System.out.println(\"번호 : \"+num); // System.out.printf(\"번호: %s\\n\", args); // 이스케이프 명령어 : 문자열 안에 삽입되는 명령어 System.out.println(\"수업명 : \"+classTitle); System.out.println(\"수업내용 : \"+classContent); System.out.println(\"기간 : \"+classStartDate+\" ~ \"+classEndDate); System.out.println(\"총수업시간 : \"+totalClassTime+\" 시간\"); // System.out.printf(\"총수업시간 : %d\\n 시간\", args); System.out.println(\"일수업시간 : \"+dayClassTime+\" 시간\"); scan.close(); &#125;&#125; static 메서드와 인스턴스 메서드 인스턴스의 값을 다루면 static을 붙이면 안된다, 반드시 인스턴스 메서드로 만들어줘야 한다. 배열과 흐름제어문(분기, 반복)의 사용 과제1 해결 프로젝트 폴더를 기존 것을 복사해서 만들 때 settings.gradle에서 rootProject.name을 변경해준다 프로젝트 폴더로 이동해서 gradle eclipse를 재실행 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.sql.Date;import java.util.Scanner;public class App &#123; public static void main(String[] args) &#123; final int NUMBER = 20; int[] no = new int[NUMBER]; // 4byte 크기 메모리 100개를 heap(인스턴스들이 저장) // 배열은 모두 ref 변수(주소 변수) // 메서드 에리어 // stack (메인 쓰레드 것과... 쓰레드 각각 1개씩 만들어진다) String[] title = new String[NUMBER]; String[] contents = new String[NUMBER]; Date[] startDate = new Date[NUMBER]; Date[] endDate = new Date[NUMBER]; int[] totalHours = new int[NUMBER]; int[] dayHours = new int[NUMBER]; int len = 0; Scanner scan = new Scanner(System.in); for (int i = 0; i &lt; NUMBER ; i++) &#123; System.out.println(\"번호?\"); no[i] = Integer.parseInt(scan.nextLine()); System.out.println(\"수업명?\"); title[i] = scan.nextLine(); System.out.println(\"수업내용?\"); contents[i] = scan.nextLine(); System.out.println(\"시작일?\"); startDate[i] = Date.valueOf(scan.nextLine()); System.out.println(\"종료일?\"); endDate[i] = Date.valueOf(scan.nextLine()); System.out.println(\"총수업시간?\"); totalHours[i] = Integer.parseInt(scan.nextLine()); System.out.println(\"일수업시간?\"); dayHours[i] = Integer.parseInt(scan.nextLine()); len++; System.out.print(\"계속하시겠습니까?(Y/n)\"); String input = scan.nextLine(); if (input.equalsIgnoreCase(\"n\")) &#123; // 대소문자 가리지 않고 break; &#125; else &#123; continue; &#125; &#125; scan.close(); for (int j = 0; j &lt; len ; j++) &#123; System.out.println(no[j]+\",\"+title[j]+\",\"+contents[j]+\",\" +startDate[j]+\"~\"+endDate[j]+\",\"+totalHours[j]+\",\"+dayHours[j]); &#125; &#125;&#125;","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"깃 연습","slug":"git","date":"2018-11-28T00:09:18.000Z","updated":"2018-12-07T05:39:07.515Z","comments":true,"path":"2018/11/28/git/","link":"","permalink":"http://eunajjing.github.io/2018/11/28/git/","excerpt":"","text":"Git 기본 사용법버전 관리 시스템(VCS; Version Control System)이란? 개요 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다. 파일 별로 이전 상태로 되돌리거나 프로젝트 통째로 이전 상태로 되돌릴 수 있다. 시간에 따라 수정 내용을 비교해 볼 수 있다. 누가 문제를 일으켰는지 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. 종류 로컬 버전 관리 시스템 간단한 데이터베이스를 이용하여 파일에서 변경되는 부분(patch set)을 관리한다. 예) RCS(Revision Control System), 이클립스 중앙집중식 버전 관리 파일의 마지막 스냅샷만 받는다(checkout). 스냅샷(snapshot)? 특정 시점의 파일 버전을 기록한 것. 만약 서버에 문제가 생기면 모든 변경 내력(history)을 잃는다. 예) CVS, Subversion, Perforce 등 CVS 개발자 A의 PC에 프로젝트를 하나 만든들어 체크인(서버에 올린다)한다. 다른 개발자 B가 이를 체크아웃(복사)하여 작업을 한다. 작업이 끝난 B는 이를 다시 서버에 올린다. 이 때 파일의 전체가 올라간다. 때문에 네트워크의 오버헤드가 발생한다. subversion CVS의 단점을 해결하기 위해 등장한 것으로, 변경된 것만 서버에 올린다. 변경 기록은 모두 서버에 있다.로컬에 없다, 로컬은 단순한 작업 디렉토리때문에 서버가 장애가 발생했을 경우 변경 기록이 모두 유실된다. 분산 버전 관리 시스템 저장소 전부를 복제한다. 변경 내력(history)까지 모두 복제한다. 예) Git, Mercurial, Bazaar, Darcs 등 Git리눅스 커널 관리를 위해 리누스 토발즈 및 리눅스 개발 커뮤니티에서 개발하였다. 2005년 4월에 개발을 시작하여 2005년 7월 11일에 첫 버전을 출시하였다. 목표 빠른 속도 단순한 구조 수천 개의 동시다발적인 브랜치가 가능한 비선형적인 구조 완벽한 분산 대형 프로젝트에서도 유용할 것 Git의 파일 상태Git은 다음 세가지 상태로 파일을 관리한다. Committed 로컬 데이터베이스에 안전하게 저장되었다는 뜻이다. Modified 파일이 변경되었지만 아직 로컬 데이터베이스에 저장되지 않았다는 뜻이다. Staged 로컬 데이터베이스에 저장할 파일임을 표시했다는 뜻이다. 다음에 커밋을 수행할 때 Staged로 표시된 파일의 변경 내용이 저장될 것이다. Git 프로젝트의 단계Git 프로젝트는 다음 세 가지 단계로 관리된다. .git Directory 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳. 즉 변경 내력과 그 내용이 저장된다. 원격 저장소를 clone 할 때 생성됨. Working Directory 특정 버전을 체크아웃(checkout)하면, .git 디렉토리에 있는 압축된 데이터베이스에서 파일을 가져와서 작업 디렉토리를 만든다. Staging Area .git 디렉토리에 존재하는 단순한 파일이다. commit 할 파일의 정보(스냅샷이라 부른다)를 담고 있다. git commit을 실행하면 이 스냅샷에 기록된 파일을 저장소에 보관하는 것이다. 커밋을 한 후에는 Staging Area는 새 스냅샷을 준비한다. Staging Area는 인덱스라는 이름으로도 부르지만, Staging Area 가 표준 이름으로 사용되는 추세이다. Git 파일의 상태 변화다음은 Git 명령에 따른 파일의 상태 변화를 보여준다. 123456789 Working Directory | Staging Area | .git Directory(Repository)[Untracked] [Unmodified] [Modified]|[ Staged ]|[ Committed ] -----------------------------------|--------------|--------------------------- +-------------------------------------&gt;&gt; : git add +-----------&gt;&gt; : git add +-------------&gt;&gt; : git commit &lt;&lt;-----------------------+ +----------&gt;&gt; : 파일 편집 &lt;&lt;------------+ : 파일 삭제 Untracked - 작업 디렉토리에 새로 파일을 추가한 경우. 아직 스냅샷이나 Staging Area에 등록되지 않은 파일. 즉 git의 버전 관리 대상이 아닌 상태. Unmodified - 마지막 커밋(commit) 이후에 아무것도 수정하지 않은 상태. Modified - 파일의 내용을 변경한 상태. Staged - 다음 커밋에서 저장하도록 Staging Area에 등록되고 표시된 상태. Git 명령다음은 콘솔에서 git 명령을 사용하는 방법이다. git config git의 사용 환경을 설정한다. /etc/gitconfig 설정 파일 시스템의 모든 사용자와 모든 저장소에 적용되는 설정. git config --system 옵션으로 이 파일을 읽고 쓴다. Windows OS의 경로 - C:/ProgramData/Git/config ~/.gitconfig, ~/.config/git/config 설정 파일 특정 사용자만 적용되는 설정. git config --global 옵션으로 이 파일을 읽고 쓴다. Windows OS의 경로 - C:/Users/사용자홈/.gitconfig .git/config 특정 저장소에만 적용되는 설정. git config 옵션을 지정하지 않으면 이 파일을 읽고 쓸 수 있다. 123예1) 사용자 이름 설정하기$ git config --global user.name &quot;Jinyoung Eom&quot;$ git config --global user.email &quot;jinyoung.eom@gmail.com&quot; 12예2) 기본 텍스트 편집기 설정하기$ git config --global core.editor emacs 12예3) 설정 확인하기$ git config --list 12예4) 특정 값 확인하기$ git config user.name git help [명령], git [명령] –help 명령어에 대한 도움말을 볼 수 있다. 123예1) config 명령에 대한 도움말 보기$ git help config$ git config --help git init 존재하는 폴더를 깃 저장소로 만든다. .git 폴더를 생성한다. 깃 저장소 관련 파일을 두는 폴더이다. 12예) ~/git/myProject 폴더를 깃 저장소로 설정하기~/git/myProject$ git init .gitignore Git으로 관리하지 않을 파일을 지정한다. 예를 들면 로그 파일(.log)이나 빌드 도구가 자동으로 생성한 파일 또는 디렉토리 등. 패턴을 사용하여 Git이 무시할 파일을 지정한다. 빈 줄이나 #으로 시작하는 줄은 주석으로 간주한다. 표준 Glob 패턴을 사용한다. /로 시작하면 하위 디렉토리에 적용되지 않는다. 디렉토리는 끝에 /을 붙인다. !로 시작하는 파일은 무시하지 않는다. 1234567891011121314151617181920212223242526예1) 주석을 표시하는 방법#이것은 주석입니다. 또는 빈 줄.예2) bin/ 디렉토리를 통째로 무시하기bin/예3) 현재 디렉토리의 *.log 파일만 무시하기. src/*.log처럼 기타 하위 디렉토리에 있는 *.log 파일은 포함하기/*.log예4) src/*.class 파일은 무시하고, src/main/*.class 파일은 포함하기src/*.class예5) src 디렉토리 및 그 하위 디렉토리에 있는 *.class 파일 무시하기src/**/*.class예6) 현재 디렉토리 및 그 하위 디렉토리에 있는 모든 *.log 파일 무시하기*.log예7) 확장자가 &apos;.o&apos; 또는 &apos;.a&apos;인 파일 무시하기*.[oa]예8) *~파일명이 ~로 끝나는 파일예9) 만약 *.log 파일을 무시한다면, cotext.log 파일은 무시하지 않고 포함하기!context.log git clone [url][폴더] url로 지정한 서버의 저장소를 로컬로 복제한다. 폴더 이름을 지정하지 않으면 저장소 이름으로 폴더를 만들어 복제한다. 폴더 이름을 지정하면 그 이름으로 폴더를 만들어 복제한다. 12예1) github.com의 저장소를 로컬에 복제하기$ git clone https://github.com/eomjinyoung/myProject 12예2) github.com의 저장소를 myProject2라는 이름으로 폴더를 만들어 로컬에 복제하기$ git clone https://github.com/eomjinyoung/myProject myProject2 git add [파일] 작업 디렉토리에 새로 추가한 파일인 경우 Staging Area에 새로 추가된 파일임을 기록한다. 변경한 파일인 경우 Staging Area에 변경된 파일임을 기록한다. 이렇게 Stating Area에 기록된 파일은 한 스냅샷으로 묶이며 커밋할 때 이 스냅샷의 파일들이 저장소에 보관된다. Staging Area에 기록된 파일은 Staged 상태가 된다. 12예1) 현재 폴더에서 확장자가 c인 파일을 Staging Area에 기록하기$ git add *.c 12예2) 현재 폴더에서 LICENSE 이름을 가진 파일을 Staging Area에 기록하기$ git add LICENSE 12예3) 현재 폴더나 하위 폴더의 파일 중에 변경되거나 추가된 파일을 Staging Area에 기록하기$ git add . git commit -m ‘이번 스냅샷을 저장하는 이유’ Staging Area에 기록된 파일들(스냅샷)을 로컬 저장소에 보관한다. 파일을 새로 추가하거나 변경하였다면 반드시 git add를 실행하여 Staging Area에 기록해야 한다. 기록되어 있지 않은 파일이나 변경 사항은 저장소에 보관되지 않는다. 커밋 할 때 마다 스냅샷에 대해 새 체크섬(checksum) 값이 부여되고 이 값이 스냅샷을 구분하는 식별자로 사용된다. 12예1) Staging Area에 있는 파일을 저장소에 보관하기$ git commit -m &apos;첫 번째 버전&apos; 123456예2) git add + git commit = git commit -a -m &apos;설명&apos; 저장소에 넣기 전에 매번 Staging Area에 기록하는 것은 매우 귀찮은 일이다. 이를 한 번에 할 수 있다. 단 Tracked 파일(Staging Area에 있거나 저장소에 있는 파일)만 대상으로 한다. 새로 추가한 파일 중에 아직 staged 상태가 아닌 파일은 제외한다.$ git commit -a -m &apos;바로 저장소로 보관하기&apos; git status 작업 파일의 상태를 조회한다. 1234567891011121314151617181920212223예1) 현재 작업 디렉토리의 파일 상태 보기$ git statusOn branch masterYour branch is up to date with &apos;origin/master&apos;.Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: src/main/webapp/test02.html modified: src/main/webapp/test03.html new file: src/main/webapp/test05.htmlChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: src/main/webapp/index.html modified: src/main/webapp/test01.htmlUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) src/main/webapp/test05.html 12345678예2) 현재 작업 디렉토리의 파일 상태를 짤막하게 보기$ git status --short M src/main/webapp/test01.htmlM src/main/webapp/test02.htmlMM src/main/webapp/test03.html?? src/main/webapp/test04.htmlA src/main/webapp/test05.htmlAM src/main/webapp/test06.html [출력 결과 보는 법] [Staged 상태][Unstaged 상태] [파일 경로] _M src/main/webapp/index.html 작업 디렉토리에 있는 파일을 변경한 경우. M_ src/main/webapp/test01.html 작업 디렉토리에 있는 파일을 변경한 후,‘git add’ 명령으로 Stated 상태로 만든 경우. MM src/main/webapp/test02.html Staged 상태의 파일을 다시 변경한 경우. ?? src/main/webapp/test03.html 작업 디렉토리에 새로 파일을 추가한 경우. A_ src/main/webapp/test04.html 새로 추가한 파일을 ‘git add’ 명령으로 Stating Area에 등록한 경우. AM src/main/webapp/test05.html 새로 추가한 파일을 Staged 상태로 만든 후, 다시 변경한 경우. git diff [옵션] 파일의 변경 내용을 비교한다. 123456789101112131415161718192021예1) 작업 디렉토리에서 변경한 파일과 Staging Area에 등록된 파일과 비교하여 변경경 전/후를 출력하기 $ git diffdiff --git a/src/main/webapp/test01.html b/src/main/webapp/test01.htmlindex 80ba906..3322e11 100644--- a/src/main/webapp/test01.html+++ b/src/main/webapp/test01.html@@ -8,6 +8,6 @@ &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen&quot; href=&quot;main.css&quot; /&gt; &lt;/head&gt; &lt;body&gt;-&lt;h1&gt;Hello!&lt;/h1&gt; +&lt;h1&gt;Hello!x&lt;/h1&gt; &lt;/body&gt;-&lt;/html&gt;\\ No newline at end of file+&lt;/html&gt;diff --git a/src/main/webapp/test03.html b/src/main/webapp/test03.htmlindex 37f2fb7..57c25bf 100644... 123예2) 특정 파일에 대해 변경 전/후를 비교하기$ git diff src/main/webapp/test01.html... 123456789101112131415161718예3) Staging Area에 있는 파일과 저장소에 있는 파일을 비교하기 이 경우 새로 추가한 파일도 보여준다. --staged 와 --cached 는 같은 옵션이다.$ git diff --staged 또는 git diff --cacheddiff --git a/src/main/webapp/test02.html b/src/main/webapp/test02.htmlindex 53e43f2..2f411f8 100644...diff --git a/src/main/webapp/test03.html b/src/main/webapp/test03.htmlindex 53e43f2..2f411f8 100644...diff --git a/src/main/webapp/test05.html b/src/main/webapp/test05.htmlnew file mode 100644 &lt;=== 새 파일이 Staging Area에 있는 경우에 이 문구가 붙는다. index 0000000..3081b8d...diff --git a/src/main/webapp/test06.html b/src/main/webapp/test06.htmlnew file mode 100644 &lt;=== 새 파일이 Staging Area에 있는 경우에 이 문구가 붙는다.index 0000000..3081b8d... git checkout [파일] 작업 디렉토리의 파일을 변경한 후 변경 전으로 되돌릴 때 사용한다. Staging Area에 마지막으로 기록된 버전으로 되돌린다. git add를 수행한 적이 없다면 Staging Area에는 마지막으로 커밋한 파일을 가리킨다. 따라서 마지막으로 커밋된 파일로 되돌릴 것이다. 최후에는 저장소에 있는 것을 가져온다. 12예) src/main/webapp/index.html 파일을 편집 전으로 되돌리기$ git checkout src/main/webapp/index.html git rm [파일] Staging Area의 기록에서 지정된 파일을 뺀다. 작업 디렉토리에 해당 파일이 있다면 그 파일도 자동 삭제된다. 이전 스냅샷에는 해당 파일이 계속 남아 있다. 잘 사용하지 않는다… 123456예1) 작업 디렉토리에 있는 파일을 삭제한 후 Git에서도 제거하기$ rm test01.html &lt;=== 작업 디렉토리에서 파일을 삭제한다.$ git rm test01.html &lt;=== Staging Area에 삭제 파일 정보를 등록한다. &apos;rm&apos; 대신 &apos;add&apos;를 사용하여 삭제된 파일을 표시해도 된다. 예) git add test01.html$ git commit &lt;=== 저장소에서 Staging Area의 정보에 따라 1234예2) 변경한 파일이나 Staging Area에 이미 기록된 파일을 강제로 제거하기$ git rm -f test01.html &lt;=== 변경된 내용을 버리고 현재 스냅샷에서 빼버린다. &lt;=== 변경한 파일이 Staging Area에 기록되었더라도 변경된 내용을 버리고 스냅샷에서 빼버린다. git mv [기존파일명][새파일명] 파일 이름을 변경한다. 1234예1) test01.html 파일의 이름을 test02.html로 변경하기$ mv test01.html test02.html$ git rm test01.html$ git add test02.html 123예2) test01.html 파일의 이름을 test02.html로 변경하기 II 위 작업을 좀 더 쉽게 다음과 같이 단축으로 처리할 수 있다. $ git mv test01.html test02.html git log Git 저장소의 변경 내력을 조회한다. 1234567891011121314예1) 저장소의 변경 내력을 최신 커밋 순으로 출력하기$ git log...commit 80e779cf97f2b8857b1fd4e3796a612470255852 &lt;=== 커밋 체크섬Author: eomjinyoung &lt;jinyoung.eom@gmail.com&gt; &lt;=== 커밋한 사람의 이름과 이메일Date: Tue Aug 21 10:04:49 2018 +0900 &lt;=== 커밋한 날짜 ok &lt;=== 커밋할 때 입력한 내용commit d89524011f2c873fedca8643fa2cb95e02cb6656Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Tue Aug 21 09:35:48 2018 +0900 Initial commit 123456789101112131415161718192021예2) 저장소의 변경 내력을 최신 커밋 순서로 출력하는데 최근 두 개의 결과만 출력하기(-2 옵션) 각 커밋의 변경 내용을 보여주기(-p 옵션)$ git log -p -2commit cc898de0b9ea138f554aeb59910b348cb34850f4 (HEAD -&gt; master)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 19:55:21 2018 +0900 p 태그 추가diff --git a/src/main/webapp/ex03.html b/src/main/webapp/ex03.htmlindex 0afb588..c0e04ec 100644--- a/src/main/webapp/ex03.html+++ b/src/main/webapp/ex03.html@@ -5,5 +5,6 @@ &lt;/head&gt; &lt;body&gt; &lt;h1&gt;테스트&lt;/h1&gt;+&lt;p&gt;내용 추가&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;... 123456789101112예3) 저장소에 대한 각 커밋의 통계 정보를 조회한다.$ git log ---stat...commit c555b1b128453d18ac2a5d3493b79021dce3f470Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 19:54:50 2018 +0900 HTML 내용 변경 src/main/webapp/ex03.html | 6 ++++-- &lt;=== 어떤 파일의 추가되거나 삭제된 줄 수 1 file changed, 4 insertions(+), 2 deletions(-) &lt;=== 요약 정보... 12345678910111213141516171819예4) 추가되거나 삭제된 내용 중에 &apos;&lt;p&gt;&apos; 문구를 포함한 정보 조회$ git log -p -S &apos;&lt;p&gt;&apos;commit cc898de0b9ea138f554aeb59910b348cb34850f4 (HEAD -&gt; master)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 19:55:21 2018 +0900 p 태그 추가diff --git a/src/main/webapp/ex03.html b/src/main/webapp/ex03.htmlindex 0afb588..c0e04ec 100644--- a/src/main/webapp/ex03.html+++ b/src/main/webapp/ex03.html@@ -5,5 +5,6 @@ &lt;/head&gt; &lt;body&gt; &lt;h1&gt;테스트&lt;/h1&gt;+&lt;p&gt;내용 추가&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; git commit –amend 마지막 커밋을 다시 현재의 Staging Area의 내용으로 덮어쓴다. 그래서 커밋 완료 후 빠뜨린 파일이 있거나 제거하지 못한 파일이 있을 경우 사용한다. 마지막 커밋 후에 변경 사항이 없다면 단지 커밋 메시지만 변경한다. 이전 커밋을 덮어쓰는 것이지만 커밋의 체크섬은 새로 발급된다. 12345예1) ex03.html을 변경한 후 커밋한다. 그 후에 다시 ex04.html을 변경한 후 이전 커밋과 합친다. $ git add ex03.html$ git commit -m &apos;ex03 변경&apos;$ git add ex04.html$ git commit --amend -m &apos;ex03 및 ex04 변경&apos; git reset HEAD [파일] 커밋 버전을 취소하는 것 git add를 실행하면 Staging Area에 해당 파일이 기록되어 커밋할 스냅샷으로 묶인다. 스냅샷으로 묶인 파일들은 커밋할 때 저장소에 그 변경 내용이 보관된다. Staging Area의 현재 스냅샷에서 빼고 싶은 파일이 있다면 이 명령을 사용한다. 이 명령을 수행하면 변경된 상태이지만 아직 Staging Area의 현재 스냅샷에 포함되지 않은 파일이 된다. 123456예1) &apos;ex03.html&apos;과 &apos;ex04.html&apos; 파일을 변경한 후 Staging Area에 넣기$ git add ex03.html ex04.htmlStaging Area에 넣은 두 개 파일 중에서 ex03.html은 제외하기 $ git reset HEAD ex03.html git revert 직전 버전의 것만 제거할 때 1git revert head 그런데 직전 버전이 아닌 과거의 버전으로 돌리고자 할 때12&gt; git revert 커밋아이디&gt; 를 cmd에 치면 12345&gt; error: could not revert 커밋아이디... &apos;커밋메시지&apos;&gt; hint: after resolving the conflicts, mark the corrected paths&gt; hint: with &apos;git add &lt;paths&gt;&apos; or &apos;git rm &lt;paths&gt;&apos;&gt; hint: and commit the result with &apos;git commit&apos;&gt; 에러 발생하고, 파일을 열게 되면 12345678&gt; &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD&gt; 11111&gt; 33333&gt; 22222&gt; =======&gt; 11111&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; parent of c088056... &apos;22222&apos;&gt; head부터 내가 쓴 것, ======는 돌리려고 했던 것의 부모 git remote 현재 프로젝트에 등록된 원격 저장소를 확인하거나 추가한다. git clone [url]으로 원격 저장소를 복제하면 원격 저장소가 origin 이라는 이름으로 자동 등록된다. 서버를 가리키는 포인터 123예1) 원격 저장소의 이름을 알아내기$ git remoteorigin 1234예2) 원격 저장소의 이름 뿐만아니라 URL도 알아내기$ git remote -vorigin https://github.com/eomjinyoung/test.git (fetch)origin https://github.com/eomjinyoung/test.git (push) 1234567예3) 원격 저장소 추가하기$ git remote add [단축이름] [URL]$ git remote add cs https://github.com/eomcs/test.gitorigin https://github.com/eomjinyoung/test.git (fetch)origin https://github.com/eomjinyoung/test.git (push)cs https://github.com/eomcs/test.git (fetch)cs https://github.com/eomcs/test.git (push) 12345678910111213예4) 원격 저장소의 정보를 조회하기$ git remote show [원격 저장소 이름]$ git remote show origin* remote origin Fetch URL: https://github.com/eomjinyoung/test.git Push URL: https://github.com/eomjinyoung/test.git HEAD branch: master Remote branch: &lt;=== 로컬 저장소와 연결된 원격 저장소의 브랜치 master tracked Local branch configured for &apos;git pull&apos;: &lt;=== git pull 했을 때 merge 할 master merges with remote master 원격 저장소의 브랜치와 로컬 저장소의 브랜치 Local ref configured for &apos;git push&apos;: &lt;=== git push 했을 때 push 할 master pushes to master (up to date) 로컬 저장소의 브랜치와 원격 저장소의 브랜치 123456예5) 원격 저장소의 단축 이름을 변경하기$ git remote rename [현재 단축이름] [새 단축이름]$ git remote rename cs eomcs$ git remoteorigineomcs 12345678예6) 원격 저장소를 삭제하기 - 원격 저장소의 서버 정보가 변경되었을 때 - 별도의 복제가 필요하지 않을 때 - 기여자가 활동하지 않을 때 $ git remote rm [원격 저장소의 단축이름]$ git remote eomcs$ git remoteorigin git fetch [원격저장소이름] 로컬에는 없고 원격 저장소에만 있는 데이터를 모두 가져온다. 단 가져온 데이터를 로컬 파일에 자동으로 합치지는(merge) 않는다. 개발자가 직접 merge 해야 한다. 12예1) 원격 저장소에 마지막으로 push 한 다음에 변경된 모든 것을 가져오기$ git fetch origin git pull git pull = git fetch origin + Merge 즉 원격 저장소의 데이터를 가져온 후에 로컬 파일과 합친다. 원격 저장소를 clone 하게 되면 로컬 저장소에 master 브랜치가 생긴다. 로컬 저장소의 master 브랜치는 자동으로 원력 저장소의 master 브랜치를 추적한다. 따라서 원격 저장소에서 가져온 데이터를 로컬 저장소의 master 브랜치와 합쳐진다. 12예1) 원격 저장소의 파일을 가져와 로컬 저장소의 파일과 병합하기 $ git pull git push [원격 저장소 이름][로컬 브랜치 이름] 로컬 저장소 브랜치를 원격 저장소로 업로드(push) 한다. 전제 조건 원격 저장소에 쓰기 권한이 있어야 한다. 아직 다른 사람이 push 한 적이 없다. 다른 사람이 push 한 적이 있다면, 먼저 원격 저장소의 데이터를 가져와서 merge 한 다음에 push 해야 한다. 12예1) 로컬 저장소의 master 브랜치를 원격 저장소에 업로드 하기$ git push origin master git tag 존재하는 태그를 조회한다. 12345예1) 저장소에 존재하는 태그를 조회한다.$ git tagv0.1v0.2... 1234예2) 저장소에 있는 태그 중에서 v10.0 버전의 태그들만 검색하기$ git tag -l &apos;v10.0*&apos;v10.0.0.1v10.0.0.2 123456예3) 현재 저장소에 저장된 파일에 대해 태그 붙이기 - 마지막 커밋에 대해 태그를 붙인다. - 태그를 만든 사람의 이름과 이메일, 날짜, 메시지도 저장한다. - 이렇게 붙인 태그를 &apos;Annotated 태그&apos;라 부른다.$ git tag -a [태그명] -m &apos;태그 메시지&apos;$ git tag -a v0.1 -m &apos;my version 0.1&apos; 12345예4) 현재 저장소에 저장된 파일, 즉 마지막 커밋에 대해 태그 붙이기 - 태그에 대한 추가 정보를 입력하지 않는다. - 이렇게 붙인 태그를 Lightweight 태그&apos;라 부른다.$ git tag [태그명]$ git tag v0.2 1234567891011121314151617예5) 이전 커밋에 대해 태그 붙이기$ git tag -a [태그명] [커밋 체크섬]$ git log --pretty=oneline75ff5353c41f3a33de4a7da91887d0ecbc2cbca6 (HEAD -&gt; master, tag: v0.2) test..ok2e08e7f0c4a5d068dcc20148e7e7b007958bd3b05 (tag: v0.1, origin/master, origin/HEAD) test..ok7c239ac5c89bcca468cfd0f412bef104e25b071a okokbb4aad9f4c000851f950feefdca4874cfa830734 ex03 편집, ex04 편집5607c88f763a12557adb69442b054990a1487d4f ex03 편집d166310b5c4502fc820bbab960094911466745e4 ex03 편집, ex04 편집bfa6df7c89c245e750c7c59f3c6fb06dfa801a74 다시 커밋c555b1b128453d18ac2a5d3493b79021dce3f470 HTML 내용 변경...$ git tag -a v0.0.1 c555b1b1 -m &apos;my version 0.0.1&apos; &lt;=== 중복되지 않는다면, 체크섬의 앞쪽 일부 값만 지정해도 된다.$ git tagv0.0.1 &lt;=== 추가된 태그v0.1v0.2 12345678예6) 로컬 저장소에 있는 태그를 서버에 공유하기$ git push [원격저장소 단축이름] [태그 이름]$ git push origin v0.1Counting objects: 1, done.Writing objects: 100% (1/1), 166 bytes | 166.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0)To https://github.com/eomjinyoung/test.git * [new tag] v0.1 -&gt; v0.1 1234567891011예7) 원격 저장소에 없는 모든 로컬 저장소의 태그를 서버에 공유하기$ git push origin --tagsCounting objects: 7, done.Delta compression using up to 8 threads.Compressing objects: 100% (7/7), done.Writing objects: 100% (7/7), 658 bytes | 658.00 KiB/s, done.Total 7 (delta 3), reused 0 (delta 0)remote: Resolving deltas: 100% (3/3), completed with 3 local objects.To https://github.com/eomjinyoung/test.git * [new tag] v0.0.1 -&gt; v0.0.1 * [new tag] v0.2 -&gt; v0.2 git show [태그명] 태그 정보와 커밋 정보를 모두 확인한다. 1234567891011121314예1) 태그 v0.1의 정보와 커밋 정보를 확인하기$ git show v0.1tag v0.1Tagger: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt; &lt;=== 태그 붙인 사람 정보Date: Mon Aug 27 00:03:56 2018 +0900 &lt;=== 태그 붙인 날짜 my version 0.1 &lt;=== 태그 붙일 때 작성한 메시지commit e08e7f0c4a5d068dcc20148e7e7b007958bd3b05 (HEAD -&gt; master, tag: v0.1, origin/master, origin/HEAD)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Sun Aug 26 23:29:24 2018 +0900 test..ok... 12345678910예2) Lightweight 태그의 정보를 확인하기 - 태그를 저장할 때 메시지를 지정하지 않았으면 태그 정보가 출력되지 않는다.$ git show v0.2-lw &lt;=== 태그를 붙인 사람의 정보가 없다.commit 75ff5353c41f3a33de4a7da91887d0ecbc2cbca6 (HEAD -&gt; master, tag: v0.2)Author: Jinyoung Eom &lt;jinyoung.eom@gmail.com&gt;Date: Mon Aug 27 00:13:30 2018 +0900 test..ok2... git checkout -b [새브랜치명][태그명] 작업 디렉토리의 내용물을 특정 태그의 커밋 버전으로 바꾼다. 태그가 가리키는 커밋의 파일들을 가져오려면 브랜치를 생성해야 한다. 특정 태그가 붙은 커밋 버전으로 브랜치를 만들고 작업 디렉토리는 그 브랜치의 파일들로 바꾼다. 123예1) v0.1 태그가 붙은 커밋 파일들로 version2 라는 이름의 브랜치를 만들고 작업 디렉토리에 가져오기$ git checkout -b version2 v0.1Switched to a new branch &apos;version2&apos; &lt;=== 작업 디렉토리의 파일들이 변경된다. git config –global alias.별명 [원래명령어] 자주 사용하는 명령어에 대해 별명을 부여한다. 12345예1) status 명령과 status --short 대해 별명을 지정하기$ git config --global alias.st status$ git config --global alias.st2 &apos;status --short&apos;$ git st &lt;=== &apos;git status&apos; 와 같다.$ git st2 &lt;=== &apos;git status --short&apos; 와 같다. 12345예2) Git 별명을 이용하여 &apos;nano&apos; 편집기를 실행하기$ git config --global alias.별명 &apos;!실행파일명&apos;$ git config --global alias.nn &apos;!nano&apos;$ git nn [nano 편집기가 실행될 것이다.] $ git branch -vv b1 c2be10d [origin/b1] v1.3 b2 664dbb5 v3.1master 09fb339 [origin/master: ahead 2] v3.0 &lt;=== 로컬 브랜치가 커밋을 2개 앞서 있다는 의미other ed485e2 [origin/other] v1.2other2 ed485e2 [origin/other] v1.2 Git 브랜치 사용법커밋 정보Git에서 commit을 수행하면 다음의 절차에 따라 커밋 정보를 저장한다. git add 실행 Blob 생성 Git 저장소에 저장되는 파일이다. 각 파일은 SHA-1 해시 알고르즘으로 계산된 40바이트 크기의 고유의 체크섬(checksum) 값을 가진다. Staging Area에 Blob의 체크섬을 기록한다. git commit 실행 트리 객체 생성 디렉토리와 파일의 구조 정보가 들어 있다. 파일 정보는 Blob의 체크섬이다. 각 트리를 구분하기 위한 SHA-1 해시로 생성한 체크섬을 가진다. 커밋 객체 생성 작성자, 커미터, 커밋 메시지 등 메타 정보가 들어 있다. 트리 객체를 가리키는 정보가 들어 있다. 각 커밋을 식별하기 위한 SHA-1 해시로 생성한 체크섬을 가진다. 이전 커밋을 가리키기 위해 이전 커밋의 체크섬이 들어 있다. 이 모든 것들은 .git에 들어있다! 객체들 간의 관계 [커밋 객체]—-&gt; [트리 객체]—-&gt; [Blob 객체들] 브랜치 Git의 브랜치는 커밋 사이를 이동할 때 사용하는 포인터 같은 것이다. 커밋의 체크섬을 이용하여 여러 커밋들 중에서 한 커밋을 가리킨다. 즉 새 브랜치를 만드는 것은 단순히 41바이트(40바이트 체크섬 + 1바이트 줄 바꿈 문자)의 파일을 하나 만드는 것에 불과하다. 따라서 브랜치를 여러 개 만들어도 전혀 상관없다. Git은 브랜치를 만들어 작업하고 나중에 merge 하는 것을 권장한다. 하루에 수십 번씩 해도 괜찮다고 제안하고 있다. master 브랜치 git init를 통해 Git 저장소를 만들 때 ‘master’라는 이름으로 기본 브랜치를 생성한다. master 브랜치로 작업하는 동안에는 항상 가장 마지막 커밋을 가리킨다. HEAD 현재 작업 중인 로컬 브랜치(워킹 디렉토리)를 가리키는 특수한 포인터이다. 와일드 표시(*)가 붙는다. 토픽 브랜치 어떤 한가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치이다. 트래킹 브랜치 = upstream 브랜치 원격 브랜치를 체크아웃 하여 만든 로컬 브랜치이다. 트래킹 브랜치에서 git pull 을 실행하면 이 로컬 브랜치와 연결된 원격 브랜치에서 데이터를 받아 로컬 브랜치로 자동 merge 한다. 브랜치 명령git branch 브랜치를 관리한다. 12345678910예1) b1 이라는 이름으로 브랜치를 새로 만들기 git branch [새 브랜치 이름] - 새로 만든 브랜치도 지금 작업하고 있는 커밋을 가리킨다. - HEAD 포인터는 브랜치 생성과 상관없이 기존의 브랜치를 계속 가리킨다.$ git branch b1$ git log --oneline &lt;=== 커밋 정보를 한 줄 씩 출력한다.f559e21 (HEAD -&gt; master, b1) v0.35896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 123456예2) 브랜치 목록을 조회하기 git branch - 아무런 옵션 없이 실행하면 브랜치의 목록을 출력한다.$ git branch b1* master &lt;=== 현재 작업하는 브랜치에 * 가 붙는다. 12예3) 브랜치들 중에서 merge 한 브랜치를 조회하기$ git branch --merged 12예4) 브랜치들 중에서 merge 하지 않은 브랜치를 조회하기$ git branch --no-merged 1234567예5) 브랜치 삭제하기$ git branch -d b1 &lt;=== merge 되지 않은 브랜치는 삭제되지 않는다.error: The branch &apos;b1&apos; is not fully merged. If you are sure you want to delete it, run &apos;git branch -D b1&apos;.$ git branch -D b1 &lt;=== -D 옵션으로 merge 되지 않은 브랜치를 강제 삭제하라.Deleted branch b1 (was 519ee27). git checkout [브랜치 이름] HEAD 포인터가 다른 브랜치를 가리키게 한다. HEAD 포인터가 가리키는 브랜치가 바뀌면, 작업 디렉토리도 그 브랜치의 커밋 정보에 따라 바뀐다. 1234567예1) HEAD 포인터를 b1 브랜치로 옮긴다.$ git checkout b1$ git log --oneline &lt;=== 로그 정보를 확인해 보라.f559e21 (HEAD -&gt; b1, master) v0.3 &lt;=== HEAD는 b1을 가리키고 있다. 5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678910예2) test04.txt를 만들어 b1 브랜치에 추가하기 test04.txt 파일을 만들었다고 가정하자!$ git add test04.txt$ git commit -m &apos;v0.4&apos;$ git log --oneline9cf510e (HEAD -&gt; b1) v0.4 &lt;=== b1은 새로 커밋한 스냅샷을 가리킨다. HEAD는 현재 작업 브랜치인 b1을 가리킨다.f559e21 (master) v0.3 &lt;=== master가 가리키는 스냅샷은 변경되지 않는다. 5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 1234567891011예3) test05.txt를 만들어 b1 브랜치에 추가하기 test05.txt 파일을 만들었다고 가정하자!$ git add test05.txt$ git commit -m &apos;v0.5&apos;$ git log --oneline34fda9c (HEAD -&gt; b1) v0.5 &lt;=== b1은 새로 커밋한 스냅샷을 가리킨다. HEAD는 현재 작업 브랜치인 b1을 가리킨다.9cf510e v0.4 f559e21 (master) v0.3 &lt;=== master가 가리키는 스냅샷은 변경되지 않는다. 5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678예4) 작업할 브랜치를 b1에서 다시 master로 교체하기 브랜치를 교체한 후 작업 디렉토리를 확인해 보면, 다시 master가 가리키는 스냅샷으로 돌아 온 것을 확인할 수 있다.$ git checkout master$ git log --onelinef559e21 (HEAD -&gt; master) v0.3 &lt;=== 전체 스냅샷 중에서 master 브랜치와 연결된 스냅샷만 화면에 출력된다.5896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678910예5) test06.txt를 만들어 master 브랜치에 추가하고 커밋 내력 확인하기 test06.txt 파일을 만들었다고 가정하자!$ git add test06.txt$ git commit -m &apos;v0.6&apos;$ git log --oneline6f4725e (HEAD -&gt; master) v0.6f559e21 v0.35896279 v0.28dd76bf v0.15d8d97b (origin/master, origin/HEAD) Initial commit 12345678910예6) 현재 HEAD가 가리키는 브랜치의 역사 뿐만 아니라 다른 브랜치의 역사까지 출력하기$ git log --oneline --graph --all* 6f4725e (HEAD -&gt; master) v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit 123456789101112예7) 체크아웃 할 때 자동으로 새 브랜치를 만들기 &apos;git branch&apos; + &apos;git checkout&apos; = git checkout -b [새 브랜치 이름] $ git checkout -b b2$ git log --oneline --all --graph* 6f4725e (HEAD -&gt; b2, master) v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit 12345678910111213예8) 새로 만든 b2 브랜치에 test07.txt 파일을 추가하고 커밋하기$ git add test07.txt$ git commit -m &apos;v0.7&apos;$ git log --oneline --all --graph* 33c8c8d (HEAD -&gt; b2) v0.7* 6f4725e (master) v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit git merge [브랜치 이름] 현재 브랜치의 커밋에 다른 브랜치의 커밋 내용을 합친다. 123456789101112131415예1) 합치려는 브랜치가 현 브랜치 보다 Upstream(이후 버전)일 경우, 별도의 merge 과정이 필요없고, 해당 브랜치의 최신 버전의 커밋으로 이동한다. 이런 merge 방식을 &apos;fast forward&apos;라 부른다.$ git checkout master$ git merge b2$ git log --oneline --all --graph* 33c8c8d (HEAD -&gt; master, b2) v0.7 &lt;=== master가 b2가 가리키는 커밋으로 이동한다.* 6f4725e v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit 12345678910111213예2) 더 이상 필요없는 b2 브랜치를 삭제하기$ git branch -d b2$ git log --oneline --all --graph* 33c8c8d (HEAD -&gt; master) v0.7* 6f4725e v0.6| * 34fda9c (b1) v0.5| * 9cf510e v0.4|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit[~/git/git-test]$ 123456789101112131415161718192021222324252627282930예3) master 브랜치에 b1 브랜치 커밋 내용을 합치기$ git checkout master &lt;=== 현재 브랜치가 master가 아니라면 이 명령을 수행한다.$ git merge b1$ git log --oneline --all --graph* 58489d3 (HEAD -&gt; master) v0.8 &lt;=== master 브랜치에 b1 브랜치를 합친 새 커밋이 생성된다.|\\ | * 34fda9c (b1) v0.5| * 9cf510e v0.4* | 33c8c8d v0.7* | 6f4725e v0.6|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit더 이상 필요없는 b1 브랜치를 삭제하기$ git branch -d b1[~/git/git-test]$ git log --oneline --all --graph* 58489d3 (HEAD -&gt; master) v0.8|\\ | * 34fda9c v0.5| * 9cf510e v0.4* | 33c8c8d v0.7* | 6f4725e v0.6|/ * f559e21 v0.3* 5896279 v0.2* 8dd76bf v0.1* 5d8d97b (origin/master, origin/HEAD) Initial commit git rebase [브랜치명] 지정한 브랜치에 현재 브랜치의 변경 내력을 순서대로 합친다. 작업 원리 두 브랜치가 갈라지기 전인 공통 커밋으로 이동한다. 공통 커밋 부터 현재 브랜치까지의 diff(변경 사항)를 차례로 만들어 임시 보관해 둔다. 현재 브랜치가 지정한 브랜치를 가리키게 한다. 임시 보관된 diff(변경 사항)을 차례로 적용한다. 특징 merge 보다 좀 더 깔끔한 history를 만든다. history가 선형이다. 모든 작업이 순서대로 진행된 것 처럼 보인다. 보통 원격 브랜치에 커밋을 깔금하게 적용하고 싶을 때 사용한다. rebase 브랜치의 변경 사항을 다른 브랜치에 순서대로 적용하면서 합친다. merge는 두 브랜치의 최종 결과만을 가지고 합친다. merge vs rebase 로컬 저장소에서 브랜치를 정리할 때 rebase를 사용한다. push로 공개한 커밋에 대해서는 rebase를 하지 말라! 되도록 merge를 사용하여 역사를 기록하고 후세에 남겨 교훈이 되게 하라. 12345678910111213141516171819202122232425262728293031323334353637383940414243예1) b1 브랜치를 master 브랜치에 합치기 현재 브랜치 내력을 조회한다.$ git log --oneline --graph --all* f9e2727 (HEAD -&gt; master) C1b1 브랜치를 만든다.$ git branch b1$ git log --oneline --graph --all* f9e2727 (HEAD -&gt; b1, master) C1파일을 변경한 후 커밋한다.$ git add .$ git commit -m &apos;C2&apos;$ git log --oneline --graph --all* 0ebbfb2 (HEAD -&gt; b1) C2* f9e2727 (master) C1master 브랜치로 옮긴 후 파일을 변경한 후 커밋한다.$ git checkout master$ git add .$ git commit -m &apos;C3&apos;$ git log --oneline --graph --all* 1df28eb (HEAD -&gt; master) C3| * 0ebbfb2 (b1) C2|/ * f9e2727 C1b1 브랜치로 옮긴 후 master 브랜치를 b1 브랜치쪽으로 rebase 한다.$ git checkout b1$ git rebase master$ git log --oneline --graph --all* 211448b (HEAD -&gt; b1) C2* 1df28eb (master) C3* f9e2727 C1master를 &apos;fast-forward&apos;로 merge 한다.$ git checkout master$ git merge b1$ git log --oneline --graph --all* 211448b (HEAD -&gt; master, b1) C2* 1df28eb C3* f9e2727 C1 1234567891011121314151617181920212223242526272829브랜치 history가 다음과 같다면,C1 --- C2 --- C3 master \\ C4 --- C5 --- C6 b1 \\ C7 --- C8 --- C9 b2예2) b2 브랜치를 master 브랜치와 연결하기 git rebase -onto [기준브랜치] [토픽 브랜치1] [토픽 브랜치2] - &apos;-onto&apos; 옵션을 사용하면 b2 브랜치로 체크아웃 할 필요없다. - &apos;토픽 브랜치1&apos;과 &apos;토픽 브랜치2&apos;의 공통 커밋 이후부터 &apos;토픽 브랜치2&apos;까지의 모든 변경 사항을 patch로 만들어서 &apos;기준 브랜치&apos;에 적용한다.$ git rebase -onto master b1 b2위 명령을 수행한 후 브랜치의 historyC1 --- C2 --- C3 master \\ \\ \\ C7&apos; --- C8&apos; --- C9&apos; b2 \\ C4 --- C5 --- C6 b1b2를 master에 합쳤으면 master에 대해 &apos;fast-forward&apos;를 수행한다.$ git checkout master$ git merge b2위 명령을 수행한 후 브랜치의 historyC1 --- C2 --- C3 --- C7&apos; --- C8&apos; --- C9&apos; master, b2 \\ C4 --- C5 --- C6 b1 123456789101112131415161718예3) 위의 상황에서 b1 브랜치를 master에 합치기 git rebase [기준 브랜치] [토픽 브랜치]$ git rebase master b1위 명령을 수행한 후 브랜치의 historyC1 --- C2 --- C3 --- C7&apos; --- C8&apos; --- C9&apos; --- C4&apos; --- C5&apos; --- C6&apos; | | master, b2 b1b1을 master에 합쳤으면 master에 대해 &apos;fast-forward&apos;를 수행한다.$ git checkout master$ git merge b1$ git branch -d b1 &lt;=== 필요없는 b1 브랜치 삭제$ git branch -d b2 &lt;=== 필요없는 b2 브랜치 삭제C1 --- C2 --- C3 --- C7&apos; --- C8&apos; --- C9&apos; --- C4&apos; --- C5&apos; --- C6&apos; | master 원격 브랜치 원격 브랜치는 원격 저장소에 있는 브랜치를 가리키는 레퍼런스(포인터) 이다. 원격 브랜치를 가리키는 형식 (remote)/(branch) 예) origin/master ‘git clone’ 명령을 수행하면 원격 저장소를 가리키는 이름으로 ‘origin’이 자동 부여된다. git clone -o [원격저장소이름] ‘-o’ 옵션을 이용하여 원격 저장소 이름을 지정하면 ‘origin’ 대신 지정한 이름이 부여된다. 1234예1) 원격 저장소의 이름을 &apos;orgin&apos; 대신 &apos;ohora&apos;라 짓기$ git clone -o ohora https://github.com/eomjinyoung/git-test$ git remoteohora git ls-remote 원격 레퍼런스(Refs)를 조회한다. 12345678910예1) 원격 저장소의 레퍼런스를 모두 출력하기 git ls-remote [원격 저장소 이름]$ git ls-remote &lt;=== 원격 저장소 이름을 생략하면 전체 출력From https://github.com/eomjinyoung/git-test.git9babde9de3ff3f9c979a8da0c9d65e008a13af31 HEAD9babde9de3ff3f9c979a8da0c9d65e008a13af31 refs/heads/master$ git ls-remote origin &lt;=== origin에 대한 것만 출력9babde9de3ff3f9c979a8da0c9d65e008a13af31 HEAD9babde9de3ff3f9c979a8da0c9d65e008a13af31 refs/heads/master git remote show [원격 저장소 이름] 원격 저장소에 대한 모든 브랜치와 정보를 조회한다. 12345678910111213예1) 원격 저장소의 브랜치 정보를 출력하기 git remote show [원격 저장소 이름]$ git remote show origin* remote origin Fetch URL: https://github.com/eomjinyoung/git-test.git Push URL: https://github.com/eomjinyoung/git-test.git HEAD branch: master Remote branch: master tracked Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (local out of date) git fetch [원격 저장소 이름] 원격 저장소가 로컬 저장소에 없는 정보를 가지고 있다면 모두 가져온다. 그리고 origin/master 포인터를 최신 커밋으로 이동시킨다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556현재 로컬 저장소의 브랜치 및 커밋 역사가 다음과 같다고 가정하자.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- X1 --- X2 | | origin/master master현재 원격 저장소의 브랜치 및 커밋 역사가 다음과 같다고 가정하자.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- Y1 --- Y2 | master예1) 원격 저장소의 내용을 로컬 저장소로 가져온다.$ git fetch origin$ git log --oneline --graph --all* 9babde9 (origin/master, origin/HEAD) Y2* 440c0c1 Y1| * 82efd10 (HEAD -&gt; master) X2| * 4039833 X1|/ * b4dec77 C6* 66d6384 C5* 401d39d C4* 4859dd1 C3* 241b657 C2* 046ea07 C1즉 다음 그래프와 같이 커밋이 구성된다.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- X1 --- X2 \\ | \\ HEAD -&gt; master Y1 --- Y2 | origin/master예2) 원격에서 가져온 정보를 로컬 저장소에 merge하기 $ git merge 9babde9$ git log --oneline --graph --all* f5d2046 (HEAD -&gt; master) X3|\\ | * 9babde9 (origin/master, origin/HEAD) Y2| * 440c0c1 Y1* | 82efd10 X2* | 4039833 X1|/ * b4dec77 C6* 66d6384 C5* 401d39d C4* 4859dd1 C3* 241b657 C2* 046ea07 C1즉 다음 그래프와 같이 커밋이 구성된다.C1 --- C2 --- C3 --- C4 --- C5 --- C6 --- X1 --- X2 --- X3 HEAD -&gt; master \\ / --- Y1 --- Y2 --- | origin/master 1234예3) 원격 저장소의 정보를 가져와서 로컬 저장소와 합치기 git pull = git fetch + get merge - &apos;git pull&apos; 명령을 사용하면 더 간단히 처리할 수 있다.$ git pull 12예4) 모든 원격 저장소에서 데이터를 받아오기$ git fetch --all git push 로컬 저장소의 정보를 원격 저장소에 올린다. 로컬에서 생성한 브랜치를 원격 저장소에 올릴 수 있다. 원격 저장소의 브랜치를 삭제할 수 있다. 1234567891011예1) push를 사용하여 로컬 저장소의 정보를 원격 저장소에 올리기$ git push &lt;=== master를 origin/master로 올린다.$ git log --oneline --graph --all* f5d2046 (HEAD -&gt; master, origin/master, origin/HEAD) X3|\\ | * 9babde9 Y2| * 440c0c1 Y1* | 82efd10 X2* | 4039833 X1|/ * b4dec77 C6 12345예2) 로컬 저장소에 있는 &apos;b1&apos; 브랜치를 원격 저장소에 올리기 git push [원격 저장소 이름] [로컬 브랜치 이름] - 로컬 브랜치 이름과 같은 원격 브랜치가 없으면 새로 만든다. - 로컬 브랜치 정보를 원격 브랜치에 올린다.$ git push origin b1 1234예3) 로컬 저장소에 있는 &apos;b1&apos; 브랜치를 원격 저장소의 &apos;other&apos; 브랜치로 올리기 git push [원격 저장소 이름] [로컬 브랜치 이름]:[원격 브랜치 이름] - 로컬 브랜치 이름과 원격 브랜치 이름을 다를 때 유용하다.$ git push origin b1:other 123예3) 원격 저장소의 &apos;b1&apos; 브랜치를 삭제하기 git push [원격 저장소 이름] --delete [브랜치 이름]$ git push origin --delete b1 git checkout -b [로컬 브랜치][원격 저장소]/[원격 브랜치] 원격 저장소의 브랜치를 받아서 로컬 브랜치를 만든다. 1234예1) 원격 저장소의 origin/other 브랜치를 체그아웃 하여 other2 로컬 브랜치 만들기$ git checkout -b other2 origin/otherBranch &apos;other2&apos; set up to track remote branch &apos;other&apos; from &apos;origin&apos;.Switched to a new branch &apos;other2&apos; 123예2) 원격 저장소의 origin/other 브랜치를 체크아웃 하여 같은 이름으로 로컬 브랜치 만들기 - 같은 이름으로 만들 때는 --track 옵션을 사용한다.$ git checkout --track origin/other git branch -vv 트래킹 브랜치의 설정 정보를 조회한다. 출력 결과 ahead n : 로컬 브랜치가 커밋을 n 개 앞서 있다. 즉 로컬 브랜치에 커밋이 2개 더 있다는 의미. behind n : 원격 브랜치에서 로컬 브랜치로 merge 하지 않은 커밋이 n 개 있다는 의미. 123456$ git branch -vv b1 c2be10d [origin/b1] v1.3* b2 664dbb5 v3.1 master 09fb339 [origin/master: ahead 2] v3.0 &lt;=== 로컬 브랜치가 커밋을 2개 앞서 있다는 의미 other ed485e2 [origin/other] v1.2 other2 ed485e2 [origin/other] v1.2","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"설치한 것들, 설정 정리","slug":"181127","date":"2018-11-27T01:40:18.000Z","updated":"2018-12-07T05:37:43.435Z","comments":true,"path":"2018/11/27/181127/","link":"","permalink":"http://eunajjing.github.io/2018/11/27/181127/","excerpt":"","text":"web App는 was에서 실행됨 was의 종류 tomcat jboss webLogic webSphere JEUS(관공서 시스템의 대부분이 돌아감) was는 java를 기반으로 만들어졌기에 jvm이 필요함 때문에 open JDK(JRE가 포함되어 있음)를 설치 자바 EE라는 기술 명세가 있는데 이에 맞춰 구현될 수 있도록 하는 게 Java EE Implement라는 구현체 타 was와 달리 톰캣은 java EE와 관련된 기술 중 서블릿, jsp, jstl, el 등 웹 관련한 것만 지원 즉 서블릿, jsp는 모든 was에서 돌아가지만 ejb는 톰캣에서 돌아가지 않는다. 만약 ejb를 처리할 일이 있다면 스프링 프레임워크를 사용해 pojo로 처리하면 된다. html, css, java script를 기본으로 제이쿼리, 부트스트랩, 앵귤러, 뷰, 리액트, 엠버 등 응용 라이브러리 이용 응용 라이브러리를 쉽게 다운 받기 위해서 npm 이용 때문에 node 사용(npm을 이용해 라이브러리를 관리) 기술 서블릿 jsp sql jdbc - 대용으로 orl 사용 jstl, el 스프링 프레임워크 - IOC 컨테이너, 웹 mvc, aop 라이브러리 관리를 위한 Gradle 사용 마리아 db 이용 git IDE는 이클립스 사용 비주얼 스튜디오 코드 사용 패키지 매니저 역할로 scoop 사용 설치open jdk설치 경로-11버전- 설정 java_home 환경 변수 설정 시스템 설정 - 고급 시스템 설정 - 시스템 속성 - 환경변수로 java_home 생성 - JDK까지만 경로 알려주기 path 환경 변수 설정PATH 경로 맨 앞에 bin까지의 경로 복사, 세미콜론이나 콜론 찍어주기 설정 확인cmd에서 12345echo %java_home%// 결과로 jdk 경로가 출력되어야 정상javac -versionjava -version// 결과로 버전이 출력되어야 정상 비주얼 스튜디오 코드설치 경로 git client설치 경로, cmd 설정 확인cmd 창에서 12git --version// 버전이 뜨면 정상 이클립스공식 홈페이지에서 인스톨러를 다운 받고, update 진행 설정 워크스페이스 디렉토리 선택 preferences - General - Workspace - Text file endcodeing을 utf-8로 설정 preferences - General - Editors - Text Editors에서 tab width를 2로 하고tabs 대신 스페이스를 넣게끔 설정show print margin 선택-칼럼은 100show whitespace characters 체크show line numbers 체크(기본으로 체크되어 있음) java 11 버전을 지원하는 플러그인을 설치 (이클립스 마켓플레이스 이용)java - installed JREs에서 확인할 수 있음 JAVA - Code Style - Formatter에서 구글 스타일 xml import구글의 코드 스타일 가이드 java - compiler에서 level을 맞춰준다 web에서 css, html, jsp 인코딩을 utf-8로 맞춰준다 자바는 모든 것을 2byte-utf-8이 아닌 그의 원형인 유니코드를 쓴다-로 저장하므로, 외부로 내보낼 땐 utf-8-3byte-로 매번 변환시키는 작업이 필요하다. 톰캣공식홈페이지에서 다운로드 preferences - server - runtime Environment에서 다운로드 받은 톰캣 add Scoop 패키지 관리자 설치맥의 경우 homebrew scoop을 이용하기 위해서는 파워쉘이 일정 버전 이상(3 이상)이어야 하기에 윈도우 파워쉘(Windows PowrShell)의 버전을 확인​ 1Get-Host | Select-Object Version 파워쉘 업데이트 1scoop install curl net framework 배우다가 스쿱 다운로드 실패로 중단 gradle빌드 도구가 하는 역할 compile test (report도 만든다) 아카이브 (.jar, .war, .zip) deployment 기존에 많이 쓰던 ant의 경우 build.xml에 빌드 정보 설정 외부 라이브러리 자동 다운로드를 위해 메이븐 등장 build.xml이 pom.xml가 된다. 빌드 명령을 정교하게 작성하고 싶어짐 스크립트 언어로 자바 호환 언어인 groovy 이용 그레이드 등장, 그레이드의 경우 build.gradle에 빌드 정보 설정 그레이드는 메이븐과 호환이 된다. 그레이드 공홈에서 binary-only를 다운로드 환경변수 설정 필요 path 맨 앞에 bin까지의 경로 넣어주고, 세미콜론 찍으며 확인 cmd에서 확인 가능 12gradle --version// 버전이 제대로 떠야 정상 마리아 db공홈에서 다운로드 default instance properties 설정 시 utf-8로 설정해줘야 함 서비스에서 mysql에 maria db가 있는지 확인하고, 상태가 시작됨인지 확인 마리아 db bin 경로를 path 환경변수에 설정 cmd에서 확인 123456mysql -u root -p// 패스워드 입력하는 창 나오고, 입력하면// welcom 마리아 db 문구가 나오며 maria db 명령이 실행 준비됨show databases;// 가지고 있는 database를 보여준다 깃허브에 repo 준비 원격에 repo를 만든 뒤 로컬에 클론을 한다. 1git clone ~url~ 새로운 프로젝트를 만든다. 12gradle init --type java-application// 강의는 groovy로 진행되기에 1, junit을 쓸 예정이므로 1 입력함 ​ jsp를 만들 때 &lt;% %&gt; 사이에 자바를 넣듯, 특정 영역에 집어넣는 언어를 dsl(Domain-specific language)이라 한다. 완성된 폴더에는 샘플 소스도 들어가 있다. 1gradle build 컴파일을 자동으로 실행하며, 필요한 라이브러리를 알아서 다운로드한다. build라는 폴더가 생성된다. 1gradle run 왜인지 내가 했더니 에러가 났다… 그래서 다시 지우고 하니까 또 된다. 왜 에러가 났을까? 이클립스에서는 제대로 된 폴더 구조를 보여주지 않는다. 이를 해결하기 위해 이클립스에선 window에서 show view - navigator로 확인한다. 프로젝트는 그레이드로 만든다! 이후에 import를 이용해 existing projects into workspace로 불러온다. 이 때 파일은 옮겨지는 게 아니라, 그대로 있고 이클립스에서 만질 수 있도록만 만드는 것 이클립스의 파일들 .settings .classpath .project 이것들이 없으면 project를 찾을 수 없다고 뜬다. 때문에 그레이드에 자동으로 생성할 수 있는 기능을 이용한다. build.gradle ​ 1234567891011121314151617plugins &#123; id 'java' id 'application' id 'eclipse' // 이클립스가 읽을 수 있도록 플러그인을 장착 &#125;repositories &#123; jcenter() &#125;dependencies &#123; implementation 'com.google.guava:guava:26.0-jre' testImplementation 'junit:junit:4.12' &#125;mainClassName = 'bitcamp.newdeal.lms.App' 이후에 cmd에서 명령어 실행 12gradle eclipse// 이클립스 설정 파일을 만들기 시작 저장/변경/삭제 명단을 작성(stageing-area에 올린다)명단에 작성할 것이 있는가 12git add .// git 폴더의 하위 모든 요소를 검사해 스테이지에 올린다 로컬 저장소에 저장(snapshot)이 순간 로컬의 .git에 저장된다.저장하는 행위를 커밋이라 한다.​ 1git commit -m &quot;커밋 메시지&quot; 서버에 업로드, 푸시​ 1git push 깃허브 임시 비밀번호 만들기settings - Developer settings - personal access tokens에서 New personal access token 생성 후 보이는 토큰을 잘 보관하기 마치며오늘 만든 프로젝트(?)","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"뉴딜과정","slug":"개발공부/뉴딜과정","permalink":"http://eunajjing.github.io/categories/개발공부/뉴딜과정/"}],"tags":[]},{"title":"hexo 블로그 404 에러 트러블슈팅","slug":"hexo_404_error","date":"2018-11-26T08:02:19.000Z","updated":"2018-12-07T09:48:31.210Z","comments":true,"path":"2018/11/26/hexo_404_error/","link":"","permalink":"http://eunajjing.github.io/2018/11/26/hexo_404_error/","excerpt":"","text":"매번 겪을 때마다 대환장해서 트러블 슈팅을 적기로 했다404의 서막hexo 블로그를 포스팅할 때마다, 어떤 포스팅은 제대로 잘 올라가는데 어떤 포스팅은 왜인지 에러가 났다. 내가 겪은 문제는 헥소 서버 상에서는 제대로 나오는데, 실 서버에서는 자꾸 404가 뜨는 경우였다. 그러니까 index까지는 제대로 나오는데, 해당 포스팅을 클릭하면 404가 뜬다. url로 들어가는 파라미터가 뭔가 이상하다고 생각해서, url을 뒤졌지만 무슨 일인지 알 수가 없었고. 재미있는 점은 직접 url을 타이핑해서 들어가면 제대로 페이지가 뜬다. 이게 무슨 일이야 왜 그런지 몰라서 매번 구글링을 하다가, 결국 어떤 이의 조언대로 마크다운 문서의 파일명을 바꾸는 식으로 문제를 해결해왔다. 참고했던 깃 이슈 하지만 인간은 망각의 동물이고, 나는 그 중에서도 망각에 두드러진 재능이 있는 이기 때문에 혹시 몰라 기록을 해둔다…. 저 이슈에 따르면 이 문제가 hexo의 문제가 아니라 github의 문제인 것 같다고 했다. 이미지 넣기이번 포스팅을 하다가, 실 서버에 올라온 이미지가 아니라 내가 가지고 있는 이미지를 블로그에 올리기 위해서 어떻게 해야하는지를 검색하게 되었고, 이것 또한 내가 잊을 게 뻔하기 때문에 함께 포스팅한다. 참고한 포스팅은 hexo 한국 공식 홈페이지","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"국비 교육 과정 수료 후기","slug":"Education_review","date":"2018-11-26T07:18:18.000Z","updated":"2018-11-27T13:31:55.138Z","comments":true,"path":"2018/11/26/Education_review/","link":"","permalink":"http://eunajjing.github.io/2018/11/26/Education_review/","excerpt":"","text":"개발 관련 국비 교육 과정 수료 후기교육 과정을 듣게 된 경위읽기 귀찮으시면 아래 요약있어요 대학을 졸업한 뒤, 나는 1년여 정도를 방송국에서 작가 업무를 했다. 프로그램은 시사였다. 소문대로 방송국 근무 환경은 좋지 않았고, 그 중 내가 속한 프로그램은 해당 방송국에서 절대 꺼지지 않는 3대 등불로 꼽히던 곳이었다. 힘들지 않았다면 거짓말이겠지만 재미가 있어 버틸 수 있던 시간이었다. 내가 업무 중에서 가장 좋아했던 특성은, 새로운 회차를 만들 적마다 매번 새로운 지식을 배워야 하는 점이었다. 프로그램을 만들고자 하는 주제와-흔히 방송 은어로 ‘야마’라고 했다-이를 뒷받침할 수 있는 근거들, 프로그램의 주제를 정면으로 반박 당할 수 있는 논리와 이에 대한 대응 지식에 대해. 제작진인 나는 매번 관련 서적을 읽고, 논문을 읽고, 전문가들의 의견을 구할 수 있는 입장에 있었다. 학창시절을 돌이켜보면 나는 학구열이 높았지만, 무언가 하나를 지속적으로 진행하는 끈기는 약한 학생이었다. 그런 점에서 방송은 최적의 공부 환경이었다. 해당 회차를 털고 나면 그 회차 주제와 관련이 있어 공부하던 것들을 버리고, 다음에 나올 방송과 연계된 새로운 공부를 할 수 있었으니까. 그래서 방송국에서 1년을 버틸 수 있었다. 결과적으로 현재 방송 업무를 하지 않지만, 내가 직업군에서 무엇을 중요시 여기는지. 나 자신을 알 수 있던 시간들이었다. 이런 경험 때문에 나는 다음에 지원할 직군도 늘 배우는 환경이길 바랐다. 내가 처음 만든 방송 주제에 대해 기억한다. 나는 ‘21세기의 인재상’과 관련한 방송에 대해 프로그램을 만들었는데, 떠오르는 산업인 4차 산업과 관련된 직군에 대해 많이 들여다볼 수 있던 시간이었다. 취재원 중 한 명은 흥미로운 역사를 지닌 이였다. 그는 군대에 있을 적, 갑작스럽게 어떤 아이디어를 떠올렸고 이를 구체적으로 발달시켜 사업을 시작하게 되었다. 전역 후, 그는 그 구체화된 것을 구현하기 위해 학교에서 개발을 배웠다. 방송에 나오는 이가 대부분 그렇듯, 시간이 흘러 그는 그 아이디어로 사업을 시작해 현재 시점서는 성공했다. 인터뷰할 당시에는 그냥 재미있는 이라고 여겼지만 방송국에서 퇴사를 하고 난 뒤 그가 부러웠다. 특정한 아이디어, 혹은 무언갈 만들겠다는 계획이 있다면 이를 직접 만들 수 있는 능력을 가지고 싶었다. 그래서 국비 교육 과정으로 개발을 배우게 되었다. 사실 이를 시작할 땐 취업을 하기 위해, 좋은 개발자가 되기 위해, 같이 특정한 목표는 없었다. 그냥 개발을 좀 배워보고 싶었고, 배울 수 있는 루트를 알아보다보니 고용노동부가 특정한 사업들을 통해 취업준비생들에게 교육에 관한 재정적 지원을 해준다는 걸 알게 되어 신청했을 뿐이었다. 취업을 하게 되면 좋은 것이지만, 결국 나와 맞지 않아 중도 포기하거나 취업을 못하게 된다고 해도 어쩔 수 없다는 마음가짐이었다. 지금 돌이켜보면 약간 무모하기도 했다. 또래들은 취업 전선에 허덕이고 있는데, 그저 배우고 싶다는 이유로 취업과 관계 없을 수도 있는 걸 6개월 동안 수강하다니. 6개월이 지난 지금, 어제 나는 최종적으로 해당 교육과정을 수료했다. 즐겁고 힘들고 과거의 나를 한 대 패고 싶던 시간이기도 했지만 후회하진 않는다. 이에 대해 기록해보고자 한다. 요약 사회생활 중 어떤 사람을 만나 개발을 배우고 싶어짐 근데 비전공자에 개발 1도 모름(그런데 정보처리기사 필기는 공부를 한 상태-퇴사한 뒤 바로 국비 지원을 신청할 수 있는 상황이 아니었기에, 그 기간 동안 뭘 해볼까 하다가 많은 이들이 개발 첫 걸음으로 정보처리기사 공부를 추천하기에 공부를 했다.-) 이클립스 툴(코딩 툴)을 이용해본 적 있음(어쩌다가 코딩 일일클래스? 같은 걸 듣게 되었는데 거기서 만져봄) 간단한 별찍기 알고리즘은 이해할 수 있었다.(마찬가지로 일일 클래스에서 배웠고 이해는 할 수 있지만 짤 수 있진 않았다) 2번의 정처기 공부 경험과 3번의 이클립스 툴 경험, 4번의 알고리즘 이해 부분을 보고 ‘뭐지 얘는?’ 싶은 분들도 있겠지만(특히 나처럼 1도 모르는 상태로 시작하려는 사람들에게)개발의 맛을 좀 보신 분들은 아시죠, 2, 3, 4가 개발에 대한 지식이 있는 상태라는 말은 아니라는 거… 취업 욕심이 그리 급하지 않아 안일한 상태로 시작 ##교육 기관 알아보기 다들 알겠지만 국비 교육 과정은 HRD-Net 에서 볼 수 있다. 본 사람이라면 알겠지만 개발 관련 교육 기관은 너무나 많고, 교육도 세부적으로 많이 갈린다. 흔히 개발을 백과 프론트로 많이 나누어서 말을 하시는 것 같은데 신청할 당시 나는 뭘 하고 싶다, 이런 것도 없었다. -근데 굳이 뭐 하나를 지향해서 교육과정을 듣는 게 의미가 있었을까 이런 생각도 든다. 그냥 시기나 장소 잘 맞는 교육과정 하나 열심히 듣고, 나중에 안 배운 지식이 필요하거든 그 때 따로 배우면 되지 않나…? 이것도 내가 너무 안일한가- 그런데 한 가지 분명히 하고 싶었던 게 있다면 모바일을 너무 배우고 싶었다. 그런데 모바일 관련해서도 알려준다는 교육 기관이 너무 많았고, 교육 기관 내 교육 과정도 수가 너무 많아서 어떤 게 좋을지 감이 잘 오지 않았다. 주변에 조언을 여쭈니, 국비 교육 과정을 들은 언니는 우선 순위를 정했다고 했다. 학원이 얼마나 집에서 가까운지(이 언니는 집이 무척 멀었다) 교육 시작일이 언제인지(취준생 입장에서는 빨리 시작해서 빨리 배우고 취업을 하고 싶으니까) 나도 이런 우선 순위를 세워보기로 했다. 하지만 우선 순위에 둘 항목조차 무얼 할지 결정하지 못해서, 구글을 통해 국비 교육 과정 후기라던지, 같은 고민을 하시는 분들의 글을 엄청 찾아 읽었다. 그러다가 개발자 커뮤니티 사이트 내에서 국비 교육 과정 수강생들에 대한 안좋은 이야기도 많이 봤고, 현업하시는 분들 입장에서는 그러실 수도 있겠다 싶어서. 교육 과정 이후에 개발 업무로 근무하게 된다면 계속 공부하는 이가 되어야겠다는 다짐도 했다. 구글링을 하다보니 이야기가 많이 나오는 학원들이 있었다. 블랙리스트급으로 여긴 가지 마세요, 하는 학원도 있었고-심지어 다양한 사이트에서 비추글이 있는 것도 있었다-나는 여기 들었는데 괜찮더라, 이런 학원도 있었다. 일단 괜찮다는 학원들을 리스트업해서 어떤 교육 과정을 신청할 수 있는지를 알아보고, 점차 우선 순위를 정할 수 있었다. 구글링 결과 괜찮은 학원이더라, 라는 평이 있는지 (아래에서 이야기하겠지만 hrd-net의 후기는 별로 믿을만하지 못한 것 같다.) 내가 배우고 싶은 모바일 과정이 있는지 교육 기관이 서울에 있는지 괜찮다는 강사가 진행하는지 비전공자의 비율이 많은지(나는 많길 바랐다) 취업률 사실 교육 기관의 위치는 집에서 가까우면 가까울수록 좋다. 그러나 위의 우선 순위에 모두 해당하는 기관은 모두 한 지역에 집중되어 있었다. 그래서 집에서 가까운지 여부도 중요하지만-프로젝트 기간에는 집이 가까운 게 우주대깡패급이었다. 집 최고!-고려 대상에서 제외가 되었다. 리스트업 후에는 면담을 진행했는데-기관 측에서는 면접이라 이름하는데, 면접이랄 것도 없었다. 그냥 얼굴보고 사람이 이상하진 않은지 그런 것만 확인하는 것 같다-리스트업한 모든 기관에서 면접 합격 통보-합격이랄 것도 없이 신청하면 그냥 되는 경우가 많고, 스타 강사의 경우에는 시험을 보는 경우도 왕왕 있다고는 들었다-를 받았다. 나의 경우 교육 기관 선택에 가장 큰 영향을 준 건 4번이었다. 결국에는 괜찮다는 평을 받은 그 강사에게 수업을 듣진 못했지만-내가 교육 기간을 착각해서 그 강사가 하는 줄 알고 신청했는데 알고 보니 다음 달에 진행할 강사였다-지금 돌이켜 생각하니 그냥 강사가 누구든 내가 열심히하면 되는 문제였던 것 같다. 기초 강의내가 선택한 교육 기관은 전공자들도, 비전공자들도 섞여있는데다가 굉장히 다양한-프로그래밍에 원래 관심이 있었지만 전공이 아닌 사람이나, 타 언어를 사용해 개발을 했던 전직 실무자, 컴공은 아니지만 관련 계열 전공을 한 자 등-수강생들을 한데 모아 가르치는 곳이었다. 기관 측은 아예 프로그래밍 지식이 없는 이들을 위해 매달 기초 강의를 제공을 해줬는데, 사실 지금 돌이켜보니 별 도움은 되지 않았으나 툴을 익힌다던가 원리에 대해 맛을 보고 가는 경험은 좋았던 것 같다. 그 때는 뭐가 뭔지 하나도 모르니까 처음에는 철학 수업에 들어온 줄 알고 착각했다. 추상화가 뭐고, 그러니까 상속을 받으면…. 나도 자바 기초 강의를 듣다가 대학교에서 배운 플라톤의 이데아에 대해 떠올리게 될 줄 상상도 못했다. 본 강의나는 6개월 강의를 들었다. 크게 3개의 분류로 나눠지는 진도였다. 자바 언어 웹 스프링 각각의 진도가 끝날 때마다 프로젝트를 진행했다. 사실 1번이 끝났을 때 구현한 프로젝트는 프로젝트라고 하기에도 민망할 정도였고, 2번부터 어디서 본 듯한 웹사이트 구현까지는 가능했다. 여기서 비전공자들이라면 들 법한 생각. 정말 아예 모르는 상태로 시작해서, 전공자들이랑 비등하게 프로젝트 구현이 가능할까?사실 구현까지는 가능하다고 생각한다 -물론 알고리즘이라던가, 자료 구조 같이 세부적인 내용까지 고려해서 효율 높은 구현은 안될 것 같지만-6개월 동안 공부하면서 느낀 건, 정말 공부하는만큼 느는 것 같다는 것. 나와 마지막 프로젝트에서 만난 한 분은 매일 저녁마다 새로운 공부를 하는 이였다. 다음날 내가 등원하면 요상한 게 구현되어 있었다. 그가 한 짓이었다. 그는 개발이 재밌다고 했고, 우리 기수에서 두번째로 빠르게 취업을 했다.-전공자들보다 빨리 취업을 했다.-나도 그처럼 열정 넘치게 개발에 몰두했으면 좋았으련만…. 나는 그가 아니니까 뭐, 할 수 있는 만큼 했다는 것에 의의를 둔다. 아래는 내가 위에서 설명한 3개의 분류를 조금씩 자세히 설명한 것들이다. Java와 Oracle지금 돌이켜 생각해보면 자바를 그렇게까지 열심히 공부할 필요가 있었을까, 하는 의문도 들지만 프로그래밍 언어를 처음 접하기엔 좋았던 것 같다. 나중에 웹에 들어간 뒤 자바의 많은 것을 잊는 나 자신을 발견하기도 했지만(…) 어쨌든 스프링에서 다시 만나기도 하고, 다른 언어를 배우는 근간을 세울 수 있다는 점에서 유익했다. 나중에 다른 언어-파이썬이라던가, C#등-을 배울 때 비교 대상으로 쓸 수 있을 것 같긴 하다. 오라클 또한 DB를 공부하는 첫 걸음으로 썼다. 기본적인 CRUD(자료 넣기, 자료 읽기, 자료 업데이트 하기, 자료 삭제하기를 줄여서 crud라 한다)를 배웠고 그 안에 프로시저, 트리거, 커서 등을 만들어 사용하는 방법을 배웠는데 어떤 db를 사용하는지에 따라 문법이 조금씩 달라져서… 자바와 마찬가지로 비교군으로 쓰기 좋았다. WEB웹이라고 통칭했지만 배운 건 세부적으로 다음과 같다. HTML CSS Java Script Ajax Json Bootstrap 각종 API 활용 WAS 내가 제일 어려워했던 건 css였다. 그러니까, 예제까지는 괜찮았는데 어쨌든 실제 구현에 들어갔을 적 화면에서 내가 원하는 대로 변형이 잘 안되니까 미칠 것 같았다. -‘왜 옆으로 안가니’라고 곡소리가 나게 만드는 대표적인 구현으로, 우리끼리는 차라리 모니터를 오려서 붙이자는 우스갯소리도 했다- 그 외에는 사실 다… 하다보니 되었다. 사실 지금도 공공데이터 api를 json으로 받아와 파싱하는 건 조금 자신 없긴 한데(…) 쉬는 기간동안 연습을 많이 해볼 작정이다. 스프링과 mybatis위에서는 스프링, 이러고 넘어갔지만 왜인지 mybatis를 빼먹으면 섭섭할 것 같아서 같이 기록. 개인적으로 스프링이 모든 걸 자동화하는 터라 처음에는 너무 혼돈의 도가니였는데-어떤 분께 스프링이 너무 어렵다, 말씀 드리니 스프링이 어려운 게 아니라 그 전의 기초가 잘 안되어 있는 것 같다는 현답을 주신 적이 있다-내가 어려워하는 이유를 곰곰이 생각해보니 세팅을 꼼꼼하게 잘 못하는 성격 탓인 것 같았다. 그러나 이 무지는 현재까지도 계속 진행 중. 변명 아닌 변명을 좀 해보자면, 3차 프로젝트의 모든 세팅을 한 사람이 몰아서 한데다가 그가 메서드 이름까지 모든 걸 만들어둬서, 나는 그 안, 비워진 메서드를 채워넣는 식으로 작업을 했다. 그래서 결국 세팅도… 다시 공부해야할 필요를 느낀다. 쓰다보니 제대로 아는 게 없는 것 같네 그 외, 따로 공부했던 것다른 포스팅에서 언급했듯 우리는 node.js와 aws를 사용했다. 노드의 경우 크롬 확장프로그램 때문에 사용할 수밖에 없었고, aws는 프로젝트 중에 사진 첨부 때문에 어쩌다보니 사용하게 됐다. 사실 구현을 한 소스를 봐도 정확히 뭐가 어떤 역할을 하는지 설명하라고 그러면 못할 것 같다. 정말 이런 말을 하고 싶지 않지만 내가 구현하지 않은 부분을 잘 모르겠다.-이걸 포트폴리오랍시고 낼 수 있을까도 너무 염려스럽다-현재로서는 내가 만든-만들었다고 할 수 있을지 모를-이 프로젝트를 내가 공부할 판이다-근데 다들 그런 것 같았다-원래는 서로가 서로의 소스에 대해 설명하는 시간을 가지려고 했으나 어쩌다보니… 결국…. 못했다. 우리 기수의 유일한 취업자들이 다 나랑 같은 팀일 건 또 뭐람. 내가 우리 프로젝트에서 맡아 구현한 부분은 아래와 같다. 웹소켓을 이용한 실시간 알림 처리(관련 포스팅을 해두었다) 트리거를 이용한 db 자동 인서트, 업데이트(관련 포스팅을 해두었다) 프로젝트 프론트 단 하이차트를 이용한 관리자 통계 데이터 테이블을 이용한 관리자 단 유저 관리 및 유저의 게시물 관리, 신고 확인 및 신고 처리(유저를 강제로 탈퇴 시키거나, 유저가 쓴 게시물 블라인드 처리, 신고한 게시물과 댓글을 확인하고 블라인드 처리하는 것) TinyMCE 에디터기 웹팩 번들링 및 커스터마이징 쓰고보니 정말 별 걸 안했다… 그래서 개인 프로젝트에 더 욕심을 내는 것 같기도 하고. 아, 2차 프로젝트는 이런 걸 했다. ajax를 이용한 비동기 댓글 crud 페이징 처리를 한 게시판 만들기 게시글 crud 썸머노트 에디터기를 이용한 게시물 작성 뷰단 구현 사실 3차는 2차에서 한 것을 제외하고 맡고 싶었던 터라 선택지가 많이 없었는데-원래 회원가입을 하고 싶었는데 가위바위보에서 졌다-지금 생각해보면 그냥 2차에서 한 거에서 더 디벨롭 시키는 방향을 욕심내도 되지 않았을까 싶다. 강의 수료 후, 아쉬운 점 및 느낀점어쩌다가 다른 기수나 다른 교육 기관에서 교육 받으신 분들과 교류하는 기회가 있었는데 기관마다, 강사마다 가르치는 차이가 크다는 걸 알게 됐다. 심지어 같은 분야의 수업인데도 강사가 누구인지에 따라 배우는 분야도 차이가 났다.-어떤 반은 언어를 두 개 배웠다고도 하고, 나의 경우 RDBMS(관계형 데이터베이스)만 배웠는데 어디는 또 NOSQL도 배웠다고 해서 혼란의 도가니-결국 느낀 건, 그냥 진짜 궁금하면 내가 하는 수밖에 없다는 것. 떠먹여주는 걸 바라면 안된다는 것. 나의 경우에는 갑작스러운 강사 교체가 이루어져서, 진도에서 분류 2에 해당하는 웹단을 한 번 더 듣는 일이 발생했는데, 처음에는 기관 측에서 분명 부족한 부분이 있으면 보강해주겠다고 했지만 그런 일은 벌어지지 않았고(…) 객관적으로 봤을 때 다른 기관에서 배운 이들 뿐만 아니라 다른 기수보다 우리 기수가 배운 것이 더 적지 않을까 하는 걱정도 된다. 제일 아쉬운 점은 모바일을 안 배웠다는 것. 도대체 나는 왜 이 수업을 들은 것인가 약간 자괴감에 휩싸이긴 하지만서도 안드로이드가 자바 기반이기 때문에 혼자서도 할 수 있을 것 같다는 희망을 얻게 되어 혼자서나마 공부해볼 작정이다. 이번 프로젝트에서 뼈 저리게 느낀 건, 의외로 개발적인 부분은 아니었다. 제일 난관이었던 건 협업의 어려움이었다. 사실 나는 대학에 진학해 일반적인 대학 교육 과정을 수료했으므로 팀플을 경험한 적이 수도 없이 많았다. 혼자 독박도 써봤고, 의도찮게 민폐도 끼쳐봤고-인과응보라고, 성적이 좋지 않았지만-함께 하는 이와 의견 충돌을 겪으며 더 나은 대안을 생각해보는 일련의 과정을 겪은 적이 있었다. 심지어 이번에 함께 프로젝트에 참여하는 이들은 나와 친한 이들이었다.-수료 프로젝트를 만드는 것이니만큼, 하고 싶은 이와 팀을 할 수 있도록 강사님이 배려해주셨다-그래서 대학 팀플보다 쉬우면 쉬웠지, 어렵진 않으리라 여겼다. 왜냐하면 일단 구성원 중 프리라이딩을 할 사람이 없으리라 여겼고, 모두 다 맡은 바 소임을 다할 이들이었기 때문에. 사람이 좋으니까 잘 되리라 여겼는데. 이게 오만이었을 줄은 상상도 못했다. 처음 협업이 어렵다고 느낀 건, 다름 아닌 뷰단 구성에서부터였다. 주제를 합의하는 건 굉장히 쉬웠는데 사람들마다 머리 속에 그리는 뷰단의 모습이 제각각이었다. 넣고 싶은 기능도 달랐고, 사이드바에 무엇을 넣을 건지, 네브 바(메뉴)는 어떻게 만들 것인지, 테마는 어떻게 갈 것인지. 이를 구체화해서 명시해야 하는 문서 작업에 들어가면서 정말 머리채 잡기 전까지 피 터지게 싸워댔다. 감정적으로 고조되었다가 화해하고, 술 마시고(…) 그걸 반복했다. 서로 잘하고자 하는 욕심이 있었기에 싸움은 더 격했다. 어찌 어찌 뷰단을 합의 보고 난 뒤에 다시 싸우게 된 건 서로가 서로의 소스를 이해하지 못하는 상황이 닥치고 나서였다. 병합을 하면 충돌이 났고, 충돌이 가시적으로 보이지 않아도 됐던 기능이 안되었다가, 대환멸의 서막이었다. 서로가 서로의 소스를 읽기에는 너무 바빴고, 확인을 하지도 않고 병합을 해버리는 상황들이 반복되며-물론 그건 대부분 특정인들이 그랬지만 그들은 프로젝트 끝까지 습관을 고치지 못했다-감정적으로 갈등이 쌓여갔다. 사실 자바를 배울 적에 강사님이 말씀하시길 “코딩 스타일이 있다. 편한 대로 하면 된다” 고 했건만 서로의 스타일을 인정하지 못했다. 솔직히 말해서 위와 같은 뷰단, 스타일 합의 부분은 우리가 평등하기 때문에 갈등이 더 심한 것 같았다. 그냥 누가 ‘이렇게 해!’라고 시키면 군말 없이 할 법한 것도 왜 그렇게 해야만하는지 서로를 설득하는데 너무 많은 노력이 필요했다. 코딩을 잘해봤자 같이 배우는 입장에서 얼마나 특출나게 잘하겠으며, 같은 곳에서 같은 사람에게 코딩을 배웠는데 얼마나 많이 벗어난 코드를 구현했을까. 그저 프로젝트가 조금씩 궤도에 오르며, 에러가 미친 듯이 나기 시작하며 스트레스를 받기 시작하고 조금만 건들이면 툭, 터지는 그런 상황이었던 것 같다. 왜 면접에서 협업을 해본 경험이 있는지 그렇게 물어대는지 알 수 있던 경험이었다. 모든 갈등의 병합이 효율적이고 성공적이었던 것만은 아니지만 이후 협업은 보다 나아지리라 믿는다. +) 아 그리고 생각보다 커뮤니케이션이 어려운 사람이 많았다. 물론 내가 부족한 탓도 있으리라 여기지만, 말이 너무 이해하기 어려워서 차라리 문서로 정리해서 달라고 말씀드리니 글로 자신의 생각을 적는 것도 힘들어하는 이들이 많아서 조금 놀랐다. 도대체 어떻게 커뮤니케이션을 하는 게 효과적인 건지 고민하는 계기가 되었다. 통합해서이 글을 과연 누가 읽을까, 를 고민하다가 누구에게 필요한 글을 쓰고 싶은 걸까, 를 고민해봤다. 나는 이 글을 나처럼 국비교육과정을 고민하는 이들이 읽기를 바라기에 그들에게 하고 싶은 말을 몇 자 적는 것으로 이 포스팅을 마치고자 한다. 노력하는 만큼 배울 수 있던 시간이었습니다. 국비교육과정은 세금으로 운영되기에, 예산이 널널한 기간에 듣는 게 좋습니다.(만약 연말에 듣게 된다면 제 때 훈련 수당이 지급되지 않을 가능성이 높습니다) 세상은 넓고 다양한 사람이 많습니다. 공부도, 취업도 누가 떠먹여주진 않는 것 같습니다. 6개월을 고생해 만든 수료 프로젝트는 이것이고, 사실 에러가 너무 많이 나서(…) 공개가 약간 민망한 감이 있기도 하고 과연 aws는 언제까지 살아있을지 알 수가 없다. 왜냐하면 내 aws 계정이 아니기 때문!","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"node.js","slug":"node-js","date":"2018-11-21T07:53:21.000Z","updated":"2018-11-26T07:22:24.495Z","comments":true,"path":"2018/11/21/node-js/","link":"","permalink":"http://eunajjing.github.io/2018/11/21/node-js/","excerpt":"","text":"노드JS공부하게 된 계기프로젝트에서 노드를 사용할 것 같다는 의견이 있어서 나름 낑낑거리며 공부했다. 프로젝트 막바지인 지금, 당시 정리해둔 문서가 많이 허접하긴 하지만 뭐… 공부했던 기록을 남겨둔다. 참고한 것Do it! Node.js 근데 많이 참고하진 않았다…변명처럼 들리겠지만 당시에 나는 플젝에서 필요할 것만을 보고 싶었고, 실제로 프로젝트 팀원들에게 그렇게 요구 받았다.(프로젝트 시작 전 우리가 어떤 기능을 쓸 것인지에 대해 고민해보고, 각자 특정 부분을 맡아 공부 후 다른 팀원에게 설명하는 식으로 스터디를 진행했다) 참고한 책은 모든 장이 연결되어 순차적으로 한 웹사이트를 구현하는 방식에 대해 이야기하고 있어서… 예를 들어 우리 프로젝트에서는 몽고 디비를 빼자고 해서, 나는 공부할 당시엔 몽고 디비를 간략히 보거나 아예 보지 않아도 됐다. 이런 식으로 특정 장을 훑듯 보고 다음 장으로 건너 뛰니, 제대로 이해가 되지 않은 파트가 발목을 잡아 정말 이해해야할 예제 소스가 잘 이해가 되지 않았다. 사실 노드를 써서 이번 프로젝트를 진행한 것도 사실이고, 내 블로그도 노드를 기반으로 해서 만든 프레임웤이긴 한데. 아직도 잘 모르겠다. 그냥 그 때 그 때 검색하면서 진행을 해서… 정말 본론 시작 - 당시에 정리한 문서시작하기 전에 node.js 다운로드 후 설치 : https://nodejs.org/en/ (8.12.0 LTS 버전을 이용하였습니다) 이클립스에서 사용할 예정이므로 이클립스에서 node.js 플러그인 설치(http://marketplace.eclipse.org/content/nodeclipse) node.js자바 스크립트를 이용해 서버를 만들 수 있는 개발 도구 node.js 특징 비동기 입출력 가능 이벤트 기반 모듈과 패키지 npm(Node Package Manager) 노드 패키지의 설치, 삭제를 지원하는 프로그램 패키지(모듈+α)는 만든 이가 다른 사람도 사용할 수 있도록 인터넷에 공유해놓는 게 일반적 노드에서 사용할 수 있는 대표적인 전역 객체 console exports process 노드에서 사용할 수 있는 대표적인 전역 변수 __filename __dirname console의 메서드들log() 형식 특수문자 예시 코드 콘솔 %d 숫자 console.log(“ 숫자 : %d”, 10) 숫자 : 10 %s 문자열 console.log(“ 문자 : %s”, 문지은) 문자 : 문지은 %j JSON console.log(“JSON : %j”, { 팀장 : “ 이주원”}) JSON {“ 팀장” : “ 이주원”} log() 외 메서드 설명 dir(object) 객체 속성 출력 time( 객체명) 실행 시간 측정을 위해 실행 시작 시간 기록 timeEnd( 객체명) 실행 시간 측정을 위해 실행 종료 시간 기록 모듈 사용(exports)기존에 여러 개로 나눠둔 무언가를 필요에 따라 맞춰다가 쓰는 식 예시module1.jsexports.methodName = function() { retrun result; }; main.jsvar module = require(&apos;module1&apos;); // require() // : 모듈을 불러올 때 사용하며 파라미터는 모듈의 이름이나 모듈의 경로 // 모듈 객체가 리턴되어 모듈객체.함수명(); 으로 접근 가능 // 만약 이름에 해당하는 파일이 없다면, 이름에 해당하는 폴더를 찾아 그 안의 index.js 실행 module.methodName(); exports와 module.exports이해에 참고했던 블로그 exports module.exports 여러 개의 변수, 함수를 각각의 속성으로 추가 가능 하나의 변수나 함수, 객체를 직접 할당, 참조가 끊기면 빈 객체 리턴됨 (단 하나의 객체만 사용 가능하다고 이해) process 속성 / 메서드 설명 예시 argv 프로세스를 실행할 때 전달되는 파라미터 정보를 가진 속성 process.argv.length : 파라미터 개수 process.argv[2] : 2 번 배열의 파라미터 env 환경 변수 정보를 가진 속성 process.env[‘OS’] : OS 환경 변수의 값(data) exit() 프로세스를 끝내는 메서드 내장 모듈과 외장 모듈 내장 모듈 : 사용자가 직접 만든 js 모듈 외장 모듈 : 다른 사람이 만들어 놓아 사용자가 npm 패키지를 이용해 다운로드한 js 모듈 외장 모듈 경로 : 프로젝트 폴더 &gt; node_modules 폴더 &gt; 모듈명 폴더 만약 매번 프로젝트마다 같은 패키지를 이용한다면 brackets-nodejs에 node_modules 폴더를 이동시키면 된다. 내장 모듈 사용하기(path만 정리) 모든 내장 모듈은 여기에서 볼 수 있다 메서드 설명 join() 여러 개의 이름을 모두 합쳐 하나의 파일 패스로 만들며, 구분자 등을 알아서 조정 dirname() 파일 패스에서 디렉터리 이름만 반환 basename() 파일 패스에서 파일 이름만 반환 extname() 파일 패스에서 확장자만 반환 외장 모듈 사용하기사용 예시 기존에 nconf라는 외부 모듈을 설치했다는 전제 하외장모듈 설치 단축키 : % npm install 외장모듈이름 var nconf = require(&apos;nconf&apos;); // 외부 모듈의 경우 경로가 아닌 모듈의 이름을 직접 불러야 함 nconf.modulInMethod(); package.json% npm init 명령어를 실행하면 생기는 json 파일로, 프로젝트에 대한 기본 정보가 들어 있으며 현재 프로젝트에 설치된 외부 모듈의 의존도 함께 기록됨향후 다른 PC에서 같은 모듈들을 사용하고 싶다면 package.json만 옮겨서 가져가면 된다. 사용법 % npm init: package.json 파일 생성 % npm install 외부모듈이름 –save : 의존 설정할 외부모듈을 설치한다. package.json이 있는 상태에서 설치된 것들만 package.json이 기록한다. 향후 다른 PC로 옮길 때 PC로 json 파일 옮기고, % npm install 명령어 실행 : package.json의 의존 속성을 참고해 패키지 설치","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"nodeJS","slug":"개발공부/nodeJS","permalink":"http://eunajjing.github.io/categories/개발공부/nodeJS/"}],"tags":[]},{"title":"websocket","slug":"websocket","date":"2018-11-08T07:27:20.000Z","updated":"2018-11-26T07:22:24.496Z","comments":true,"path":"2018/11/08/websocket/","link":"","permalink":"http://eunajjing.github.io/2018/11/08/websocket/","excerpt":"","text":"websocket을 이용한 간단한 알림 구현 유용하게 참고했던 링크들시니어코딩 유튜브 강좌 스프링 시큐리티를 사용하지 않아 http세션과 웹소켓을 잇는 작업이 존재 연속된 강의라서 도중에 강의만 따라해서는 모르는 과정이 있음, 이 부족한 부분은 깃허브에 소스가 오픈되어 있어서 보면서 해야함 블로그 포스팅 xml 단에서 설정해야할 부분이 빠져있음 간단하게 몇 건의 send를 받았는지 표기하는 예제 개인적으로 제일 많은 도움을 받았음 그런데 왜인지 똑같은 소스인데 override가 안되더라ㅠㅠ 근데 이건 안되어도 일단 기능은 제대로 발동해서 놔둠 블로그 포스팅 위의 블로그 포스팅에서 누락된 것을 보기 위해 참고했었음 이상한 곳에서 계속 헤메이던 웹소켓 구현 다들 저 위의 링크들을 따라하다보면 나…름 구현은 가능할 듯 근데 내가 힘들었던 건 많이 참고했다는 블로그 포스팅을 보고 1차로 페이지 이동 시 웹소켓 발동까지는 했는데 갑자기 실시간으로 알림 받기로 변경하라는 피드백을 받아서 일부를 수정하면서 생긴 것. 인강은 디비에 있는 데이터를 뿌리지 않고 웹소켓이 보낸 데이터를 클라이언트 단에 단순히 뿌려주는 식으로 구현됨 그런데 나는 디비에서 가져와야 하기 때문에 쵸큼 달랐고 걍 핸들러에서 db에 select를 하게끔 만들었다. 나는 send된 파라미터가 여러 개일 때만 처리하려고 했는데 왜인지 파라미터 여러 개 send가 먹지 않았던 문제가 제일 힘들었다. 나중에 알고보니까 아래처럼 써서 그랬던 거 같다. websocket.send(&quot;~~~&quot;, &quot;~~~&quot;, &quot;~~&quot;); 이렇게 썼다면 되지 않았을까?(어쩌다보니 이렇게 보낼 필요가 없어서 나는 시도는 안해봤다) websocket.send(&quot;~~~~, ~~~~, ~~~&quot;); 그리구 인강에서 전역 변수로 빼서 사용하는 웹소켓, 나는 먹지 않아서 그냥 고치기 전? 전역 변수로 빼지 않고 사용하는 웹소켓으로 구현했다. 테스트 웹소켓 테스트 가능 사이트","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"trigger","slug":"trigger","date":"2018-11-01T02:06:33.000Z","updated":"2018-11-26T07:22:24.496Z","comments":true,"path":"2018/11/01/trigger/","link":"","permalink":"http://eunajjing.github.io/2018/11/01/trigger/","excerpt":"","text":"트리거의 이용 트리거특정한 테이블에 INSERT, UPDATE, DELETE와 같은 DML문이 수행되었을 때, 데이터베이스에서 자동으로 동작하도록 작성된 프로그램 문법create trigger 트리거명 [before OR after] [insert OR update OR delete] on DML_실행되는_테이블명 [for each row] begin 실행할_쿼리_작성 end; before : DML 실행 전에 트리거 발동 after : DML 실행 후에 트리거 발동 insert : 만약 이 테이블에 인서트되면 해당 트리거 발동 update : 만약 이 테이블이 업데이트되면 delete : 삭제되면 for each row : 한 레코드 당 한 번씩 발동 레코드 구조체 나는 mariaDB를 사용해서 프로젝트 구현 중이기에 new.칼럼명 : 입력된 레코드에서 해당 칼럼의 데이터 old.칼럼명 : 기존에 있던 레코드에서 칼럼의 데이터 (delete문에서는 new.칼럼명을, insert문에서는 old.칼럼명을 사용할 수 없다) 트리거에서 조건문 만들기create trigger blind after update ON report FOR EACH ROW -- blind란 트리거를 생성한다. 이 트리거는 report 테이블에 레코드 하나가 들어간 이후에 실행된다. begin -- 트리거 정의 시작 if new.checkCode = &apos;PS02&apos; then -- 만약 업데이트된 레코드의 checkCode 칼럼의 값이 &apos;PS02&apos;라면(if절 1번) if new.noteOrCommCode = &apos;NC00&apos; then -- 만약 업데이트된 레코드의 noteOrCommCode 칼럼의 값이 &apos;NC00&apos;라면 (if절 2번) insert into notify(userEmail, notifyCode, notifyTarget, readCheck) values ((select userEmail from note where noteNum=new.noteNum), &apos;RN&apos;, new.noteNum, 1) -- 해당 SQL문을 실행한다. on DUPLICATE KEY update readCheck=1; -- 만약 이미 중복하는 레코드가 있다면 insert하지 않고 update하겠다. -- readCheck라는 칼럼의 데이터를 1로 else -- 업데이트된 레코드의 noteOrCommCode 칼럼의 값이 &apos;NC00&apos;이 아니라면 insert into notify(userEmail, notifyCode, notifyTarget, readCheck) values ((select userEmail from notecomm where noteCommNum=new.noteNum), &apos;RC&apos;, (select noteNum from notecomm where noteCommNum=new.noteNum), 1) on DUPLICATE KEY update readCheck=1; end if; -- if절 2번 종료 end if; -- if절 1번 종료 end; -- 트리거 정의 종료 on DUPLICATE KEY는 트리거의 문법이 아닌 일반 쿼리 문법 트리거로 루프 돌리기create trigger QNAAdmin after insert on notify for each row begin DECLARE done INT DEFAULT FALSE; declare tempoUserEmail varchar; declare curUserEmail cursor for select userEmail from roles where roleCode=&apos;ROLE_ADMIN&apos;; DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; if (select roleCode from roles where userEmail=new.userEmail) = &apos;ROLE_ADMIN&apos; then open curUserEmail; ins_loop: LOOP fetch curUserEmail into tempoUserEmail; if done then leave ins_loop; end if; insert into notify(userEmail, notifyCode, notifyTarget) values (tempoUserEmail, &apos;QNA&apos;, new.qnaNum); end loop; close curUserEmail; end if; end; 관리자가 여러 명일 수 있어서, 쿼리의 결과가 다중일 때 트리거 안에서 루프를 돌게끔 쿼리문을 짜보았다.그런데 위 쿼리는 실제로 프로젝트에 사용은 못했다.roles가 예약어로 잡혀있는 것 같다고 강사님이 그러셨다.문법 자체는 오류가 없어보인다고 그러셔서, 나중에 또 내가 이런 뻘짓하고 싶어할까봐 같이 기록. 프로젝트에선 파라미터로 role이 관리자인 것들을 리스트 형태로 보낸다음, foreach로 돌렸다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"notification API를 이용한 웹 알림 구현","slug":"notification-API를-이용한-웹-알림-구현","date":"2018-10-16T03:43:02.000Z","updated":"2018-11-26T07:22:24.495Z","comments":true,"path":"2018/10/16/notification-API를-이용한-웹-알림-구현/","link":"","permalink":"http://eunajjing.github.io/2018/10/16/notification-API를-이용한-웹-알림-구현/","excerpt":"","text":"notification API를 이용한 웹 알림 구현&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;notify()&quot;&gt;알림 띄우기&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() { if(window.Notification) { Notification.requestPermission(); } // 온 로드되면 공지 기능을 허용한다. function notify() { var notification = new Notification(&apos;공지 타이틀&apos;, { icon: &apos;https://camo.githubusercontent.com/7710b43d0476b6f6d4b4b2865e35c108f69991f3/68747470733a2f2f7777772e69636f6e66696e6465722e636f6d2f646174612f69636f6e732f6f637469636f6e732f313032342f6d61726b2d6769746875622d3235362e706e67&apos;, body: &apos;github 블로그로 이동&apos; }); notification.onclick = function() { window.open(&apos;http://eunajjing.github.io&apos;); }; // 알림 메시지 클릭하면 해당 페이지 새 창이 뜬다. } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 원래 커뮤니티 사이트에서 내가 쓴 게시물에 댓글 달면 댓글 달렸다고 알리는 기능? 구현하고 싶어서 검색하다 발견한 소스. 간단하게 잘라서 구현해봤다. 내가 원한 건 이게 아닌데…","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"}],"tags":[]},{"title":"mongoDB_01","slug":"mongoDB-01","date":"2018-10-15T02:09:06.000Z","updated":"2018-11-26T07:22:24.495Z","comments":true,"path":"2018/10/15/mongoDB-01/","link":"","permalink":"http://eunajjing.github.io/2018/10/15/mongoDB-01/","excerpt":"","text":"MogoDB(NoSQL) 기초01공부한 강의 근데 강의가 오래 전 것 같고, 아예 nosql을 처음 접하는 나로는 조금 어려운 부분이 있어서(group, map-reduce 등) 이번 것만 듣고 다른 강의 찾아 들어볼 생각 NoSQL관계형 DB로 처리하기에는 약간 부족한 부분들을 매꿔줄 수 있는 DB. KEY VALUE 형 문서형 (MongoDB) 컬럼 제한형 그래프 기반형 몽고 DB 데이터 구성 데이터 베이스 : 컬렉션들의 집합 컬렉션 : 테이블과 유사 BSON : 스키마에 맞춰 저장하는 유형 BSON: JSON의 바이너리 형태라는 뜻 몽고 DB 특징 조인을 지원하지 않는다(대부분의 NOSQL이 그러함) 스키마가 존재하지 않는다 create DB 구문이 존재하지 않는다(하지만 drop절은 있다) 몽고 DB 첫걸음몽고디비가 제공하는 자바스크립트 쉘 인터페이스로 몽고디비에 접속을 하게 되면 use 데이터베이스명 구문을 사용하면 데이터베이스가 자동으로 생성된다.but 파일이 자동으로 생성은 안된다. (컬렉션을 생성해야함) db.stats(); 해당 DB 설정 상황 확인 db.createCollection(“컬렉션명”); 컬렉션 생성 명령어 db.help 어떠한 명령어가 있는지 확인하는 명령 db.getCollectionNames(); 실제로 컬렉션이 만들어져있는지를 확인하는 메서드 몽고 DB의 파일들 mongod.lock : 실제 서버를 실행시키는 프로세스 id 저장 .ns : 몽고디비는 컬렉션, 인덱스를 생성하게 되면 각각에 네임스페이스 필드를 만들게 되어 있음. 해당 값들을 저장하는 파일 0 또는 1 : 실제 데이터를 저장하는 파일들 (파일의 크기 0은 64메가, 1은 128메가가 초기 할당된 상태로, 이후 메모리 증가가 필요한 경우 숫자 크기가 늘어난다, 메모리는 2기가가 될 때까지 2배씩 늘어난다.) 몽고 DB의 컬렉션 종류일반적인 용도의 컬렉션 캡드 컬렉션 고정된 크기 이상 증가하지 않음 만약 크기 이상 데이터가 들어갈 경우 가장 오래된 도큐먼트를 덮음 개별 도큐먼트 삭제가 불가능함 기본적으로 몽고 디비에서 자신의 데이터를 관리하기 위한 시스템 컬렉션들이 두 개 생성되어 있음 (system.index, system.namespaces) 복제를 위한 컬렉션 insert db.컬렉션명.insert({“컬럼1”:”value1”, “컬럼2”:”value2”}) db.컬렉션명.find({“컬럼1”:”value1”}) – find할 조건, select와 비슷 {“_id” : ObjectId(“명시적으로 쓰지 않았다면 몽고 디비가 임의로 붙였을 id 값, 이 id는 내부적으로 관리를 위해 생성”), “컬럼1” : “value1”, “컬럼2” : “value2”} – find 결과 update db.컬렉션명.update({“기존 컬럼명”:”기존 value”}, {“치환할 컬럼명”:”치환할 value”}}) db.컬렉션명.update({“기존 컬럼명”:”기존 value”}, {$set{“덮어씌울 컬럼명”:”덮어씌울 value”}}) 첫번째 매개변수는 update 대상이 될 것을 찾는 조건이되며 두번째 매개변수는 치환할 데이터 매개변수.관계형 DB와 다르게 몽고 디비는 만들어진 도큐멘트를 치환하는 방식으로 update가 이루어진다.치환의 경우 오버헤드가 발생할 수도 있기 때문에 $set이라는 명령어를 사용하여 문서를 치환하지 않고 원하는 부분만 바꿀 수 있다. remove db.컬렉션명.remove({“삭제할 컬럼명”:”삭제할 value”}) selectfind 검색 조건이 참일 때 커서가 반환 db.컬렉션명.find(); {“_id” : ObjectId(“-“), “칼럼1” : value1} {“_id” : ObjectId(“-“), “칼럼2” : value2} {“_id” : ObjectId(“-“), “칼럼3” : value3} findOne (= find.limit(1);) 검색 조건에 해당하는 문서가 여러 개라도 하나만 반환 {“_id” : ObjectId(“-“), “칼럼1” : value1} 정규표현식(대표적인 지시자)범위 지시자 $gt $gte $lt $lte집합 지시자 $in $all $nin부울 지시자 $ne $not $or $exists기타 $mod $type $where group개발자가 원하는 함수를 만들어 쓸 수 있으나 결과가 16메가가 넘으면 처리가 되지 않음 map-reduce개발자가 원하는 함수를 만들어 쓸 수 있음 map : 그룹화, 리듀스 계산을 위한 데이터 전달 reduce : 실제 연산 인덱스 system.namespaces : 색인의 이름 정보 데이터 저장되어있음 system.indexs : 색인의 상세 정보 데이터 저장되어있음 ensureIndex : 색인 생성 dropIndex : 색인 삭제 db.컬렉션명.ensureIndex({“칼럼”:1}) // 1은 임의로 준 값db.system.indexs.find() // 상세 정보 데이터들이 출력됨","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"몽고DB","slug":"개발공부/몽고DB","permalink":"http://eunajjing.github.io/categories/개발공부/몽고DB/"}],"tags":[]},{"title":"SQLD 후기-제30회 자격검정","slug":"SQLD_후기-제30회_자격검정","date":"2018-10-07T06:55:41.000Z","updated":"2018-11-26T08:02:37.000Z","comments":true,"path":"2018/10/07/SQLD_후기-제30회_자격검정/","link":"","permalink":"http://eunajjing.github.io/2018/10/07/SQLD_후기-제30회_자격검정/","excerpt":"","text":"SQLD 후기 - 제30회 자격검정 응시 어쩌다보니 조금 즉흥적으로 응시하게 된 SQLD 시험. 발표가 난 건 좀 됐지만, 정처기 공부 때문에 정신이 없어서 후기를 못 올렸다. 보게 된 경위원래 나는 2018년도 정보처리기사 2회차 필기 시험을 봤었고, 해당 회차에 한 번에 합격을 하긴 했었다. 그런데 실기 공부를 너무 안해서(..) 실기는 다음 회차를 노리게 되었고 그 붕 뜬 기간 동안 무얼 공부할까 하다가, 마침 SQLD 시험 일정이 맞는 거 같아서 시험을 보게 되었다. 2017년도 시험이 너무 어려웠다는 후기가 많았기에-물론 2018년도 시험은 쉽다는 후기가 현재에는 많지만 당시에는 29회(2018년도 2회차 시험) 발표 전이라 쉽다는 후기가 별로 없었다-되게 스트레스를 많이 받아가며 공부를 했었다. 막판에는 이렇게 힘들어할 바엔 그냥 시험지나 보고 오자, 마인드로 공부를 잘 안했을 정도. 그런데 치루고 나니까 난이도가 쉬웠던 터라, 막판까지 공부를 열심히 할 걸 그랬다는 아쉬움이 남는다. 시험 준비나는 다른 분들의 후기를 따라 기본서는 사지 않았고, 공식 홈페이지에서 설명해놓은 개념을 몽땅 프린트해서 스프링제본했다. 홈페이지와 기본서의 내용은 같다곤 하는데…. 사실 홈페이지가 가독성이 정말 많이 떨어져서 책을 구매하는 것도 나쁘지 않았을 것 같다는 후회가 들었다. 나는 막판에 내가 프린트한 스프링 책을 버리고, 그냥 sqld를 공부하시던 분들이 인터넷에 정리 겸 해서 올려두신 걸로 공부했다. 너무 가독성이 안좋아서 무슨 소리인지 당최 이해가 안돼서… 그리고 많은 분들이 추천하셨던 책인, ==SQL 자격검정 실전문제== 이 문제집은 구매해서 풀었다. 진짜 후기들 말따라 기본서의 그 모든 어려운 개념을 차근차근 읽어서 이해하는 것보단 문제에 있는 것 위주로 일단 공부를 한다음에 확장하는 식으로 공부하는 게 더 효율적이었던 것 같다. 근데 시험의 80% 지분이 있는 2과목 위주로 시험 문제가 많고, 1과목은 그렇게 문제가 많은 것 같지가 않아서 좀 불안했다. 그래서 나는 찾아보니 시중에 ==SQLD,SQLP 연습문제 300== 이 문제집도 있길래 마저 풀었다. 이 책은 이북으로만 출판이 되어있고, 아직 학적이 남아있는 학교 도서관에서 빌릴 수 있어서 사진 않고 빌려 보았다. 실전문제집이 정말 데이터 뽑아내기 위주의 문제가 많다면 이 책은 개념을 묻는 문제 위주여서 나름 도움이 되었다. 1과목에서 과락하시는 분들이 제법 있다고 하길래 계속 불안했거든. 그런데 ‘나름’ 도움이 됐다고 하는 게 너무 오타가 많다ㅠㅠ… 굳이 굳이 없는데 사서 볼 책인지는 사실 잘 모르겠다. 그리고 다른 분들은 복원 문제 찾아서 많이 풀어보기를 추천하시던데, 나는 사실 잘 모르겠다. 막판에 나도 복원 문제를 구글링해서 몇 번 풀어보긴 했지만… 차라리 문제집을 여러 번 풀어보거나(근데 문제집 여러 회독하면 문제 답을 아예 외우게 되어서 내가 진짜 이 쿼리문을 이해하고 체크하는 건지, 아니면 외워버려서 체크하는 건지 잘 모르겠다) 헷갈리는 개념을 바로 잡는 게 내게는 더 도움이 되었던 것 같다. 마치며정말 자격증 한 줄 채우기 위해 봤던 시험이긴 했지만, 정보처리기사 공부하는 것보다 얻어가는 게 많은 시험이었다. 잘 쓴 쿼리문은 코드량을 줄인다는 걸 좀 많이 느낄 수 있기도 했고. 개인적으로 여유가 된다면 sqlp에도 도전해보고 싶다.","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]},{"title":"정보처리기사-신기술용어","slug":"정보처리기사-신기술용어","date":"2018-10-06T10:14:47.000Z","updated":"2018-11-26T07:22:24.497Z","comments":true,"path":"2018/10/06/정보처리기사-신기술용어/","link":"","permalink":"http://eunajjing.github.io/2018/10/06/정보처리기사-신기술용어/","excerpt":"","text":"신기술용어 지그비 : 저속, 저비용, 저전력의 무선 망을 위한 기술. 주로 양방향 무선 개인 영역 통신망 기반의 홈 네트워크 및 무선 센서망에서 사용되는 기술 피코넷 : 여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신기술을 사용하여 통신망을 형성하는 무선 네트워크 기술 애드훅 : 고정된 유선망을 가지지 않고 이동 호스트(Mobile Host)로만 이루어진 통신망 스콤 : 미국 전자 학습 표준 연구 개발 기관인 ADL에서 제정한 사실 표준 디봅스 : 시스템 개발과 운영을 병행 및 협업하는 방식 하둡 : 대량의 자료(Big Data)를 처리할 수 있는 큰 컴퓨터 클러스터에서 동작하는 분산 응용 프로그램을 지원하는 자유 자바 소프트웨어 프레임워크 ICN : 통신을 기반으로 한 이전의 인터넷 통신 패러다임을 정보 중심으로 재편성하려는 네트워킹이다 OGSA : 애플리케이션 공유를 위한 웹 서비스 표준과 인프라 자원의 공유를 위한 그리드 기술이 결합된 개방형 표준이다. SOA : 기업의 소프트웨어 인프라인 정보 시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보 기술 아키텍처 ITIL : 세계적으로 공인된 Best Practice(모범 실무)를 제공하는 IT서비스 품질모델 ITSM : 프로세스와 고객에 초점을 맞춘 서비스 관리 AMR :자동 원격검침 시스템으로 검침원이 일일이 고객을 방문하지 않고 단말기를 이용해 검침 데이터를 읽고 컴퓨터 운영프로그램과 연계해 고지서 발급은 물론 수요 패턴까지 효율적으로 관리할 수 있는 시스템 SDN : 하드웨어 중심의 네트워크를 소프트웨어 기반으로 전환시키는 것 DLP : 기업 내부자의 고의나 실수로 인한 외부로의 정보 유출을 방지하는 솔루션 MDM : OTA(Over The Air, 휴대폰무선전송기술)을 이용하여 언제 어디서나 모바일기기가 Power On 상태로 있으면 원격에서 모바일 기기를 관리할 수 있는 시스템 SCM : 제조, 물류, 유통업체 등 유통 공급망에 참여하는 모든 업체들이 협력을 바탕으로 정보기술을 활용, 재고를 최적화하고 리드 타임을 대폭적으로 감축하여 결과적으로 양질의 상품 및 서비스를 소비자에게 제공함으로써 소비자 가치를 극대화하기 위한 21세기 기업의 생존 및 발전전략 디지털 프로슈머 : 인터넷 커뮤니티에 참여해 콘텐츠를 즐기고 정보와 자료를 얻는 소비자이면서 동시에 의견을 적극 개진해 생산에도 영향을 미치는 사람 크리슈머 : 프로슈머보다 발전된 개념으로 소비를 통해 욕구를 충족하는 수준을 넘어 자신의 개성을 표현하는 창조적인 소비자 올랩 : 이용자가 직접 데이터베이스를 검색, 분석해서 문제점이나 해결책을 찾는 분석형 애플리케이션 개념 디지털 발자국 : 사람들이 여러 웹페이지에 로그인을 하거나 결제 정보를 입력하는 등 온라인 활동을 하면서 남긴 기록 웨버홀리즘 : 생물학적 데이터를 수집, 관리하는 기술 노모포비아 : 스마트폰 등 휴대전화가 없을 때 초조해하거나 불안감을 느끼는 증상을 일컫는 말 생물 정보학 : 생물학적 데이터를 수집, 관리하는 기술 모바일컴퓨팅 : 무선 이동통신과 PDA, 인터넷을 통해 컴퓨터와 통신기술을 효과적으로 연계시켜 언제, 어디서나 이동하면서 정보교환이나 수집, 검색, 정리, 저장하는 기술 소셜다이닝 : SNS를 통해 관심사가 비슷한 사람끼리 만나 식사를 즐기며 인간관계를 맺는 것 소셜엔지니어링 : 컴퓨터 보안에서 인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안 절차를 깨트리기 위한 비기술적 시스템 침입 수단 CC : IT 제품의 보안성을 평가하기 위한 국제 기준 ERM : 기업의 모든 단위업무별로 흐름도를 분석하여 어떤 과정에 어느 정도의 위험요인이 있는지 평가하여 전 조직원들이 공유하도록 함 USIM : 사용자 인증과 글로벌 로밍, 전자상거래 등 다양한 기능을 1장의 카드에 구현한 것 원격 현장감 : 공간적으로 떨어져 있는 장소 또는 가상의 장소를 신체적으로 경험하는 것 ISO20000 : 국제표준화기구(ISO)가 2005년 발표한 IT서비스관리(ITSM) 국제 표준 SLA : 서비스 사업자와 서비스 사용자가 제공될 정보 서비스 및 그와 연관된 여러 조건들에 대한 서로의 책임과 의무 사항을 기술해 놓은 협약서 플래시메모리 : RAM과 ROM의 장점을 한 대 묶은 메모리 VOD : 방송 프로그램을 시청자의 요구에 따라 시간과 공간을 초월하여 제공하는 시스템 IMS : 인터넷 프로토콜(IP)을 기반으로 음성, 오디오, 비디오 및 데이터 등의 멀티미디어 서비스를 제공하는 규격 NDN : 콘텐츠 중심 네트워크와 동일한 개념 포스퀘어 : 구글에서 독립한 데이스 크롤리(Dennis Crowley)가 2009년 3월에 발표한 위치기반 소셜네트워크서비스 정보전염병 : ‘정보’와 ‘전염병’의 합성어 해시태그 : #(샤프 기호)와 특정 단어(들)을 붙여 쓴 것 스모크테스팅 : 소프트웨어 일부를 개발한 후 본격적인 시험 수행에 앞서 소프트웨어의 결함을 식별하고 변경의 유효성을 검사하는 시험의 형태 랜섬웨어 : 인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 스프레트시트, 그림파일 등을 암호화해 열지 못하도록 만든 후 돈을 보내주면 해독용 열쇠 프로그램을 전송해 준다며 금품을 요구하는 악성 프로그램 포직스 : 서로 다른 UNIX OS의 공통 API를 정리하여 이식성이 높은 유닉스 응용 프로그램을 개발하기 위한 목적으로 IEEE가 책정한 애플리케이션 인터페이스 규격 비트코인 : 사토시 나카모토라는 필명의 프로그래머가 개발하였다. 실제 생활에서 쓰이는 화폐가 아니라 온라인 거래상에서 쓰이는 가상화폐 코드커터족 : 지상파와 케이블 등 기존 텔레비전 방송 서비스를 해지하고 인터넷 방송 서비스를 선택하는 소비자군 핀테크 : 금융과 IT의 융합을 통한 금융서비스 및 산업의 변화를 통칭 트랙백 : 다른 사람의 글을 읽고 그 글에 직접 댓글을 올리는 대신에 자신의 블로그에 글을 올리고 글의 일정 부분이 다른 사람의 댓글로 보이도록 하는 것 subscription commerce : 구매자가 정기 구독료나 가입비를 서비스업체에 지급하면 해당 업체가 상품을 알아서 선정해 정기적으로 배달해주는 상거래 재핑효과 : 채널을 돌리다가 중간에 있는 채널의 시청률이 높아지는 현상 IOT : 가전제품, 전자기기뿐만 아니라 헬스케어, 원격검침, 스마트홈, 스마트카 등 다양한 분야에서 사물을 네트워크로 연결해 정보를 공유 스마트 그리드 : 기존의 전력망에 정보기술(IT)을 접목하여 전력 공급자와 소비자가 양방향으로 실시간 정보를 교환함으로써 에너지 효율을 최적화하는 차세대 지능형 전력망 NFC : 10cm 이내의 가까운 거리에서 다양한 무선 데이터를 주고받는 통신 기술 IAM : 조직이 필요로 하는 보안 정책을 수립하고 정책에 따라 자동으로 사용자의 계정과 권한을 관리하는 솔루션 NScreen : 하나의 콘텐츠를 스마트폰ㆍPCㆍ스마트TVㆍ태블릿PCㆍ자동차 등 다양한 디지털 정보기기에서 공유할 수 있는 컴퓨팅ㆍ네트워크 서비스 APT : 다양한 IT 기술과 방식들을 이용해 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격 제우스 : 사용자의 온라인 뱅킹 계정 정보를 탈취하기 위해 개발된 상용 멀웨어 DES : 데이터 암호화 표준으로, 대표적인 비밀키 암호화 기법 widget : 컴퓨터에서 운영체제의 응용 프로그램을 동작시키고 결과를 화면에 표시하는 작은 그래픽사용자 인터페이스(GUI) 도구 죽음의 핑 : 인터넷 프로토콜 허용 범위 이상의 패킷을 고의로 전송하여 발생한 서비스 거부 공격 인터넷 제어 메시지 프로토콜 : 인터넷 프로토콜과 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로의 변경 등을 위한 제어 메시지를 취급하는 무연결 전송용의 프로토콜 SYN : 동기식 신호 방식에서 동기를 유지하기 위한 신호로 사용되는 전송 제어 문자 UWB : 초광대역을 사용하는 초고속의 무선 데이터 전송 기술 WPA : Wi-Fi에서 제정한 무선 랜 인증 및 암호화 관련 표준 동기식 접속 지향 링크(SCO) : 블루투스 데이터 링크의 하나. 두 장비 간에 음성과 같이 지정된 대역폭 통신을 위한 전용 회선의 동기식 접속 방법이다. 스턱스넷 : 독일 지멘스사의 원격 감시 제어 시스템(SCADA)의 제어 소프트웨어에 침투하여 시스템을 마비하게 하는 악성 코드 래드섹 : 네트워크 이용자의 인증을 위해 전송 제어 프로토콜 ‘RADIUS over TLS(Transport Layer Security)’의 준말 OWASP : 개방형 웹 애플리케이션 보안 프로젝트 스니핑 : 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나 BLE : 저전력 저용량 데이터 송수신이 가능한 블루투스 기술 인포러스트 : 정보와 열광의 합성어로 ‘정보열광자’라고도 한다 텔레매틱스 : 통신과 정보과학의 합성어로 자동차와 컴퓨터·이동통신 기술의 결합을 의미하는 개념 킬스위치 : 분실한 정보기기를 원격으로 조작해 개인 데이터를 삭제하고 사용을 막는 일종의 자폭 기능 SAN : 광저장장치영역 네트워크 스마트 카 : 자동차와 IT 기술을 융합하여 인터넷 접속이 가능한 자동차 씬 클라이언트 : 서버 기반 컴퓨팅 AR : 실제 화면에 가상의 정보를 덧붙여 보여주는 기술. 집단 지성 : 다수의 개체가 서로 협력하거나 경쟁하여 얻게 되는 지적 능력의 결과로 얻어진 집단적 능력 시멘틱 웹 : 컴퓨터가 이해할 수 있는 웹 DOS : 시스템에 과도한 부하를 일으켜 정보 시스템의 사용을 방해하는 공격 방식 유선급 프라이버시 : 유선 랜(LAN)에서 기대할 수 있는 것과 같은 보안과 프라이버시 수준의 무선 랜(WLAN)의 보안 프로토콜 LTE : 3세대 이동통신(3G)을 ‘장기적으로 진화’시킨 기술이란 뜻에서 붙여진 명칭 기밀성 : 정보보안 3가지 목표 중 인가된 사용자만 정보 자산에 접근할 수 있는 것을 의미 IPIN : 인터넷에서 주민등록번호 대신 쓸 수 있도록 만든 사이버 주민등록번호 IT 규제준수 : 기업의 활동이 정보시스템에 의존하는 바 기업이 따라야 하는 규정과 지침 및 법규를 준수하는 것 에스크로 : 전자 상거래 등에서 구매자와 판매자 사이에 중개 서비스 회사가 개입해 상품 인도와 대금 지불을 대행해 주는 서비스 OCAP : 모든 종합 유선 방송(CATV)에서 운용될 수 있도록 대화형(interactive) 텔레비전 서비스나 응용 프로그램을 설계할 수 있는 자바(Java) 기반의 미들웨어 소프트웨어 계층을 포함하는 디지털 케이블 방송 미들웨어 표준 데이지 : 시각장애인이나 독서 장애인을 위한 국제 디지털 문서 포맷 저작권 라이선스 통합 관리 시스템 : 정부가 디지털 저작물에 대한 체계적인 관리를 위해 추진하고 있는 시스템 사이버 스토킹 : 정보 통신망을 이용해 악의적인 의도로 지속적으로 공포감이나 불안감 등을 유발하는 행위 사이버 불링 : 특정인을 사이버상에서 집단적으로 따돌리거나 집요하게 괴롭히는 행위 RVC : 하나의 디지털 미디어 기기에서 다양한 콘텐츠를 재생할 수 있도록 만든 표준 WBAN : 몸에 심는(implant) 형태의 센서나 기기를 무선으로 연결하는 개인 영역 네트워킹 기술 그린 IT : 정보 기술(IT) 전 분야에서 유해 물질 사용을 자제하고 에너지 절감을 통해 친환경 제품과 서비스를 제공하는 개념 WBS : 광대역 전송을 지원하는 무선 통신 시스템 PKI : 공개 키 암호 시스템을 안전하게 사용하고 관리하기 위한 정보 보호 표준 방식 CA : 보안 적격 여부 및 메시지 암호화를 위한 공개 키의 발급과 관리를 담당하는 신뢰성이 보장된 온라인상의 기관 XML : 하이퍼텍스트 생성 언어(HTML) 기능을 확장할 목적으로 월드 와이드 웹 컨소시엄(WWW Consorsium)에서 표준화한 페이지 기술 언어 BCP : 재난 발생 시 비즈니스의 연속성을 유지하기 위한 계획 인증서 폐기 목록 : 더 이상 유효하지 않은 인증서 목록 보안토큰 : 전자 서명 생성 키 등 비밀 정보를 안전하게 저장, 보관할 수 있고 기기 내부에 프로세스 및 암호 연산 장치가 있어 전자 서명 키 생성, 전자 서명 생성 및 검증 등이 가능한 하드웨어 장치 DDOS : 감염된 대량의 숙주 컴퓨터를 이용해 특정 시스템을 마비시키는 사이버 공격 LED : 전류가 흐르면 빛을 방출하는 다이오드의 한 종류 복호화 : 암호화 과정의 역과정 이중인증 : 기존의 아이디 및 비밀번호에 의한 인증 외에 인증 수단을 추가적으로 사용토록한 것 W3C : 월드 와이드 웹 브라우저/서버 기술의 표준화를 추진하고 있는 교육/연구 기관 및 관련 회사들의 단체 메타데이터 : 일련의 데이터를 정의하고 설명해 주는 데이터 생체 인식 : 개인마다 다른 신체 정보를 이용하여 개인을 식별하는 인증방법 증분 백업 : 데이터 영역 중 변경되거나 증가된 데이터만을 백업 받는 방식 RTO : 비상사태 또는 업무중단 시점부터 업무가 복구되어 다시 정상가동 될 때까지의 시 무결성 : 정보보안 3가지 목표 중 적절한 권한을 가진 사용자에 의해 인가된 방법으로만 정보를 변경할 수 있도록 하는 것을 의미한다. 가용성 : 정보보안 3가지 목표 중 정보 자산에 대해 적절한 시간에 접근 가능한 것을 의미한다. 살라미 : 이탈리아 소시지를 얇게 썬다는 의미로 계좌를 불법으로 조금씩 옮기는 해킹 다크 데이터 : 정보를 수집한 후, 저장만 하고 분석에 활용하고 있지 않는 다량의 데이터 블록 체인 : 온라인 금융 거래 정보를 블록으로 연결하여 피투피(P2P) 네트워크 분산 환경에서 중앙 관리 서버가 아닌 참여자(피어, peer)들의 개인 디지털 장비에 분산·저장시켜 공동으로 관리하는 방식 그레이웨어 : 정상 소프트웨어와 바이러스 소프트웨어의 중간에 해당하는 일종의 악성 소프트웨어 타이포스쿼팅 : 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 일 파밍 : 합법적으로 소유하고 있던 사용자의 도메인을 탈취하거나 도메인네임시스템(DNS) 이름을 속여 사용자들이 진짜 사이트로 오인하도록 유도하여 개인 정보를 훔치는 신종 인터넷 사기 수법 QOS : 인터넷이나 네트워크 상에서 전송률 및 에러율과 관련된 서비스 품질을 가리키는 말 QOE : 서비스 이용자가 각자의 기대치(expectation)에 근거하여 주관적으로 인지하는 어플리케이션 혹은 서비스의 총체적인 허용도 AJAX : 비동기적인 웹 애플리케이션의 제작을 위해 자바스크립트 언어와 기타 웹 표준을 사용하는 기술 제로데이 공격 : 보안 취약점이 발견되었을 때 그 문제의 존재 자체가 널리 공표되기도 전에 해당 취약점을 악용하여 이루어 지는 보안 공격 크라우드소싱 : 군중(crowd)과 외부 용역(outsourcing)의 합성어 IPV6 : IPv4 프로토콜의 주소가 32비트라는 제한된 주소 공간 및 국가별로 할당된 주소가 거의 소진되고 있다는 한계점으로 인해 지속적인 인터넷 발전에 문제가 예상되어, 이에 대한 대안으로 개발된 프로토콜 LBSNS : 스마트폰에 내장된 GPS수신기를 통해 고객의 위치를 인식하고 이를 바탕으로 각종 이벤트의 정보공유, 의사소통까지 가능하게 하는 서비스. DMB : 음성, 영상 등 다양한 멀티미디어 신호를 디지털 방식으로 고정·휴대·차량용 수신기에 제공하는 방송 서비스 지상파 DMB : ITU-R의 디지털 라디오의 표준 DSB System A(Eureka-147)에 기반하여 우리나라에서 개발한 지상파 디지털 멀티미디어 방송 표준 킬러앱 : 오랜 기간 시장을 지배하고 있던 경쟁자를 압도한 소프트웨어 EA : 기업의 목표와 요구 사항을 효과적으로 지원하기 위해 정보 기술(IT) 인프라 각 부분의 구성과 구현 기술을 체계적으로 기술하는 작업 디지털 포렌식 : ‘컴퓨터 법의학’이라 불리는데 전자증거물을 사법기관에 제출하기 위해 휴대폰, PDA, PC, 서버 등에서 데이터를 수집 분석하는 디지털수사과정 펨토셀 기지국 : 사무실이나 집에 설치하는 초소형 이동 통신 기지국 NRI : 세계 경제 포럼(WEF)이 국제적인 경영대학인 인시아드(INSEAD)와 공동으로 개인과 정부, 기업의 정보통신기술(ICT) 발전도와 경쟁력을 국가별로 평가한 지수 데이터 마이닝 : 각 데이터의 상관관계를 인공 지능 기법을 통해 자동적으로 찾아 주는 과정 EDI : 기업 간 전자상거래 서식 또는 공공 서식을 서로 합의된 표준에 따라 표준화된 메시지 형태로 변환해 거래 당사자끼리 통신망을 통해 교환하는 방식 고객 관계 관리 : 기업이 고객을 관리하기 위해 필요한 방법론이나 소프트웨어 등을 가리키는 용어 VOIP : 공중 교환 전화망(PSTN)을 통해 이루어졌던 음성 서비스를 IP 네트워크를 통해 음성을 디지털 패킷의 형태로 전달하는 기술 CTTH : 기존 케이블 방송망으로 초고속/대용량 서비스를 제공하는 새로운 전송 방식. 총 1Gbps 용량을 여러 가입자가 공유하는 구조로 일반 가정에 130Mbps의 빠른 인터넷 속도를 제공 C4I : 군의 전 자원을 전산화하고 네트워크로 연결해 효율적인 전쟁을 수행할 수 있도록 한 통합 전장 관리 체계 멀웨어 : 악의적인 목적으로 작성된 것으로 악성 코드(Malicious Code) 또는 악성 프로그램(Malicious Program) 등으로 불린다 SEO : 검색 엔진에서 검색했을 때 상위에 나타나도록 관리하는 것 특허괴물 : 특허권을 비롯한 지적 재산권을 통해 로열티 수입만으로 이익을 창출하는 특허 관리 전문 기업 건물 에너지 관리 시스템 : 빌딩 내 에너지 관리 설비의 다양한 정보를 실시간 수집ㆍ분석해 에너지 사용 효율을 개선하는 시스템 우주클럽 : 자국 영토에서 자국 기술로 인공위성 및 우주선 발사가 가능한 국가들의 모임 글로나스 : 러시아의 전파 위성 항법 시스템이다 SSO : 단 한번의 로그인만으로 기업의 각종 시스템이나 인터넷 서비스에 접속하게 해주는 보안 응용 솔루션 OTP : 로그인 할 때마다 그 세션에서만 사용할 수 있는 일회성 패스워드를 생성하는 보안 시스템 위성DMB : 디지털 비디오·오디오 및 데이터 등의 방송 프로그램 신호를 위성 송신 설비 및 지상 중계 설비를 이용해 극초단파 대역에서 방송하는 것 VHF : 파장이 더 긴 전파와는 달리 이 전파는 대기에서 심하게 반사하지 않기 때문에 지구의 굴곡을 따라 쉽게 휘지 않고 따라서 지평선 너머로는 전송할 수 없다. LBS : 이동성(Mobile) 기기를 통해 각종 교통 및 생활 정보를 실시간으로 받아 삶의 질을 향상시키는 서비스를 총칭 ITS : 교통수단 및 교통 시설에 전자·제어 및 통신 등 첨단 기술을 접목하여 교통 정보 및 서비스를 제공하고 이를 활용함으로써 교통 체계의 운영 및 관리를 과학화·자동화하고, 교통의 효율성과 안전성을 향상시키는 교통 체계 GPS : 1970년대 초 미국 국방부가 지구 상에 있는 물체의 위치를 측정하기 위해 만든 군사용 시스템이었다. 그러나 오늘날에는 미 의회의 승인을 거쳐 민간부문에서도 사용되고 있다 GIS : 지도에 관한 속성 정보를 컴퓨터를 이용해서 해석하는 시스템 데이터 웨어하우스 : 정보와 창고의 의미가 합성되어 만든 어휘 데이터 마트 : 데이터의 한 부분으로서 특정 사용자가 관심을 갖는 데이터들을 담은 비교적 작은 규모의 데이터 웨어하우스 EIS : 기업의 상급 경영 관리직의 전략 구상을 지원할 목적으로 구축된 시스템 위피 : 한국형 무선 인터넷 플랫폼 표준 규격 그룹웨어 : 여러 사람이 함께 쓸 수 있는 소프트웨어 부여 리눅스 : 공개소프트웨어 리눅스의 한국형 데스크톱 및 서버용 운영체제 표준 배포판 롱테일 : 1년에 단 몇 권밖에 팔리지 않는 ‘흥행성 없는 책’들의 판매량을 모두 합하면, 놀랍게도 ‘잘 팔리는 책’의 매상을 추월한다는 온라인 판매의 특성을 이르는 개념 망 중립성 : 모든 네트워크 사업자는 모든 콘텐츠를 동등하게 취급하고 어떠한 차별도 하지 않아야 한다는 원칙 반달리즘 : 다수가 참여할 수 있도록 공개된 문서의 내용을 훼손하거나 엉뚱한 제목으로 변경하고 낙서를 하는 일 OSMU : 우수한 기획을 통해 제작된 1차 콘텐츠를 시장에 성공 시킨후 재 투자 및 라이센스를 통해 2차, 3차 콘텐츠로 발전시키는 전략 포스트넷 : 우체국 택배와 국제 특별 수송(EMS)을 강화하기 위해 우편물에 RFID 칩을 달아 언제 어디서나 실시간으로 그 우편물의 위치를 확인할 수 있는 우편 물류 시스템","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-알고리즘","slug":"정보처리기사-알고리즘","date":"2018-10-04T11:38:18.000Z","updated":"2018-11-26T07:22:24.497Z","comments":true,"path":"2018/10/04/정보처리기사-알고리즘/","link":"","permalink":"http://eunajjing.github.io/2018/10/04/정보처리기사-알고리즘/","excerpt":"","text":"알고리즘과 소프트웨어 개발 소프트웨어 생명주기 개발 타당성 검토 개발 계획 수립 요구사항 분석 소프트웨어 설계 소프트웨어 구현 테스트 운용 유지보수 소프트웨어 관리요구관리형상관리유지관리품질관리 효율성 신뢰성 기능성 사용성 이식성 유지보수성 알고리즘의 효율성공간 효율성 고정 공간 가변 공강시간 효율성 (빅오 표기법) 번역 시간 실행 시간 소프트웨어 아키텍처 MVC 구조 C/S 구조 다층 구조 저장소 구조 객체지향설계의 개념과 원리 분류화 캡슐화 추상화 일반화 다형성 동적 바인딩 소프트웨어 디자인 패턴 리팩토링 SOLID : 객체지향설계의 5대 원칙 단일 책임의 원칙 개방 폐쇄 원칙 리스코프 교환 원칙 인터페이스 분리 원칙 의존관계 역전 원칙 소프트웨어 테스트 기법 화이트박스 테스트 기법 블랙박스 테스트 기법 소프트웨어 3R 재공학 역공학 재사용 소프트웨어 개발 방법론폭포수 방법론애자일 방법론 스크럼 XP","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-DB_4","slug":"정보처리기사-DB_4","date":"2018-10-01T10:37:51.000Z","updated":"2018-10-07T08:18:39.983Z","comments":true,"path":"2018/10/01/정보처리기사-DB_4/","link":"","permalink":"http://eunajjing.github.io/2018/10/01/정보처리기사-DB_4/","excerpt":"","text":"인덱스 인덱스 파일 : 데이터의 위치 관리 [키 값, 주소] 데이터 파일 : 실제 데이터 기억 인덱스 구조B-트리: 검색 효율을 높이기 위해 자료 구조를 트리 구조로 나타내는 방법 B+-트리: B-트리의 변형으로 인덱스 세트와 순차 세트로 구성 클러스터드 인덱스 하나의 속성을 기준으로 정렬 후 테이블을 재구성해 인덱스를 만드는 방법 물리적 순서와 인덱스 순서 동일 하나의 테이블에 하나의 인덱스 넌 클러스터드 인덱스 주소값으로 인덱스를 만들어 검색 여러 개의 인덱스 OODB 객체 속성 메시지 메소드 클래스 캡슐화 상속 다형성 복합 객체 : 한 객체가 가진 속성으로 다른 객체를 이용하기 위한 것, FK와 유사한 개념 보안정보 보안의 목표 기밀성 : 허락되지 않은 대상이 정보의 내용을 알 수 없도록 하는 것 무결성 : 허락되지 않은 대상이 정보를 수정/삭제할 수 없는 것 가용성 : 허락된 대상이 정보에 접근하고자 할 때 방해받지 않는 것 보안 어휘 평문과 암호문 암호화와 복호화 대칭키 시스템 : 암호화와 복호화의 키가 동일 비대칭키 시스템 : 암호화할 때는 공개키, 복호화할 때는 비밀키 이용, 공개키와 비밀키를 키 페어라고 한다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-DB_3","slug":"정보처리기사-DB_3","date":"2018-10-01T09:59:27.000Z","updated":"2018-10-07T08:18:39.983Z","comments":true,"path":"2018/10/01/정보처리기사-DB_3/","link":"","permalink":"http://eunajjing.github.io/2018/10/01/정보처리기사-DB_3/","excerpt":"","text":"이상과 정규화 이상DB 내 데이터의 중복과 종속으로 인해 발생되는 문제점 삭제 이상: 원하지 않는 자료까지 함께 삭제가 이루어지는 이상 삽입 이상 : NULL이면 안되는 값에 NULL이 들어가 삽입이 안되는 이상 갱신 이상 : 갱신 과정에서 일부만 갱신되어 정보의 파악이 안되는 현상 함수적 종속 완전 함수 종속 부분 함수 종속 이행적 함수 종속 정규화 제1정규형(원자값): 한 릴레이션을 구성하는 모든 도메인이 원자값으로만 구성 제2정규형(부분 함수 종속 제거): 모든 속성이 기본키에 완전 함수 종속이 되도록 구성 제3정규형(이행적 함수 종속 분해) 보이스-코드 정규형(후보키가 아닌 결정자 관계 제거): 릴레이션에서 모든 결정자가 후보키(PK)가 되도록 하는 과정 제4정규형(다치 종속 관계 제거) 제5정규형(조인 종속 관계 제거): 조인 종속이 후보키를 통해서만 성립이 되도록 하는 정규형 역정규화릴레이션 역정규화릴레이션 병합릴레이션 분할 수직 분할 수평 분할 속성 역정규화(파생 속성 추가)트랜잭션 원자성 : 모두 수행되거나 모두 수행되지 않거나 일관성 : 완료되면 일관성 있는 DB 상태여야 한다 격리성 : 하나의 트랜잭션이 수행 중에는 다른 트랜잭션이 접근 할 수 없음 영속성 : 트랜잭션이 성공적으로 완료된 후 결과는 지속적으로 유지되어야 함 트랜잭션 스케줄 직렬 스케줄 : 순차적 비직렬 스케줄 : 비순차적 직렬 가능 스케줄 : 직렬 스케줄 기법의 결과와 비직렬 스케줄 기법의 결과가 동일하게 나오는 경우 회복 로그 : 트랜잭션이 수행되어 변경되는 데이터베이스 상황 정보를 기록(로그파일)하는 것 회복 기법 즉시 갱신 기법 : 트랜잭션 실행 중에 변경되는 내용을 바로 DB에 적용 지연 갱신 기법 : 트랜잭션이 부분 완료되면 DB에 적용 검사 시점 기법 : 트랜잭션 실행 중 검사 시점을 지정해 그 때 완료된 내용을 DB에 적용 그림자 페이징 : 로그를 사용하지 않고, DB를 동일한 크기의 단위인 페이지로 나누어 각 페이지마다 복사하여 보관하는 기법. 장애가 발생되면 그림자 페이지를 이용해 회복 REDO(재수행) UNDO(취소)병행 제어: 여러 트랜잭션이 실행되는 경우 트랜잭션 간의 격리성을 유지해 에러가 발생하지 않도록 하는 것 병행 제어를 하지 않았을 때의 문제점 갱신 분실 모순성 연쇄 복귀 비완료 의존성 : 하나의 트랜잭션 수행이 실패한 후 회복되기 전 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상 로킹 트랜잭션의 고립성 같은 것, 하나의 트랜잭션이 이미 DB에 접근해 있으면 다른 트랜잭션이 접근하지 못하게 막음 LOCK과 UNLOCK, 교착 상태가 있다. 공유락과 배타락이 있다. 2단계 로킹 기법에는 확장 단계와 축소 단계가 있다. 타임 스태프: 각 트랜잭션이 데이터에 접근할 시간을 미리 지정해 기억시킨 뒤 그 시간의 순서에 따라 순서대로 데이터에 접근하여 수행하는 방법","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사-DB_2","slug":"정보처리기사-DB_2","date":"2018-09-28T11:01:27.000Z","updated":"2018-10-07T08:18:39.982Z","comments":true,"path":"2018/09/28/정보처리기사-DB_2/","link":"","permalink":"http://eunajjing.github.io/2018/09/28/정보처리기사-DB_2/","excerpt":"","text":"SQL DDL제약조건 primary key unique foreign key ~ references ~ check(속성명 = 범위 값) constraint 제역조건명 제약조건(속성명) 스키마 정의create schema 스키마명 authorization 유저명; 도메인 정의create domain 도메인명 데이터타입; 도메인에도 속성에 줄 수 있는 check 제약조건을 똑같이 명시 가능 (디폴트 값, check(value in(‘값’, ‘값’))) 인덱스 정의create index 인덱스명 on 테이블명(속성명) 외래키 지정 옵션 on delete on update cascade set null set default no action DML (헷갈리는 것 위주로 용어만 정리) order by(asc, desc) exists: 부속 질의문의 검색 결과 존재 여부에 따라 메인 쿼리 진행 여부가 달라짐 DCL grant: grant 권한내용 on 테이블명 to 유저명 [with grant option] with grant option: 자신이 가진 권한을 다른 유저에게도 부여가 가능하다 revoke: revoke 권한내용 on 테이블명 from 유저명 [cascade] 만약 권한을 취소 당한 유저가 다른 유저에게 해당 권한을 부여했다면, 그 권한 또한 연쇄적으로 취소된다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"정보처리기사 - DB_1","slug":"정보처리기사-DB_1","date":"2018-09-28T04:02:15.000Z","updated":"2018-10-07T08:18:39.982Z","comments":true,"path":"2018/09/28/정보처리기사-DB_1/","link":"","permalink":"http://eunajjing.github.io/2018/09/28/정보처리기사-DB_1/","excerpt":"","text":"데이터베이스 데이터베이스의 정의 공용 데이터 통합된 데이터: 하나의 주제에 따라 중복을 최소화한 데이터의 집합 저장된 데이터 운영 데이터 데이터베이스의 특징 내용에 의한 참조 계속적인 변화 동시 공유 실시간 접근성 데이터 중복의 최소화 DBMS: 사용자와 데이터베이스 간의 중계 역할을 하여 모든 사용자나 응용 프로그램들이 데이터베이스를 공유할 수 있도록 관리, 운영해주는 소프트웨어 시스템 데이터베이스의 특성 중복성 종속성 데이터베이스 언어 DCL DML DDL 스키마: 데이터베이스의 전체적인 구조와 제약조건 명세를 기술, 정의한 것 스키마 종류 설명 내부 스키마 물리적 저장 장치 관점 개념 스키마 논리적 사용자 관점 외부 스키마 사용자가 사용하는 한 부분에서 본 논리적 구조, 서브 스키마 데이터베이스 설계 요구 조건 분석 설계 설계 구분 개념적 설계 구축할 db 정하기, db 구성요소 정하기, 관계 설계 논리적 설계 사용자가 알아볼 수 있는 형태로 변환, 스키마 정의 물리적 설계 기계가 처리하기에 알맞게 내부 저장 장치 구조와 접근 경로 설계 구현 운영 및 개선(유지보수) 관계 데이터 모델 릴레이션: 테이블 속성 튜플: 레코드 도메인 릴레이션 인스턴스 : 튜플들의 집합 차수 : 속성의 수 카디널리티 : 튜플의 수 릴레이션의 특징 릴레이션의 튜플은 모두 상이하다. 릴레이션의 튜플들은 유일하며 순서에는 의미가 없다. 릴레이션의 속성들 간의 순서는 의미가 없다. 릴레이션의 속성 값은 원자값으로 구성되며 분해가 불가능하다. 유일성과 최소성 유일성 : 각 튜플을 유일하게 식별하는 성질 최소성 : 유일성을 만족하되 최소 구성으로 이루어진 것 무결성 제약조건 개체 무결성 : pk와 같은 것 참조 무결성 도메인 무결성 고유 무결성 null 무결성 키 무결성 : 하나의 릴레이션에는 하나 이상의 튜플이 존재해야만 한다. 관계 데이터 연산관계대수(절차적 언어)셀렉트(σ선택조건(테이블명))프로젝트(π칼럼명(테이블명))조인(테이블명▷◁조건 테이블명) 동일 조인 자연 조인 외부 조인 세타 조인 디비전(테이블명1(테이블명1의 속성 ÷ 테이블명2의 속성)테이블명2)일반 집합 연산자 합집합 교집합 차집합 카디션 프로덕트 관계해석(비절차적 언어, {결과값|조건})ex. {학점,이름|학점^학점.수강번호=’7777’^학점.점수&gt;=80} 용어 뷰 : 가상 테이블로 물리적으로 기억공간을 차지하지 않으며, 논리적 독십성을 제공하고 데이터 접근제어로 보안성 향상 내장 SQL : 일반 응용 프로그램에 SQL을 삽입해 DB 이용 및 조작을 할 수 있도록 한 것 커서 : 튜플 단위로 처리하는 것 declare : 사용할 커서 선언open : 커서를 첫 번째 튜플로 이동fetch : 다음 튜플로 이동close : 커서 종료 스토어드 프로시저 튜닝 : DB 시스템 최적화를 위해 재조정 하는 것 CRUD 매트릭스 : 응용 시스템과 DB 간의 업무 분석을 위한 상관 분석표 트리거 행 이주 : 저장 공간이 없을 때 블럭을 옮겨 저장하는 현상으로 데이터 타입이 varchar일 때 발생, 검색이 느려진다 행 연결 : 저장 공간이 적어 새로 입력하려는 데이터의 일부만 저장하고 일부는 다른 블럭에 저장해 두 블럭을 연결하는 방법 OLAP : 사용자가 직접 DB 검색과 분석을 통해 문제점이나 해결책을 찾도록 해주는 분석형 애플리케이션 MOLAP : 다차원 배열ROLAP : 관계형 DB를 기초로 함HOLAP : MOLAP + ROLAP 스타 스키마 : 활동한 내용을 수치로 표현한 사실 테이블, 추가적인 관점을 제공하는 차원 테이블로 구성\\ OLTP : 사용자 단말기에서 요청한 트랜잭션 처리를 중앙 컴퓨터에 처리해 처리 결과를 사용자 측으로 되돌려 보내는 처리 형태 시스템 카탈로그(=데이터 사전) : 개체들에 대한 정보와 정보들 간의 관계를 저장한 것(시스템 테이블) 메타 데이터 : 시스템 카탈로그 안에 저장된 데이터, 정보의 정보 DBA : DB 시스템의 전체적인 관리 운영에 책임을 지는 사람이나 집단 DA : 데이터 정의와 체계화, 감독 및 보안 업무를 담당하는 관리자이며 데이터에 대한 관리를 총괄하고 정보 활용에 대한 계획수립과 통제 수행자 E-R Model Mapping Rule : 개념적 데이터베이스 모델링에서 관계형 데이터베이스로 변환하는 과정 교차 엔티티 : 다대다 관계를 구현하기 위해 추가로 생성되는 엔티티 슈퍼키 : 후보키+다른 속성들과의 모든 조합으로, 유일성은 만족하지만 최소성은 만족하지 않는다.","categories":[{"name":"개발공부","slug":"개발공부","permalink":"http://eunajjing.github.io/categories/개발공부/"},{"name":"정보처리기사","slug":"개발공부/정보처리기사","permalink":"http://eunajjing.github.io/categories/개발공부/정보처리기사/"}],"tags":[]},{"title":"first","slug":"first","date":"2018-09-24T00:08:52.000Z","updated":"2018-09-24T13:51:00.093Z","comments":true,"path":"2018/09/24/first/","link":"","permalink":"http://eunajjing.github.io/2018/09/24/first/","excerpt":"","text":"깃허브를 이용해서 블로그 만들기 그러니까, 도전은 한 3일 정도 된 듯참고 도움이 많이 된 포스트1도움이 많이 된 포스트2 보통 블로그로는 지킬과 헥소를 많이 사용하는 것 같은데,처음 블로그를 할 수 있음을 알려준 이가 헥소를 사용 중이기도 했고,헥소가 검색이 더 잘된다는 말이 있어서 나도 헥소로 만들기로 결정하고 만들기 위해 엄청 끙끙댔다. 저장소만 한 5번은 다시 만든 듯ㅋㅋㅋㅋ 왜인지 계속 경로 에러가 나서, 노드도 다시 깔고 별 짓을 다했다. 솔직히 아직…. 나는 포털 사이트가 제공해주는 블로그 사이트가 제일 편한 것 같은데. 어쨌든 개발자를 꿈꾸는데 블로그 하나 제대로 못 만들면 안될 것 같아서ㅠㅠㅠㅠ 정처기 시험 며칠 남지도 않았는데 이러고 있다. 때려칠 뻔한 대환장에러파티hexo YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line ~ 나는 수많은 이들이 구글과 깃의 이슈로 물은 YAMLException 때문에 대부분의 시간을 버렸다. 재미있게도 핵소 공홈에도 이 에러…는 트러블슈팅으로까지 올라와있는데, 나에게 있어서 별 도움은 안됐다. 핵소 공홈 트러블 슈팅// 18.09.24. 기준 제일 윗줄에서 확인 가능 대부분의 사람들이 해결책이라며 내놓은 건, 따옴표 표기 같은 거였다. 화가 난 나는 에러 메시지가 뜬 줄부터 아래까지 모조리 따옴표를 넣어버리는 미친 짓도 벌여봤지만 계속 에러 잼…ㅎㅎㅎ… 헥소 나한테 외그래… 며칠 째 똑같은 에러를 보고 있자니 너무 화가 나서 걍 딴짓할 겸 헥소의 트러블 슈팅 모두를 읽기 시작. 그러다가… Make sure you are using soft tabs and add a space after colons. 몇 번 반복하다가 맨 윗 문단의 마지막 문장이 눈에 띄어서, 혹시나 해서 살펴봤는데…. 내가 그 콜론 다음에 띄어쓰기를 잘못한 사람이었고…. 내가 추가로 쓴 옵션 칼럼에는 모조리 띄어쓰기가 없어서 나는 에러였다. 아니 근데 웃긴 게 그럼 띄어쓰기 없는 라인부터 에러라고 말을 해줘야지 왜 얘는 요상한 곳에서 에러 표기를 하는 거람. 웹단 처음 들어와서 강사님이 에러가 나면 그 줄부터 보지 말고, 그 위부터 읽는 거라고 그렇게 귀에 뭐가 박힐 듯 잔소리를 해댔는데. 여기서도 똑같은 실수를 했다. 모든 헥소를 이용한 깃허브 블로그 가이드에는 브랜치 두 개 만들라는 팁이 있어야 하는 거 아닌가? 사실 블로그 배포에 성공한 건 한 3번 정도인데, 매번 당황하고 지웠던 건 다름 아닌 소스 관리를 어떻게 해야할지 모르겠다는 거. 아예 파일 구조가 달라져버리는 터라, 풀 받는데 계속 에러가 났다. 구글링을 좀 해보니, 저장소를 아예 두 개 파서 운용하시는 분도 계셨고, 브랜치를 두 개 판 분도 계셨다-사실 브랜치 두 개가 다수였다- 아니 그러면 처음부터 브랜치 두 개 파라고 이야기를 해주던가ㅠㅠㅠ(위에 내가 참고했다는 블로그에는 아쉽게도 브랜치 두 개 생성 얘기는 없었다) 농담이 아니라 이 블로그 때문에 명절 연휴 통째로 날릴 삘….","categories":[{"name":"일상","slug":"일상","permalink":"http://eunajjing.github.io/categories/일상/"}],"tags":[]}]}