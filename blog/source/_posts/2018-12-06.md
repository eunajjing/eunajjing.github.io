---
title: 2018-12-06 수업 내용 정리
date: 2018-12-06 09:45:18
tags:
categories:
- 개발공부
- 뉴딜과정
---

## MVC 모델

### MVC 모델1

- JSP가 요청을 받는 Controller의 역할을 하면서 동시에 View의 역할도 하는 것

### MVC 모델2

- Servlet이 Controller의 역할
- JSP가 View의 역할

- Service도 Model의 역할을 한다, DAO만 Model이 아님
  - 업무 로직
  - 트랜젝션 관리

> ## component
>
> - 부품, 역할적인 의미가 강조될 때 사용되는 용어
> - object, instance, bean...

##  JSP 실행 방식

- JSP를 실행하고 싶다는 요청이 들어오면
- JSP 엔진이 JSP를 JAVA 소스로 만든다
- 이것은 httpServlet을 상속 받은 서블릿 소스가 된다 
- 이것은 `.class`파일이 되어 실행되는 것
- JSP는 서블릿 클래스를 만드는 재료로 사용되는 것
- 때문에 JSP는 template이라고 불리기도 한다
- 즉 **JSP는 직접 실행되는 것이 아님**
- 직접 print.out할 필요가 없어서 사용하는 것

### JSP 안의 <% %>

- Domain-Specific language = DSL

  ```jsp
  <%@ page language="java" contentType="text/html; charset=UTF-8"
      pageEncoding="UTF-8"%>
  ```

- 위에 선언하는 이유

- 그런데 JAVA만 사용이 가능
  (향후 다른 언어도 가능하게 하려고 만들었다)

## 스코프

1. 서버가 시작되며 **웹 어플리케이션** 실행
   - 하나의 서버에는 여러 개의 웹 어플리케이션이 실행될 수 있다
   - 정확히 말하면 웹 어플리케이션이 시작하면
2. **ServletContext** 보관함이 생성
   - 이것은 웹 앱을 종료할 때까지 보관함은 유지된다.
   - 이 보관함에는 **IOC Container**가 대표적으로 있다.
3. **클라이언트가 최초로 서버에 접속하는 순간**에 **HttpSession** 객체가 생성되며 Session을 무효화할 때 보관함이 사라진다.
4. 유저 단에서 요청이 들어오면 **ServletRequest** 보관함이 생기고, 응답할 때까지 보관함은 유지된다.
5. **JSP**는 자신만의 **PageContext** 스코프를 가진다 JSP가 실행되는 동안에만 유지되는 보관소이다. 때문에 응답이 완료되지 않더라도, 다른 JSP로 실행이 옮겨가는 순간 사라진다.



- `sendRedirect`로 이동시킬 때는 상대 경로로 지정해도 된다. 브라우저의 입장에서 경로를 인식하기 때문

- 서버에서 `include`, `forward`시키는 경우에는 루트부터 시켜줘야 한다

> ## Expression Language(EL 태그)
>
> - 표현언어
> - ${}
> - Expression : 결과를 리턴하는 것
> - 때문에 태그 안에는 결과를 리턴하는 값이 와야 함
> - Statment의 일부 (if, else의 {} 등)
>
> ## OGNL
>
> - 오브젝트 그래프 네비게이션 언어
> - EL 태그 안에서 쓸 수 있다
> - 객체 안의 객체를 가리킬 때 쓰는 표기법

> html meta tag 중에 실행 후 reloading을 지원하는 태그가 있다
>
> ```jsp
> <meta http-equiv="Refresh" content="1;url=list">
> // 1초 후에 어디로 리로딩하겠다
> ```

## component

- button에 타입이 지정이 안되면 기본 submit 버튼

## Filter

- 필터 역할을 할 클래스는 `Filter` 인터페이스를 상속 받아야 함
- `dofilter`메서드를 구현
  - `init()`
  - `detory()`

```java
인터페이스 {
    default 리턴타입 메서드() {
        정의
    }
}
```

- 원래 인터페이스는 메서드를 구현할 수 없으나,  인터페이스에 기본적으로 적용이 되는 메서드을 추가 시키기 위해 사용

- `init`와 `detory`가 대표적인 default 메서드

```java
필터 인터페이스를 상속 받은 필터 클래스 {
	@Override
	doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
		chain.doFilter(request, response);
		// 이 필터 다음에 또 다른 필터가 있다면 그 필터 실행
		// 없다면 원래 목적지인 servlet 실행
	}
}
```

- 필터에 `sertCharacterEncoding`같은 공통으로 들어가는 메서드를 추가하면 편하다

```java
@webFilter("*")
```

- 어노테이션 기입이 필요하다.

