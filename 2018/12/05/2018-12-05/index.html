<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="keywords" content="hexo, autumn">
    <title>
        ERecord
    </title>
    <!-- favicon -->
    
    <link rel="icon" href="http://osly086qe.bkt.clouddn.com/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">

    <!-- highlight -->
    <link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/github-gist.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad()
    </script>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="http://osly086qe.bkt.clouddn.com/hexo-infinite-scroll-v1.0.1.min.css">
    <script src="http://osly086qe.bkt.clouddn.com/hexo-infinite-scroll-v1.0.3.min.js"></script>
    <script>
        infiniteScroll()

        // for mobile menu
        $(function() {
            $('.social-button').click(function() {
                if ($('.social-links').hasClass('hide-links')) {
                    $('.social-links').removeClass('hide-links')
                } else {
                    $('.social-links').addClass('hide-links')
                }
            })
        })
    </script>
</head>

    <body style="background: url(http://osly086qe.bkt.clouddn.com/button-bg.png) #f3f3f3">
        <div class="container">
            <header class="header">
    <h1 class="title">
        <a href="/" class="logo">
            ERecord
        </a>
    </h1>
    <h2 class="desc">
        일상 및 개발 공부 기록용 블로그
    </h2>

    <nav class="links">
        <button class="social-button">
            menu
        </button>
        <ul class="social-links hide-links">
                <li>
                    <a href="https://github.com/eunajjing">GITHUB
                    </a>
                </li>
<li><a href="https://uri.life/web/accounts/8579">CONNECTING</a>
</li>
        </ul>
    </nav>
</header>

                <main class="main">
                    <article class="post">
    
        <h4 class="post-cat">
            <a href="/categories/개발공부/">
                개발공부
            </a>
        </h4>
        
        <h4 class="post-cat">
            <a href="/categories/개발공부/뉴딜과정/">
                뉴딜과정
            </a>
        </h4>
        
            <h2 class="post-title">
                2018-12-05 수업 내용 정리
            </h2>
            <ul class="post-date">
                <li>
                    2018-12-05
                </li>
                <li>
                    euna
                </li>
            </ul>
            <div class="post-content">
                <h2 id="Bean-컨테이너"><a href="#Bean-컨테이너" class="headerlink" title="Bean 컨테이너"></a>Bean 컨테이너</h2><blockquote>
<h2 id="SW의-용어"><a href="#SW의-용어" class="headerlink" title="SW의 용어"></a>SW의 용어</h2><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><ul>
<li>일을 실행하는 역할</li>
</ul>
<h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><ul>
<li>해석하는 역할</li>
<li>엔진보다 협소한 의미, 실행까지 하면 엔진이라고 한다</li>
</ul>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><ul>
<li>객체의 생성과 소멸을 관리</li>
</ul>
<h3 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h3><ul>
<li>생성과 실행과 소멸을 담당하는 역할</li>
<li>컨테이너 + 엔진의 느낌</li>
</ul>
</blockquote>
<ul>
<li><p>Bean </p>
<ul>
<li>인스턴스, 오브젝트, 객체</li>
</ul>
</li>
<li><p>의존 객체 주입이 필요</p>
<ul>
<li>생성자에 파라미터로 던져주던 것들</li>
</ul>
</li>
<li><p>IOC Container(DI Container)</p>
<ul>
<li><p>의존 객체를 주입한 빈 컨테이너<br>(IOC != DI)<br>(IOC &gt; DI)</p>
</li>
<li><p>제어의 역행이 일어난다</p>
<ul>
<li><p>메인 흐름과 별개의 이벤트 핸들러(리스너) 메서드가 실행된다</p>
</li>
<li><p>생성하지 않은 객체가 외부에서 만들어져 주입 된다</p>
<blockquote>
<h2 id="IOC의-3대-예-중-2개"><a href="#IOC의-3대-예-중-2개" class="headerlink" title="IOC의 3대 예 중 2개"></a>IOC의 3대 예 중 2개</h2><ul>
<li>이벤트 리스너</li>
<li>DI = 의존 객체 주입(생성이 아님)</li>
</ul>
</blockquote>
</li>
<li><p>DI를 쓰면 좋은 점</p>
<ul>
<li><p>의존 객체 대체가 쉽다<br>(예를 들어 지불 수단이라는 인터페이스 급의 객체를 DI해서 넣어두면, 지불 수단 인터페이스를 상속 받은 돈, 카드 등의 재화도 주입이 가능)</p>
</li>
<li><p>단위 테스트가 쉽다</p>
<p>(예를 들어 원래 과일을 가는 믹서기를 만든다고 했을 때, 믹서기를 만드는 도중 테스트를 한다고 가정하자. 과일까지 모두 조달해서 믹서기를 작동하는 구조 OR 믹서만 작동이 가능한 구조 중에 단위 테스트가 쉬운 건 후자. 테스트할 때 과일 외에도 다양한 식품을 넣어볼 수 있다.)</p>
</li>
<li><p>쓸모 없는 데이터의 생성을 최소화할 수 있다<br>(자원 낭비가 덜 함)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Spring-IOC-Container"><a href="#Spring-IOC-Container" class="headerlink" title="Spring IOC Container"></a>Spring IOC Container</h2><blockquote>
<p>spring 공부 다시 해야할 듯…</p>
</blockquote>
<ol>
<li><p><code>dependncies</code>에 <code>Spring-context</code> 의존 설정을 해준다.<br>(maven에서 검색함)</p>
</li>
<li><p>Spring Ioc 설정 파일 추가</p>
<ul>
<li><p>xml로 설정하거나</p>
</li>
<li><p>class로 설정하는 방법 두 개</p>
<ul>
<li><p>AppConfig.java(Class) 작성</p>
<ul>
<li><p>만약 내가 만든 클래스가 아니라서, 즉 IOC Container가 자동으로 생성할 수 없는 경우 메서드를 정의하여 직접 객체를 생성해야 한다.</p>
<ul>
<li>mybatis 관련 객체의 경우가 대표적으로, sqlSessionFactory가 가 그렇다.</li>
</ul>
</li>
<li><p>SqlSessionFactory 객체를 생성하는 메서드 추가</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.eomcs.lms;</span><br><span class="line"></span><br><span class="line">// ioc Container에게 패키지 이름을 알려준다</span><br><span class="line">// 이름을 알려주면 그 패키지를 뒤져서 @conponent가 붙은 클래스에 대해</span><br><span class="line">// 인스턴스를 자동으로 생성</span><br><span class="line">@ComponentScan(&quot;com.eomcs.lms&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">  @Bean // Spring IOC Container에게 이 메서드를 호출하여 리턴 값을 보관하라고 표시하는 어노테이션</span><br><span class="line">  public SqlSessionFactory createSqlSessionFactory() throws Exception&#123;</span><br><span class="line">    String resource = &quot;com/eomcs/lms/conf/mybatis-config.xml&quot;;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    return new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    // 리턴 값을 저장할 때 사용할 이름을 따로 지정하지 않으면 메서드 이름으로 저장되기에</span><br><span class="line">    // 이런 메서드의 이름은 동사가 아닌 객체의 이름인 명사 형태로 짓는다</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이름 지정하는 방법<code>@Bean(&quot;이름&quot;)</code>은 이러하지만 잘 사용하지 않는다. </p>
</li>
<li><p>dao 클래스는 내가 만든 클래스므로, 해당 클래스 위에 객체 자동생성하도록 설정</p>
<p>이 때 당연히 인터페이스는 객체 생성이 불가하므로, 상속 받은 클래스에 어노테이션 <code>@Component</code> 이용</p>
</li>
<li><p>Spring Boot</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>xml 설정이 아닌 java class로 설정한다</li>
</ul>
</blockquote>
</li>
<li><p>Spring IOC Container 준비</p>
<ul>
<li><p>실행 클래스에 Spring IOC Container 객체 준비</p>
</li>
<li><p>실행 클래스에서 해당 소스 기술</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext iocContainer = new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure>
<p>그리고 이 소스를</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command commandHandler = commandMap.get(command);</span><br></pre></td></tr></table></figure>
<p>이렇게 변경</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Command commandHandler = (Command) iocContainer.getBean(command);</span><br><span class="line">        // 빈을 찾으면 정상 실행, 빈을 못 찾으면 예외가 발생</span><br><span class="line">        // 때문에 if else가 아니라 try catch 처리</span><br></pre></td></tr></table></figure>
<p>차후에 iocContainer도 <code>close()</code> 필요</p>
<blockquote>
<h2 id="Class-정보를-보고자-할-때"><a href="#Class-정보를-보고자-할-때" class="headerlink" title="Class 정보를 보고자 할 때"></a>Class 정보를 보고자 할 때</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;     Class&lt;?&gt; clazz = Class.forName(&quot;com.eomcs.lms.AppConfig&quot;);</span><br><span class="line">&gt;     // AppConfig 클래스가 메모리에 로딩되어 있지 않다면 로딩 후 클래스 정보 리턴</span><br><span class="line">&gt;     // 어떤 클래스라도 상관 없이 받기 위해 제네릭 &lt;?&gt;</span><br><span class="line">&gt;     // class가 이미 사용되는 예약어라 clazz로 객체 이름 설정이 일반적</span><br><span class="line">&gt;     // AppConfig.class와 같다.</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     // Reflection 클래스 : JVM에 로딩되어 있는 있는 클래스와 메소드 정보를 읽어 올 수 있다</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     Method[] methods = clazz.getMethods();</span><br><span class="line">&gt;     // 클래스의 모든 메서드들이 들어온다</span><br><span class="line">&gt; </span><br><span class="line">&gt;     Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">&gt;     // 생성자의 정보</span><br><span class="line">&gt;     Class&lt;?&gt; returnType = methods[0].getReturnType();</span><br><span class="line">&gt;     // 메서드의 리턴 타입</span><br><span class="line">&gt;     Parameter[] params = methods[0].getParameters();</span><br><span class="line">&gt;     // 메서드에 들어가는 파라미터</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     ApplicationContext iocContainer = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">&gt;     // 확장자(.class)가 아닌 클래스 변수명임을 기억할 것</span><br><span class="line">&gt;     System.out.println(iocContainer.getBeanDefinitionCount());</span><br><span class="line">&gt;     // 몇 개의 객체 생성을 했는지</span><br><span class="line">&gt;     String[] names = iocContainer.getBeanDefinitionNames();</span><br><span class="line">&gt;     // 생성된 객체들의 이름을 리턴</span><br><span class="line">&gt;     </span><br><span class="line">&gt;     for (String name : names) &#123;</span><br><span class="line">&gt;       System.out.printf(&quot;%s ===&gt; %s\n&quot;, name, iocContainer.getBean(name).getClass().getName());</span><br><span class="line">&gt;       // 객체 이름 ===&gt; 경로 출력됨</span><br><span class="line">&gt;       // 객체의 이름을 지정하지 않았다면 클래스명 맨 앞 대문자를 소문자로 변경해 사용</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="Spring-IOC-컨테이너와-mybatis-연동"><a href="#Spring-IOC-컨테이너와-mybatis-연동" class="headerlink" title="Spring IOC 컨테이너와 mybatis 연동"></a>Spring IOC 컨테이너와 mybatis 연동</h2><ul>
<li><p><code>buid.gradle</code>에 <code>mybatis-spring</code> 의존 설정 추가</p>
</li>
<li><p>sqlSessionFactory 객체 생성</p>
<ul>
<li><p><code>mybatis-spring</code>에서 제공하는 도우미 클래스를 사용해 만드는 것으로 메서드 변경</p>
<ul>
<li>apache common-dbcp 라이브러리 추가<br>datasource 구현체(db 커넥션풀 객체)</li>
<li><code>buid.gradle</code>에 <code>commons-dbcp2</code> 의존 설정 추가</li>
</ul>
<p>기존 소스가 이런 상태에서 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public SqlSessionFactory sqlSessionFactory() throws Exception &#123;</span><br><span class="line">  String resource = &quot;com/eomcs/lms/conf/mybatis-config.xml&quot;;</span><br><span class="line">  InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">  return new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 변경하고,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123;</span><br><span class="line">    </span><br><span class="line">    SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">    </span><br><span class="line">    // datasource 주입</span><br><span class="line">    factoryBean.setDataSource(dataSource);</span><br><span class="line">    </span><br><span class="line">    return factoryBean.getObject();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>클래스 위에 <code>@PropertySource</code> 어노테이션을 더 추가해주고, 가져오는 프로퍼티 파일이 들어갈 수 있도록 <code>@value</code> 어노테이션도 클래스 변수 위에 기술해준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// spring ioc Container에게 프로퍼티 파일을 로딩할 것을 명령</span><br><span class="line">@PropertySource(&quot;classpath:/com/eomcs/lms/conf/jdbc.properties&quot;)</span><br><span class="line">// 프로퍼티가 있는 위치를 가리키되, 기술하는 방식을 지켜야 한다.</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">  @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">  String jdbcDriver;</span><br><span class="line">  @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">  String jdbcUrl;</span><br><span class="line">  @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">  String jdbcUserName;</span><br><span class="line">  @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">  String jdbcPassword;</span><br></pre></td></tr></table></figure>
<p>객체 생성 메서드를 만들어준다. (basic datasource 방식)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public DataSource dataSource() &#123;</span><br><span class="line">  BasicDataSource dataSource = new BasicDataSource();</span><br><span class="line">  dataSource.setDriverClassName(jdbcDriver);</span><br><span class="line">  dataSource.setUrl(jdbcUrl);</span><br><span class="line">  dataSource.setUsername(jdbcUserName);</span><br><span class="line">  dataSource.setPassword(jdbcPassword);</span><br><span class="line">  return dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 db 커넥션을 java 파일에서 하므로, <code>mybatis-config.xml</code>에서 중복 기술 사항을 삭제한다.</p>
<ul>
<li>db 커넥션 풀</li>
<li>db 연결 정보를 담은 프로퍼티 파일 로딩</li>
</ul>
</li>
</ul>
</li>
<li><p>트랜젝션 관리자</p>
<ul>
<li><p>spring 트랜젝션 관련 라이브러리 의존 설정(<code>Spring JDBC</code>) 추가</p>
</li>
<li><p><code>AppConfig</code>에 PlatformTransactionManager를 리턴하는 메서드 구현</p>
<ul>
<li><p>이 때 이 객체의 이름은 반드시 transactionManager로 설정</p>
<ul>
<li>다른 이름으로 설정하면 트랜젝션과 관련한 다른 객체를 생성할 때 그 객체가 트랜젝션 관리자를 자동으로 찾지 못한다.</li>
</ul>
<p>생성자 메서드 소스는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public PlatformTransactionManager platformTransactionManager(DataSource dataSource) &#123;</span><br><span class="line">    return new DataSourceTransactionManager(dataSource);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>이제 db 트랜젝션 관리 또한 java 파일에서 하므로, <code>mybatis-config.xml</code>에서 중복 기술 사항을 삭제한다.</p>
</li>
</ul>
</li>
<li><p>도메인 클래스에 별명 구현</p>
<ul>
<li><p>SqlSessionFactory를 반환하는 메서드에 다음의 설정을 세팅한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factoryBean.setTypeAliasesPackage(&quot;com.eomcs.lms.domain&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>마찬가지로 별명 지정 또한 java 파일에서 했으므로, <code>mybatis-config.xml</code>에서 중복 기술 사항을 삭제한다.</p>
</li>
</ul>
</li>
<li><p>SQL을 보관한 XML 파일 경로 또한 java 파일에서 가능</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">  public SqlSessionFactory sqlSessionFactory(DataSource dataSource, ApplicationContext iocContainer) throws Exception &#123;</span><br><span class="line">    </span><br><span class="line">    SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">    </span><br><span class="line">        factoryBean.setMapperLocations(iocContainer.getResources(&quot;classpath:/com/eomcs/lms/mapper/*Mapper.xml&quot;));</span><br><span class="line">    // sql mapper 로딩</span><br><span class="line">    // sql 파일이 있는 위치를 파라미터로 보내야 하는 상황</span><br><span class="line">    // sql 파일의 위치 정보를 resource 객체에 담아 넘겨야 함</span><br><span class="line">    // resource 객체는 Spring IOC Container를 통해 만들 수 있다.</span><br><span class="line">    // Spring IOC Container 객체를 얻는 방법 : 메서드의 파라미터로 받는다.</span><br><span class="line">    // 이 경우 ioc container 생성은 실행 클래스에서 하기에</span><br><span class="line">    // 실행 클래스에서 해당 객체가 넘어온다.</span><br><span class="line">    </span><br><span class="line">    return factoryBean.getObject();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>mybatis-config.xml</code>가 더 이상 필요 없다</strong></p>
</li>
</ul>
<h2 id="웹-어플리케이션-이론"><a href="#웹-어플리케이션-이론" class="headerlink" title="웹 어플리케이션 이론"></a>웹 어플리케이션 이론</h2><ul>
<li>웹 브라우저는 http 프로토콜에 맞춰서 웹 서버에 요청한다.</li>
<li><p>웹 서버는 우리가 만든 프로그램을 실행해서 결과를 받아서 http 프로토콜 규칙에 맞춰 응답해야 한다.</p>
</li>
<li><p>그런데 웹서버의 역할은 프로그램을 실행하는 게 아니다. 웹서버는 정적 웹 리소스 html, css, java script, png, jpeg 등을 읽어서 웹 브라우저에게 리턴하는 게 원래 역할이다. 웹서버가 프로그램을 실행해야하는 상황이니까 프로그램을 실행할 중간 객체를 필요로 하게 된다.</p>
<blockquote>
<p>실행해야 하는 리소스(DB와 같은 것)은 동적 리소스(Dynamic Web Resource)</p>
</blockquote>
</li>
<li><p>ioc container는 웹서버의 요청이 들어오면 메서드를 호출해 프로그램을 실행시켜 리턴 값을 전달한다.</p>
</li>
<li><p>웹 서버는 웹 브라우저로 http 프로토콜 규칙에 맞춰 리턴 값을 응답한다.</p>
</li>
<li><p>웹 브라우저는 응답 받은 것에 맞춰 화면을 출력한다.</p>
</li>
</ul>
<h3 id="웹-어플리케이션이란"><a href="#웹-어플리케이션이란" class="headerlink" title="웹 어플리케이션이란"></a>웹 어플리케이션이란</h3><ul>
<li><p>웹 기반으로 프로그램 실행되는 자바 프로그램</p>
</li>
<li><p>웹 어플리케이션이 하나의 객체로 이루어진 게 아닌 만큼, 기능을 잘게 쪼개서 하나의 클래스가 하나의 기능을 수행하게끔 만들어야 한다.</p>
</li>
<li><p>웹 어플리케이션은 서버 프로그램인데 간단한 작업만을 수행한다.</p>
</li>
<li><p>때문에 서버 어플리케이션의 작은 조각이라는 의미로 접미사 let을 붙인다. </p>
<h4 id="서블릿-Servlet"><a href="#서블릿-Servlet" class="headerlink" title="서블릿(Servlet)"></a>서블릿(Servlet)</h4></li>
<li><p>웹 어플리케이션을 구성하는 요소들</p>
</li>
<li><p>작은 서버 프로그램</p>
<h4 id="서블릿-컨테이너-WAS"><a href="#서블릿-컨테이너-WAS" class="headerlink" title="서블릿 컨테이너(WAS)"></a>서블릿 컨테이너(WAS)</h4></li>
<li><p>웹 서버 상에서 실행되는 자바 컨테이너</p>
</li>
<li><p>서블릿 컨테이너의 대표적인 예는 톰캣</p>
<ul>
<li>서블릿 컨테이너는 이미 다운 받아 사용하는 것이고</li>
<li>개발자는 서블릿을 만드는 것</li>
</ul>
</li>
<li><p>웹 서버, 웹 브라우저는 종속이 아니지만(http 프로토콜 규칙 때문)</p>
</li>
<li>서블릿은 서블릿 컨테이너에 종속된다. 예를 들어 버전이 맞지 않는다면 실행되지 않는다.</li>
<li><p>서블릿 컨테이너와 서블릿이 통신할 수 있도록 규칙이 있고 이들은 인터페이스로 구성되어 있다.</p>
<ul>
<li>서블릿</li>
<li>필터</li>
<li>리스너</li>
</ul>
</li>
<li><p>규칙이 들어 있는 인터페이스들이 자동으로 들어있는 것은 JAVA EE(웹 기술와 분산 기술-EJB-, 웹 서비스 기술, 자원 관리 기술)</p>
<ul>
<li>대표적인 것 : 자바 EE 구현체<ul>
<li>웹로직</li>
<li>웹스피어(IBM 서버)</li>
<li>JBoss</li>
<li>Glasspish</li>
<li>Geronemo</li>
<li>톰캣 : EE 모두 구현이 아닌 웹 기술만 뽑아서 만든 것</li>
<li>Jeus</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="웹-어플리케이션을-구성하는-요소"><a href="#웹-어플리케이션을-구성하는-요소" class="headerlink" title="웹 어플리케이션을 구성하는 요소"></a>웹 어플리케이션을 구성하는 요소</h3><ul>
<li>서블릿</li>
<li>필터</li>
<li>리스너</li>
</ul>
<h3 id="servlet의-메서드"><a href="#servlet의-메서드" class="headerlink" title="servlet의 메서드"></a>servlet의 메서드</h3><p>인터페이스로 구현되어 있는 기본 5개의 메서드</p>
<ul>
<li>init()</li>
<li>service()</li>
<li>detory()</li>
<li>getServletInfo()</li>
<li>getServletConfig()</li>
</ul>
<p>서블릿 구현</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 어노테이션을 이용해 톰캣 서버에 서블릿이 있음을 알리고</span><br><span class="line">// 루트 디렉토리부터 쓴 url을 매핑해준다.</span><br><span class="line">// 톰캣 서버에 서블릿을 추가한 후 서블릿을 변경하면 일정 시간이 지난 후 리로딩 가능</span><br><span class="line">// 추가하는 경우에만 서버 재시작 필요</span><br><span class="line">@WebServlet(&quot;/board/list&quot;)</span><br><span class="line">public class BoardListServlet implements Servlet&#123;</span><br><span class="line"></span><br><span class="line">(4개의 메서드 생략)</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void service(ServletRequest req, ServletResponse res)</span><br><span class="line">      throws ServletException, IOException &#123;</span><br><span class="line">    res.setContentType(&quot;text/palin;charset=utf-8&quot;);</span><br><span class="line">    PrintWriter out = res.getWriter();</span><br><span class="line">    // 클라이언트 쪽에 출력할 때 필요한 객체준비</span><br><span class="line">    out.println(&quot;게시물 목록&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class BoardListServlet extends GenericServlet &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>이렇게 추상클래스 <code>GenericServlet</code>을 상속 받아도 된다. <code>GenericServlet</code>에는 <code>service</code>메서드를 제외한 메서드가 구현이 되어 있기에 <code>service</code>만 구현하면 된다.</p>
<p>또한 <code>HttpServletRequest</code>와 <code>HttpServletResponse</code>를 파라미터로 사용하기 위해 추상클래스 <code>HttpServlet</code>(<code>GenericServlet</code>을 상속 받음)을 상속 받아도 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BoardListServlet extends HttpServlet&#123;</span><br><span class="line">	@Override</span><br><span class="line">  public void service(HttpServletRequest req, HttpServletResponse res)</span><br><span class="line">      throws ServletException, IOException &#123; .. &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HttpServletRequest</code>와 <code>HttpServletResponse</code>를 파라미터로 사용할 수 있는  <code>service</code>는 <code>doget</code> 과 <code>dopost</code> 호출이 가능하다.</p>
<ul>
<li><code>httpServlet</code>은 <code>service</code> 실행 시 부모인 <code>GenericServlet</code>에 정의된 <code>service</code>메서드를 부르고, 이 메서드는 다시 <code>HttpServletRequest</code>와 <code>HttpServletResponse</code>를 파라미터로 쓰는  <code>service</code>메서드를 내부적으로 부르며 실행된다.</li>
<li><strong>서블릿 컨테이너는 바로 <code>doget</code>과 <code>dopost</code>를 직접 부르지 못한다.</strong></li>
</ul>
<h3 id="filter의-메서드"><a href="#filter의-메서드" class="headerlink" title="filter의 메서드"></a>filter의 메서드</h3><ul>
<li>init()</li>
<li>service()</li>
<li>detory()</li>
</ul>
<h3 id="listener의-메서드"><a href="#listener의-메서드" class="headerlink" title="listener의 메서드"></a>listener의 메서드</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">public class ContextLoaderListener implements ServletContextListener&#123;</span><br><span class="line">  // 웹 어플리케이션이 시작되거나 종료될 때 호출되는 메서드를 정의한 것</span><br><span class="line">  </span><br><span class="line">  AnnotationConfigApplicationContext iocContainer;</span><br><span class="line">  // 다른 메서드에서도 접근이 가능하도록 전역변수로 올린다.</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    System.out.println(&quot;웹 어플리케이션이 종료될 때 자동 호출&quot;);</span><br><span class="line">    // Spring IOC Container 자원을 해제</span><br><span class="line">    iocContainer.close();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">    // TODO Auto-generated method stub</span><br><span class="line">    System.out.println(&quot;웹 어플리케이션이 시작될 때 자동으로 호출&quot;);</span><br><span class="line">    </span><br><span class="line">    // AppConfig 클래스가 메모리에 로딩되어 있지 않다면,</span><br><span class="line">    // Spring IoC 컨테이너 준비하기</span><br><span class="line">    iocContainer = </span><br><span class="line">        new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">    </span><br><span class="line">    System.out.println(iocContainer.getBeanDefinitionCount());</span><br><span class="line">    String[] names = iocContainer.getBeanDefinitionNames();</span><br><span class="line">    </span><br><span class="line">    for (String name : names) &#123;</span><br><span class="line">      System.out.printf(&quot;%s ===&gt; %s\n&quot;, name, </span><br><span class="line">          iocContainer.getBean(name).getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    // Spring IOC Container를 servlet이 사용할 수 있도록</span><br><span class="line">    // servletContext라는 보관소에 저장</span><br><span class="line">    ServletContext sc = sce.getServletContext();</span><br><span class="line">    // 파라미터로 들어온 ServletContextEvent를 이용해 IOC Container를 받을 준비</span><br><span class="line">    sc.setAttribute(&quot;iocContainer&quot;, iocContainer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>WAS가 요청을 받으면 <code>service</code> 메서드가 실행되며 <code>doget</code>이나 <code>dopost</code> 실행됨</p>
</li>
<li><p>servlet 호출됨</p>
<ul>
<li><p>이 순간부터 IOC Container가 관리하는 게 아니라 관리자가 WAS로 넘어감</p>
</li>
<li><p>그런데 dao부터는 IOC Container가 관리</p>
</li>
<li><p>때문에 servlet에 IOC Container의 주소를 알려줘야 함</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.setAttribute(&quot;iocContainer&quot;, iocContainer);</span><br></pre></td></tr></table></figure>
<p>이 작업이 이루어지는 이유</p>
<p>그리고 <code>HttpServlet</code>를 상속 받은 <code>BoardListServlet</code> 소스 코드는 다음과 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 어노테이션을 이용해 톰캣 서버에 서블릿이 있음을 알리고</span><br><span class="line">// 루트 디렉토리부터 쓴 url을 매핑해준다.</span><br><span class="line">@WebServlet(&quot;/board/list&quot;)</span><br><span class="line">public class BoardListServlet extends HttpServlet&#123;</span><br><span class="line">  </span><br><span class="line">  ApplicationContext iocContainer;</span><br><span class="line">  BoardDao boardDao;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void init() throws ServletException&#123;</span><br><span class="line">    // 서블릿 인터페이스에 정의된 init(ServletConfig)가 먼저 호출되고, init(ServletConfig)가 init()를 호출하는 것</span><br><span class="line">    // 톰캣이 바로 호출하는 게 아님</span><br><span class="line">    // boardDao 객체를 꺼내기 위해 먼저 IOC Container를 꺼낸다.</span><br><span class="line">    ServletContext sc = this.getServletContext();</span><br><span class="line">    // ServletContext는 웹 어플리케이션 당 한 개 뿐이다.</span><br><span class="line">    // ContextLoaderListener에서 꺼낸 것과 같은 객체가 온다.</span><br><span class="line">     iocContainer = (ApplicationContext) sc.getAttribute(&quot;iocContainer&quot;);</span><br><span class="line">    // 오브젝트 자료형이 리턴되어 applicationcontext 인터페이스로 받는다</span><br><span class="line">    </span><br><span class="line">     try &#123;</span><br><span class="line">       boardDao = iocContainer.getBean(BoardDao.class);</span><br><span class="line">     &#125;catch (Exception e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void service(HttpServletRequest req, HttpServletResponse res)</span><br><span class="line">      throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    res.setContentType(&quot;text/palin;charset=utf-8&quot;);</span><br><span class="line">    PrintWriter out = res.getWriter();</span><br><span class="line">    // 클라이언트 쪽에 출력할 때 필요한 객체준비</span><br><span class="line">    out.println(&quot;게시물 목록&quot;);</span><br><span class="line">    </span><br><span class="line">    try &#123;</span><br><span class="line">      List&lt;Board&gt; list = boardDao.findAll();</span><br><span class="line">      </span><br><span class="line">      for (Board board : list) &#123;</span><br><span class="line">        out.printf(&quot;%3d, %-20s, %s, %d\n&quot;, </span><br><span class="line">            board.getNo(), </span><br><span class="line">            board.getContents(), </span><br><span class="line">            board.getCreatedDate(), </span><br><span class="line">            board.getViewCount());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>servlet에서 dao 도달</p>
</li>
<li><p>dao에서 mariaDB 도달</p>
</li>
</ul>
<h2 id="설정"><a href="#설정" class="headerlink" title="설정"></a>설정</h2><h3 id="서블릿-어플리케이션-개발에-사용할-라이브러리-추가"><a href="#서블릿-어플리케이션-개발에-사용할-라이브러리-추가" class="headerlink" title="서블릿 어플리케이션 개발에 사용할 라이브러리 추가"></a>서블릿 어플리케이션 개발에 사용할 라이브러리 추가</h3><ul>
<li><p>build.gradle에서 빌드 명령 사용이 가능할 수 있도록 설정</p>
<ul>
<li><code>eclipse</code> 대신 <code>eclipse-wtp</code> 플러그인 추가</li>
<li>웹 어플리케이션 배치 파일(<code>.war</code>)을 만들 <code>war</code> 플러그인 추가</li>
<li>단독으로 실행이 불가하므로 <code>application</code> 플러그인도 제거</li>
<li><code>mainClassName = &#39;App&#39;</code> 도 제거</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &apos;java&apos;</span><br><span class="line">    id &apos;eclipse-wtp&apos;</span><br><span class="line">    id &apos;war&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>servlet-api</code> 의존 설정</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">providedCompile group: &apos;javax.servlet&apos;, name: &apos;javax.servlet-api&apos;, version: &apos;4.0.1&apos;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>providedCompile</code> : 개발하는 동안에만 사용하겠다</li>
<li><code>compile</code> : 개발하는 동안에도 사용하고, 배포 시에도 함께 쓰겠다.</li>
</ul>
</li>
<li><p><code>src/main/webapp</code> : 웹 자원을 둘 디렉토리 생성</p>
</li>
</ul>

            </div>
</article>

                </main>
                <aside class="aside">
                    <section class="aside-section">
                        
    <h1>Categories</h1>

    <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/개발공부/">개발공부</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/개발공부/nodeJS/">nodeJS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/개발공부/뉴딜과정/">뉴딜과정</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/개발공부/몽고DB/">몽고DB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/개발공부/안드로이드/">안드로이드</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/개발공부/정보처리기사/">정보처리기사</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/일상/">일상</a></li></ul>

                    </section>
                    <section class="aside-section">
                        
    <h1>Archives</h1>

    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a></li></ul>


                    </section>
                    <section class="aside-section tag">
                        
    <h1>Tags</h1>

    

                    </section>
                </aside>
        </div>
    </body>

</html>